[2024-27-08 09:26:10 INFO] **[Preprocessing]**

**ChatDev Starts** (20240827092610)

**Timestamp**: 20240827092610

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}


**project_name**: RealWorld_BA_101_PCLActiveStage.t

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_101_PCLActiveStage.t_RealWord_20240827092610.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-27-08 09:26:10 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStage is PCLParent {     using SafeMath for uint256;     using SafeMath for uint128; uint256 requestId;  // enum PooledCreditLineStatus { //     NOT_CREATED, //     REQUESTED, //     ACTIVE, //     CLOSED, //     EXPIRED, //     LIQUIDATED, //     CANCELLED // }  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE); }  function test_cannotStartActivePCL() public {     try borrower.start(requestId) {         revert('cannot start active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     // verified using the borrower verifier instead of lender verifier     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_nonLenderCannotWithdrawLiquidity() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);     try _pooledCreditLineLender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL1');     } }  function test_lenderCannotWithdrawLiquidity() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotLendToActivePCL() public {     LenderInfo memory info = lenders[0];     PCLUser lender = PCLUser(info.lenderAddress);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendToActivePCLNewLender() public {     // Creating a new lender for lending     PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     lender.registerSelf(mockAdminVerifier1);     admin.transferToken(request.borrowAsset, address(lender), 100_000);     lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin)); }  function test_onlyBorrowerCanBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;     PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker)); }  function assert_borrowByInvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _user = PCLUser(_actor);     if (_actor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try admin.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try _user.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotBorrowMoreThanPossible() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);      try borrower.borrow(_id, _amountBorrowable + 1) {         revert('Borrower should not be able to borrow more than possible');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB3');     } }  function test_borrowerCannotBorrowZeroAmount() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.borrow(_id, 0) {         revert('Borrower should not be able to borrow zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB1');     } }  function test_lenderDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress); }  function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress); }  function test_adminDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin)); }  function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin)); }  function assert_DepositAndCannotWithdrawCollateral_InvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _depositor,     address _withdrawer ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      // Depositing into PCL     if (_depositor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     } else {         PCLUser _user = PCLUser(_depositor);          admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     }      // withdrawing from PCL     if (_withdrawer == address(admin)) {         try admin.withdrawCollateral(_id, _collateralRequired, false) {             revert('Admin should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_withdrawer);          try _user.withdrawCollateral(_id, _collateralRequired, false) {             revert('Invalid actor should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     if (request.collateralRatio != 0) {         borrower.withdrawCollateral(_id, _withdrawableCollateral, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_lenderDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);     _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(_lender, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try _lender.withdrawAllCollateral(_id, false) {         revert('lender should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_adminDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(admin, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try admin.withdrawAllCollateral(_id, false) {         revert('admin should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_borrowerCannotWithdrawZeroAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     try borrower.withdrawAllCollateral(_id, false) {         revert('borrower should not be able to withdraw zero all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  function test_borrowerCannotWithdrawZeroCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try borrower.withdrawCollateral(_id, 0, false) {         revert('Withdrawing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC2');     } }  function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);      try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {         revert('Withdrawing more collateral than withdrawable should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  function test_borrowerCanWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_cannotCloseIfDebtIsNonZero() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow); }  function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));     borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));     // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));      try borrower.close(_id) {         revert('Borrower should not be able to close with non-zero debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  function test_lenderCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin)); }  function assert_invalidActorCannotClose(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, request.minBorrowAmount);      if (_actor == address(admin)) {         try admin.close(_id) {             revert('Admin should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.close(_id) {             revert('Invalid actor should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanRepayAndClose() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanRepayAndClose(_id, _amountToBorrow); }  function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(_id, _currentDebt);      _currentDebt = pcl.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0);      borrower.close(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED); }  function test_repayWithInsufficientBalance() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));     try borrower.repay(_id, _currentDebt) {         revert('REVERT: Insufficient Balance');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds allowance');         } else {             assertEq(reason, 'Dai/insufficient-allowance');         }     } }  function test_borrowerCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower)); }  function test_adminCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;     emit log_named_uint('request.borrowLimit', request.borrowLimit);     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin)); }  function assert_InvalidActorCannotLiquidate(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      if (_actor == address(admin)) {         try admin.liquidate(_id, true) {             revert('admin liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.liquidate(_id, true) {             revert('Invalid actor liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } }  function test_onlyLendersCanLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit / 3;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyLendersCanLiquidate(_id, _amountToBorrow); }  function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {     if (request.collateralRatio == 0) return;     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      PCLUser _lender = PCLUser(lenders[1].lenderAddress);     uint256 _amountLent = lenders[1].amount;     _lender.liquidate(_id, true);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_lenderCannotLiquidateZeroPrincipal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with zero principal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, _amountToBorrow / 2);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with if collateral ratio is more than ideal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  function test_borrowerCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotTerminate(_id); }  function assert_borrowerCannotTerminate(uint256 _id) public {     try borrower.terminate(_id) {         revert('Borrower terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_lenderCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotTerminate(_id); }  function assert_lenderCannotTerminate(uint256 _id) public {     PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));     try _lender.terminate(_id) {         revert('Lender terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_onlyAdminCanTerminate() public {     uint256 _amountToBorrow = request.borrowLimit;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyAdminCanTerminate(_id, _amountToBorrow); }  function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));     vm.roll(block.number + (request.duration / (2 * 20)));      uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));     admin.terminate(_id);     uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     } else {         assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     }     if (request.borrowAssetStrategy == compoundYieldAddress) {         assertGe(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } else {         assertEq(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } }  function test_depositCollateral() public {     uint256 _amount = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositCollateral(_id, _amount); }  function assert_depositCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());     admin.transferToken(address(collateralAsset), address(borrower), _amount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);     borrower.depositCollateral(_id, _amount, false);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));     assertEq(pcl.depositedCollateralInShares(_id), _shares); }  function test_depositCollateral_insufficientBalance() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);      admin.transferToken(address(collateralAsset), address(borrower), 10);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);     try borrower.depositCollateral(_id, 100, false) {         revert('Insufficient Balance of collateral tokens');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds balance');         } else {             assertEq(reason, 'SafeERC20: low-level call failed');         }     } }  function test_depositZeroCollateral() public {     uint256 _amount = 0;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositZeroCollateral(_id, _amount); }  function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));     borrower.setAllowance(         pooledCreditLineAddress,         address(collateralAsset),         100_000 * (10**ERC20(address(collateralAsset)).decimals())     );     try borrower.depositCollateral(_id, _amount, false) {         revert('Depositing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC1');     } }  function test_depositCollateralFromSavingsAccount() public {     request.collateralAssetStrategy = compoundYieldAddress;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));     emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);     if (request.collateralRatio != 0) {         borrower.depositToSavingsAccount(             savingsAccountAddress,             _collateralRequired,             address(collateralAsset),             compoundYieldAddress,             address(borrower)         );     }     uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));     emit log_named_uint('total tokens: ', _totalTokens);     uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);     emit log_named_uint('required collateral: ', _collateralRequired);     borrower.setAllowanceForSavingsAccount(         savingsAccountAddress,         _collateralRequired,         address(collateralAsset),         pooledCreditLineAddress     );     _helperDepositCollateral(borrower, _id, _collateralRequired, true);     uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);     emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);     // assertEq(_borrowAbleAmount, _amountToBorrow);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, true);     }     uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);     uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         pooledCreditLineAddress,         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);     assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14); }  function test_adminCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, address(admin)); }  function test_lenderCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress); }  function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {     if (_actor == address(admin)) {         try admin.cancelRequest(_id) {             revert('Admin cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);         try _user.cancelRequest(_id) {             revert('Invalid actor cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotCancelRequest() public {     assert_borrowerCannotCancelRequest(requestId); }  function assert_borrowerCannotCancelRequest(uint256 _id) public {     try borrower.cancelRequest(_id) {         revert('Canceling a PCL in active stage should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow); }  function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay zero current debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP3');     } }  function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow); }  function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay if interest is zero');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP4');     } }  function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     try _lender.transferLPTokens(address(borrower), _id, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_borrowerCannotReceivePoolTokens() public {     assert_borrowerCannotReceivePoolTokens(requestId);     request.borrowerVerifier = mockAdminVerifier1;     borrower.registerSelf(mockAdminVerifier1);     (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);     assert_borrowerCannotReceivePoolTokens(_id); }  function assert_canTransferPoolTokensToVerifiedUser(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     // borrowing some tokens     {         uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());         uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;         uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);         admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);         borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);         _helperDepositCollateral(borrower, _id, _collateralRequired, false);         borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);          // going ahead in time to generate interest         vm.warp(block.timestamp + 6 days);         // repaying the interest and some principal back         borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);         borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);     }      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender     _lender.withdrawInterest(_id);      uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     // calculating the receivers interest in shares     uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);     uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         receiverInterestInTokens,         address(borrowAsset)     );      uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);     _lender.transferLPTokens(_recevingAddress, _id, _amount);      uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);     assertEq(_finalBalance - _prevBalance, _amount);      uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;     curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;     assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14); }  function assert_cannotTransferEcxessPoolTokens(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _id, _amount) {         revert('balance less than the amount to transfer');     } catch Error(string memory reason) {         // assertEq(reason, 'ERC1155: insufficient balance for transfer');         assertEq(reason, 'SafeMath: subtraction overflow');     } }  function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     // testing when user is not verified     try _lender.transferLPTokens(_newUserAddress, _id, _balance) {         revert('should not have been possible to send LP tokens to not verified user');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT3');     } }  function test_lenderTransfersTokenToAnotherLender() public {     LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     address _recevingAddress = lenders[1].lenderAddress;     assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);     assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance); }  function test_lenderTransferTokenToNewUser() public {     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));      // testing when user is verified     _newUser.registerSelf(mockAdminVerifier1);      LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);      assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3); }  function test_areTokensTransferable() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     LenderInfo memory _lenderInfo = lenders[0];      address _recevingAddress = lenders[1].lenderAddress;     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  function test_canTransferPoolTokensWhenZeroInterest() public {     PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);     assertGe(_startBalanceLenderFrom, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);      PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);     uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);     assertGe(_startBalanceLenderTo, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);      _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);     assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));     assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo)); }  function test_cannotWithdrawZeroInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);      // cannot withdraw zero interest     vm.expectRevert(bytes('LP:WI1'));     _lender.withdrawInterest(requestId); }  function test_newPoolTokenHolderCanWithdrawInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _newUser.registerSelf(mockAdminVerifier1);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     _lender.transferLPTokens(address(_newUser), requestId, _balance);     uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);     assertEq(_newUserBalance, _balance);     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repaying the interest and some principal back     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // fetch borrowerInterestSharesWithdrawn for new user     uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     assertEq(_prevBISW, 0);     // get the interest for the new user     uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));     uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser     _newUser.withdrawInterest(requestId);     uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;     // match the interest shares withdrawn with the interest calculated     assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14); }  function test_stateAfterBorrow() public {     admin.updateProtocolFeeFraction(0);      uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('borrowable amount', _borrowableAmount);     assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);      uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));     borrower.borrow(requestId, _borrowableAmount);     uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));      assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);     assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14); }  function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());     _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     emit log_named_uint('_collateralRequired: ', _collateralRequired);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     // borrow some amount     uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());     if (_curBorrowAmount == _amountToBorrow) {         _curBorrowAmount = _curBorrowAmount.mul(90).div(100);     }     borrower.borrow(requestId, _curBorrowAmount);     // check borrow able amount     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     if (request.collateralRatio != 0) {         assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);     } else {         assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);     }     // now check withdrawableCollateral     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);     assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14); }  function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction); }  function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {     _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);     assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount)); }  function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {     if (request.collateralRatio == 0) return;     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);     uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));     emit log_named_uint('_maxCollateral: ', _maxCollateral);     emit log_named_uint('_minCollateral: ', _minCollateral);     _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);     emit log_named_uint('_collateralAmount: ', _collateralAmount);     _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);     emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);     // calulating what should borrowed to achieve _collateralRatioToAchieve     uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(         _collateralRatioToAchieve     );     emit log_named_uint('_amountToBorrow: ', _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);      uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('_maxBorrowable: ', _maxBorrowable);     if (         request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14     ) {         assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);         if (_amountToBorrow &gt; _maxBorrowable) {             _amountToBorrow = _maxBorrowable;         }     } else {         assertLe(_amountToBorrow, _maxBorrowable);     }      borrower.borrow(requestId, _amountToBorrow);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);      uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);     // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve     assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14); }  function test_closeActivePCLOncePrincipalPaidAndEnded() public {     // borrowing some tokens     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repay everything back     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _balance = borrowAsset.balanceOf(address(borrower));     if (_currentDebt &gt; _balance) {         admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));     }     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);     // go to end of pcl     vm.warp(block.timestamp + request.collectionPeriod + request.duration);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);     assertEq(0, borrowAsset.balanceOf(address(borrower))); }  event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);  function test_closeWhenNoCollateral() public {     vm.warp(block.timestamp + 6 days);     // close     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_closeWhenCollateral() public {     uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();     admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     vm.warp(block.timestamp + 6 days);     vm.roll(block.number + (6 * 86400) / 20);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));     vm.expectEmit(true, true, false, false);     emit CollateralSharesWithdrawn(requestId, _shares);     // close     borrower.close(requestId);     // this is equal only when no yield is used     // with compund this should be assertLe becuase deposited collateral would earn yield     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } else {         assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } }  event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare); event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);  function test_withdrawLiquidatedCollateral() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable.sub(10));     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable.sub(10),         address(borrowAsset)     );     // going ahead in time to make liquidation possible     vm.warp(block.timestamp + 50 days);     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);      uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;      vm.expectEmit(true, true, false, false);     emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } else {         assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } }  event PooledCreditLineTerminated(uint256 indexed id);  function test_terminateAfterLiquidation() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable);     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable,         address(borrowAsset)     );      // going ahead in time to make liquidation possible     vm.warp(block.timestamp + request.duration.mul(7).div(11));     vm.roll(block.number + request.duration.mul(7).div(11).div(20));     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;     vm.expectEmit(true, true, false, false);      emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);      uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));      uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));     emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);     // for an active pcl borrowLimit == total amount lent     _totalSupply = lp.totalSupply(requestId);     // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);     // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);     // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);      // now the admin terminates     vm.expectEmit(true, true, false, true);     emit PooledCreditLineTerminated(requestId);     admin.terminate(requestId);      assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));      if (request.borrowAssetStrategy == compoundYieldAddress) {         // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } else {         // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } }  function _helperDepositCollateral(     PCLUser _user,     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) private {     if (_amount != 0) {         _user.depositCollateral(_id, _amount, _fromSavingsAccount);     } }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLActiveStage is PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n\n    uint256 requestId;\n\n    // enum PooledCreditLineStatus {\n    //     NOT_CREATED,\n    //     REQUESTED,\n    //     ACTIVE,\n    //     CLOSED,\n    //     EXPIRED,\n    //     LIQUIDATED,\n    //     CANCELLED\n    // }\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function test_cannotStartActivePCL() public {\n        try borrower.start(requestId) {\n            revert('cannot start active pcl');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:S1');\n        }\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert('External user cannot create');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert('External user cannot terminate');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert('Lender cannot lend zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L1');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        // verified using the borrower verifier instead of lender verifier\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Unverified lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L2');\n        }\n    }\n\n    function test_nonLenderCannotWithdrawLiquidity() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        try _pooledCreditLineLender.withdrawLiquidity(requestId) {\n            revert('Lender cannot withdraw liquidity');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL1');\n        }\n    }\n\n    function test_lenderCannotWithdrawLiquidity() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.withdrawLiquidity(requestId) {\n            revert('Lender cannot withdraw liquidity');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n    }\n\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert('Non lender cannot withdraw liquidated collateral tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:WLC1');\n        }\n    }\n\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert('Lender cannot withdraw liquidated collateral tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    function test_cannotTransferLPTokensToSameAddress() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert('Lender cannot transfer LP tokens to itself');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT1');\n        }\n    }\n\n    function test_cannotBurnPoolTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert('Lender cannot burn LP tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'ERC1155: transfer to the zero address');\n        }\n    }\n\n    function test_cannotLendToActivePCL() public {\n        LenderInfo memory info = lenders[0];\n        PCLUser lender = PCLUser(info.lenderAddress);\n        try lender.lend(requestId, 100_000) {\n            revert('cannot lend to active pcl');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    function test_cannotLendToActivePCLNewLender() public {\n        // Creating a new lender for lending\n        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        lender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(request.borrowAsset, address(lender), 100_000);\n        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);\n        try lender.lend(requestId, 100_000) {\n            revert('cannot lend to active pcl');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    function test_lenderCannotBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);\n    }\n\n    function test_adminCannotBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));\n    }\n\n    function test_onlyBorrowerCanBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));\n    }\n\n    function assert_borrowByInvalidActor(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        PCLUser _user = PCLUser(_actor);\n        if (_actor == address(admin)) {\n            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n            _helperDepositCollateral(admin, _id, _collateralRequired, false);\n\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n            try admin.borrow(_id, _amountToBorrow) {\n                revert('Invalid user should not be able to borrow');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        } else {\n            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);\n            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n            _helperDepositCollateral(_user, _id, _collateralRequired, false);\n\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n            try _user.borrow(_id, _amountToBorrow) {\n                revert('Invalid user should not be able to borrow');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        }\n    }\n\n    function test_borrowerCannotBorrowMoreThanPossible() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);\n\n        try borrower.borrow(_id, _amountBorrowable + 1) {\n            revert('Borrower should not be able to borrow more than possible');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:IB3');\n        }\n    }\n\n    function test_borrowerCannotBorrowZeroAmount() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        try borrower.borrow(_id, 0) {\n            revert('Borrower should not be able to borrow zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:IB1');\n        }\n    }\n\n    function test_lenderDepositsAndCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);\n    }\n\n    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);\n    }\n\n    function test_adminDepositsAndCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));\n    }\n\n    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));\n    }\n\n    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _depositor,\n        address _withdrawer\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        // Depositing into PCL\n        if (_depositor == address(admin)) {\n            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n            _helperDepositCollateral(admin, _id, _collateralRequired, false);\n\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n        } else {\n            PCLUser _user = PCLUser(_depositor);\n\n            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);\n            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n            _helperDepositCollateral(_user, _id, _collateralRequired, false);\n\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n        }\n\n        // withdrawing from PCL\n        if (_withdrawer == address(admin)) {\n            try admin.withdrawCollateral(_id, _collateralRequired, false) {\n                revert('Admin should not be able to withdraw collateral');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        } else {\n            PCLUser _user = PCLUser(_withdrawer);\n\n            try _user.withdrawCollateral(_id, _collateralRequired, false) {\n                revert('Invalid actor should not be able to withdraw collateral');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        }\n    }\n\n    function test_borrowerCanWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);\n        if (request.collateralRatio != 0) {\n            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);\n        }\n        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);\n    }\n\n    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);\n        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(_lender, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        try _lender.withdrawAllCollateral(_id, false) {\n            revert('lender should not be able to withdraw all collateral');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:OCLB1');\n        }\n    }\n\n    function test_adminDepositsAndCannotWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(admin, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        try admin.withdrawAllCollateral(_id, false) {\n            revert('admin should not be able to withdraw all collateral');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:OCLB1');\n        }\n    }\n\n    function test_borrowerCannotWithdrawZeroAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        try borrower.withdrawAllCollateral(_id, false) {\n            revert('borrower should not be able to withdraw zero all collateral');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WAC1');\n        }\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        try borrower.withdrawCollateral(_id, 0, false) {\n            revert('Withdrawing zero collateral should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC2');\n        }\n    }\n\n    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);\n\n        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {\n            revert('Withdrawing more collateral than withdrawable should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC1');\n        }\n    }\n\n    function test_borrowerCanWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        if (request.collateralRatio != 0) {\n            borrower.withdrawAllCollateral(_id, false);\n        }\n        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);\n    }\n\n    function test_cannotCloseIfDebtIsNonZero() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);\n    }\n\n    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));\n        borrower.borrow(_id, 90_000 * (10ERC20(address(borrowAsset)).decimals()));\n        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));\n\n        try borrower.close(_id) {\n            revert('Borrower should not be able to close with non-zero debt');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C2');\n        }\n    }\n\n    function test_lenderCannotClose() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);\n    }\n\n    function test_adminCannotClose() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));\n    }\n\n    function assert_invalidActorCannotClose(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        borrower.borrow(_id, request.minBorrowAmount);\n\n        if (_actor == address(admin)) {\n            try admin.close(_id) {\n                revert('Admin should not be able to close PCL');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n\n            try _user.close(_id) {\n                revert('Invalid actor should not be able to close PCL');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        }\n    }\n\n    function test_borrowerCanRepayAndClose() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n\n        vm.warp(block.timestamp + (request.duration / 2));\n\n        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(_id, _currentDebt);\n\n        _currentDebt = pcl.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0);\n\n        borrower.close(_id);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_repayWithInsufficientBalance() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n\n        vm.warp(block.timestamp + (request.duration / 2));\n\n        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));\n        try borrower.repay(_id, _currentDebt) {\n            revert('REVERT: Insufficient Balance');\n        } catch Error(string memory reason) {\n            if (!isForked) {\n                assertEq(reason, 'ERC20: transfer amount exceeds allowance');\n            } else {\n                assertEq(reason, 'Dai/insufficient-allowance');\n            }\n        }\n    }\n\n    function test_borrowerCannotLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));\n    }\n\n    function test_adminCannotLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        emit log_named_uint('request.borrowLimit', request.borrowLimit);\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));\n    }\n\n    function assert_InvalidActorCannotLiquidate(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);\n        borrower.borrow(_id, _borrowable);\n\n        vm.warp(block.timestamp + (request.duration / 2));\n\n        if (!isForked) {\n            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);\n        }\n\n        if (_actor == address(admin)) {\n            try admin.liquidate(_id, true) {\n                revert('admin liquidating should revert');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'LP:LIQ1');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n\n            try _user.liquidate(_id, true) {\n                revert('Invalid actor liquidating should revert');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'LP:LIQ1');\n            }\n        }\n    }\n\n    function test_onlyLendersCanLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit / 3;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);\n    }\n\n    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {\n        if (request.collateralRatio == 0) return;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);\n        borrower.borrow(_id, _borrowable);\n\n        vm.warp(block.timestamp + (request.duration / 2));\n\n        if (!isForked) {\n            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);\n        }\n\n        PCLUser _lender = PCLUser(lenders[1].lenderAddress);\n        uint256 _amountLent = lenders[1].amount;\n        _lender.liquidate(_id, true);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_lenderCannotLiquidateZeroPrincipal() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);\n    }\n\n    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        vm.warp(block.timestamp + (request.duration / 2));\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.liquidate(_id, true) {\n            revert('Lender liquidating should revert with zero principal');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L1');\n        }\n    }\n\n    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);\n    }\n\n    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, _amountToBorrow / 2);\n\n        vm.warp(block.timestamp + (request.duration / 2));\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.liquidate(_id, true) {\n            revert('Lender liquidating should revert with if collateral ratio is more than ideal');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    function test_borrowerCannotTerminate() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotTerminate(_id);\n    }\n\n    function assert_borrowerCannotTerminate(uint256 _id) public {\n        try borrower.terminate(_id) {\n            revert('Borrower terminating PCL should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'Ownable: caller is not the owner');\n        }\n    }\n\n    function test_lenderCannotTerminate() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotTerminate(_id);\n    }\n\n    function assert_lenderCannotTerminate(uint256 _id) public {\n        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));\n        try _lender.terminate(_id) {\n            revert('Lender terminating PCL should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'Ownable: caller is not the owner');\n        }\n    }\n\n    function test_onlyAdminCanTerminate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_onlyAdminCanTerminate(_id, _amountToBorrow);\n    }\n\n    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n\n        vm.warp(block.timestamp + (request.duration / 2));\n        vm.roll(block.number + (request.duration / (2 * 20)));\n\n        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));\n        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));\n        admin.terminate(_id);\n        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));\n        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);\n        } else {\n            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);\n        }\n        if (request.borrowAssetStrategy == compoundYieldAddress) {\n            assertGe(\n                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,\n                (request.borrowLimit / 2) - 90_000 * 10(ERC20(address(borrowAsset)).decimals())\n            );\n        } else {\n            assertEq(\n                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,\n                (request.borrowLimit / 2) - 90_000 * 10(ERC20(address(borrowAsset)).decimals())\n            );\n        }\n    }\n\n    function test_depositCollateral() public {\n        uint256 _amount = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_depositCollateral(_id, _amount);\n    }\n\n    function assert_depositCollateral(uint256 _id, uint256 _amount) public {\n        // lender.lend(_id, _amount);\n        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());\n        admin.transferToken(address(collateralAsset), address(borrower), _amount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);\n        borrower.depositCollateral(_id, _amount, false);\n        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));\n        assertEq(pcl.depositedCollateralInShares(_id), _shares);\n    }\n\n    function test_depositCollateral_insufficientBalance() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n\n        admin.transferToken(address(collateralAsset), address(borrower), 10);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);\n        try borrower.depositCollateral(_id, 100, false) {\n            revert('Insufficient Balance of collateral tokens');\n        } catch Error(string memory reason) {\n            if (!isForked) {\n                assertEq(reason, 'ERC20: transfer amount exceeds balance');\n            } else {\n                assertEq(reason, 'SafeERC20: low-level call failed');\n            }\n        }\n    }\n\n    function test_depositZeroCollateral() public {\n        uint256 _amount = 0;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_depositZeroCollateral(_id, _amount);\n    }\n\n    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {\n        // lender.lend(_id, _amount);\n        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10ERC20(address(collateralAsset)).decimals()));\n        borrower.setAllowance(\n            pooledCreditLineAddress,\n            address(collateralAsset),\n            100_000 * (10ERC20(address(collateralAsset)).decimals())\n        );\n        try borrower.depositCollateral(_id, _amount, false) {\n            revert('Depositing zero collateral should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:DC1');\n        }\n    }\n\n    function test_depositCollateralFromSavingsAccount() public {\n        request.collateralAssetStrategy = compoundYieldAddress;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));\n        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);\n        if (request.collateralRatio != 0) {\n            borrower.depositToSavingsAccount(\n                savingsAccountAddress,\n                _collateralRequired,\n                address(collateralAsset),\n                compoundYieldAddress,\n                address(borrower)\n            );\n        }\n        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));\n        emit log_named_uint('total tokens: ', _totalTokens);\n        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            address(borrower),\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);\n        emit log_named_uint('required collateral: ', _collateralRequired);\n        borrower.setAllowanceForSavingsAccount(\n            savingsAccountAddress,\n            _collateralRequired,\n            address(collateralAsset),\n            pooledCreditLineAddress\n        );\n        _helperDepositCollateral(borrower, _id, _collateralRequired, true);\n        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);\n        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);\n        // assertEq(_borrowAbleAmount, _amountToBorrow);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);\n        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.withdrawAllCollateral(_id, true);\n        }\n        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            address(borrower),\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);\n        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            pooledCreditLineAddress,\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);\n        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);\n    }\n\n    function test_adminCannotCancelRequest() public {\n        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));\n    }\n\n    function test_lenderCannotCancelRequest() public {\n        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);\n    }\n\n    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {\n        if (_actor == address(admin)) {\n            try admin.cancelRequest(_id) {\n                revert('Admin cannot cancel PCL');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n            try _user.cancelRequest(_id) {\n                revert('Invalid actor cannot cancel PCL');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        }\n    }\n\n    function test_borrowerCannotCancelRequest() public {\n        assert_borrowerCannotCancelRequest(requestId);\n    }\n\n    function assert_borrowerCannotCancelRequest(uint256 _id) public {\n        try borrower.cancelRequest(_id) {\n            revert('Canceling a PCL in active stage should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {\n        _seed = scaleToRange128(_seed, 1, 10);\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);\n        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        try borrower.repay(_id, 1) {\n            revert('Borrower should not be able to repay zero current debt');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:REP3');\n        }\n    }\n\n    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {\n        _seed = scaleToRange128(_seed, 1, 10);\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);\n        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        uint256 _borrowAssetDecimalScaling = 10(ERC20(address(borrowAsset)).decimals());\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);\n\n        try borrower.repay(_id, 1) {\n            revert('Borrower should not be able to repay if interest is zero');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:REP4');\n        }\n    }\n\n    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);\n        log_named_uint('lender lp balance: ', _balance);\n        try _lender.transferLPTokens(address(borrower), _id, _balance) {\n            revert('should not have been possible to send LP tokens to the borrower');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT2');\n        }\n    }\n\n    function test_borrowerCannotReceivePoolTokens() public {\n        assert_borrowerCannotReceivePoolTokens(requestId);\n        request.borrowerVerifier = mockAdminVerifier1;\n        borrower.registerSelf(mockAdminVerifier1);\n        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);\n        assert_borrowerCannotReceivePoolTokens(_id);\n    }\n\n    function assert_canTransferPoolTokensToVerifiedUser(\n        uint256 _id,\n        address _recevingAddress,\n        uint256 _amount\n    ) public {\n        // borrowing some tokens\n        {\n            uint256 _borrowAssetDecimalScaling = 10(ERC20(address(borrowAsset)).decimals());\n            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;\n            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n            _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);\n\n            // going ahead in time to generate interest\n            vm.warp(block.timestamp + 6 days);\n            // repaying the interest and some principal back\n            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);\n            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);\n        }\n\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender\n        _lender.withdrawInterest(_id);\n\n        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;\n        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;\n        // calculating the receivers interest in shares\n        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);\n        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            receiverInterestInTokens,\n            address(borrowAsset)\n        );\n\n        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);\n        _lender.transferLPTokens(_recevingAddress, _id, _amount);\n\n        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);\n        assertEq(_finalBalance - _prevBalance, _amount);\n\n        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;\n        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;\n        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;\n        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;\n        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);\n    }\n\n    function assert_cannotTransferEcxessPoolTokens(\n        uint256 _id,\n        address _recevingAddress,\n        uint256 _amount\n    ) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {\n            revert('balance less than the amount to transfer');\n        } catch Error(string memory reason) {\n            // assertEq(reason, 'ERC1155: insufficient balance for transfer');\n            assertEq(reason, 'SafeMath: subtraction overflow');\n        }\n    }\n\n    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);\n        log_named_uint('lender lp balance: ', _balance);\n        // testing when user is not verified\n        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {\n            revert('should not have been possible to send LP tokens to not verified user');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT3');\n        }\n    }\n\n    function test_lenderTransfersTokenToAnotherLender() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n        address _recevingAddress = lenders[1].lenderAddress;\n        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);\n        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);\n    }\n\n    function test_lenderTransferTokenToNewUser() public {\n        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));\n\n        // testing when user is verified\n        _newUser.registerSelf(mockAdminVerifier1);\n\n        LenderInfo memory _lenderInfo = lenders[0];\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n\n        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);\n    }\n\n    function test_areTokensTransferable() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        LenderInfo memory _lenderInfo = lenders[0];\n\n        address _recevingAddress = lenders[1].lenderAddress;\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {\n            revert('should not have been possible to send LP tokens to the borrower');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT5');\n        }\n    }\n\n    function test_canTransferPoolTokensWhenZeroInterest() public {\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);\n        assertGe(_startBalanceLenderFrom, 0);\n        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);\n\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);\n        assertGe(_startBalanceLenderTo, 0);\n        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);\n\n        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);\n        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));\n        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));\n    }\n\n    function test_cannotWithdrawZeroInterest() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n\n        // cannot withdraw zero interest\n        vm.expectRevert(bytes('LP:WI1'));\n        _lender.withdrawInterest(requestId);\n    }\n\n    function test_newPoolTokenHolderCanWithdrawInterest() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _newUser.registerSelf(mockAdminVerifier1);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n        _lender.transferLPTokens(address(_newUser), requestId, _balance);\n        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);\n        assertEq(_newUserBalance, _balance);\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        borrower.borrow(requestId, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // going ahead in time to generate interest\n        vm.warp(block.timestamp + 6 days);\n        // repaying the interest and some principal back\n        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        borrower.repay(requestId, 10_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // fetch borrowerInterestSharesWithdrawn for new user\n        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;\n        assertEq(_prevBISW, 0);\n        // get the interest for the new user\n        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));\n        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));\n        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser\n        _newUser.withdrawInterest(requestId);\n        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;\n        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;\n        // match the interest shares withdrawn with the interest calculated\n        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);\n    }\n\n    function test_stateAfterBorrow() public {\n        admin.updateProtocolFeeFraction(0);\n\n        uint256 _amountToBorrow = request.borrowLimit;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        emit log_named_uint('borrowable amount', _borrowableAmount);\n        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);\n\n        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));\n        borrower.borrow(requestId, _borrowableAmount);\n        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));\n\n        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);\n        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);\n    }\n\n    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {\n        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());\n        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        emit log_named_uint('_collateralRequired: ', _collateralRequired);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        // borrow some amount\n        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());\n        if (_curBorrowAmount == _amountToBorrow) {\n            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);\n        }\n        borrower.borrow(requestId, _curBorrowAmount);\n        // check borrow able amount\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        if (request.collateralRatio != 0) {\n            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);\n        } else {\n            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);\n        }\n        // now check withdrawableCollateral\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);\n        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);\n    }\n\n    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {\n        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);\n    }\n\n    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {\n        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10_decimals).div(_ratioOfPrices);\n        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));\n    }\n\n    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {\n        if (request.collateralRatio == 0) return;\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);\n        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10ERC20(address(borrowAsset)).decimals()));\n        emit log_named_uint('_maxCollateral: ', _maxCollateral);\n        emit log_named_uint('_minCollateral: ', _minCollateral);\n        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);\n        emit log_named_uint('_collateralAmount: ', _collateralAmount);\n        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);\n        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);\n        // calulating what should borrowed to achieve _collateralRatioToAchieve\n        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10_decimals).mul(pcl.SCALING_FACTOR()).div(\n            _collateralRatioToAchieve\n        );\n        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);\n        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);\n        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);\n\n        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);\n        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);\n        if (\n            request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14\n        ) {\n            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);\n            if (_amountToBorrow &gt; _maxBorrowable) {\n                _amountToBorrow = _maxBorrowable;\n            }\n        } else {\n            assertLe(_amountToBorrow, _maxBorrowable);\n        }\n\n        borrower.borrow(requestId, _amountToBorrow);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);\n\n        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);\n        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve\n        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);\n    }\n\n    function test_closeActivePCLOncePrincipalPaidAndEnded() public {\n        // borrowing some tokens\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        borrower.borrow(requestId, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // going ahead in time to generate interest\n        vm.warp(block.timestamp + 6 days);\n        // repay everything back\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        uint256 _balance = borrowAsset.balanceOf(address(borrower));\n        if (_currentDebt &gt; _balance) {\n            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));\n        }\n        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n        // go to end of pcl\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n        assertEq(0, borrowAsset.balanceOf(address(borrower)));\n    }\n\n    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);\n\n    function test_closeWhenNoCollateral() public {\n        vm.warp(block.timestamp + 6 days);\n        // close\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_closeWhenCollateral() public {\n        uint256 _collateralAmount = 1e2 * 10ERC20(address(collateralAsset)).decimals();\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);\n        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);\n        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));\n        vm.warp(block.timestamp + 6 days);\n        vm.roll(block.number + (6 * 86400) / 20);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));\n        vm.expectEmit(true, true, false, false);\n        emit CollateralSharesWithdrawn(requestId, _shares);\n        // close\n        borrower.close(requestId);\n        // this is equal only when no yield is used\n        // with compund this should be assertLe becuase deposited collateral would earn yield\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));\n        } else {\n            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));\n        }\n    }\n\n    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);\n    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);\n\n    function test_withdrawLiquidatedCollateral() public {\n        if (request.collateralRatio == 0) return;\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);\n        borrower.borrow(requestId, _borrowable.sub(10));\n        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            request.borrowLimit - _borrowable.sub(10),\n            address(borrowAsset)\n        );\n        // going ahead in time to make liquidation possible\n        vm.warp(block.timestamp + 50 days);\n        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);\n        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));\n\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _totalSupply = lp.totalSupply(requestId);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n\n        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            _principalBorowable,\n            address(borrowAsset)\n        );\n        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +\n            _lenderYieldShares;\n\n        vm.expectEmit(true, true, false, false);\n        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);\n        _lender.liquidate(requestId, true);\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));\n        } else {\n            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));\n        }\n    }\n\n    event PooledCreditLineTerminated(uint256 indexed id);\n\n    function test_terminateAfterLiquidation() public {\n        if (request.collateralRatio == 0) return;\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);\n        borrower.borrow(requestId, _borrowable);\n        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            request.borrowLimit - _borrowable,\n            address(borrowAsset)\n        );\n\n        // going ahead in time to make liquidation possible\n        vm.warp(block.timestamp + request.duration.mul(7).div(11));\n        vm.roll(block.number + request.duration.mul(7).div(11).div(20));\n        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);\n        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));\n\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _totalSupply = lp.totalSupply(requestId);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            _principalBorowable,\n            address(borrowAsset)\n        );\n        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +\n            _lenderYieldShares;\n        vm.expectEmit(true, true, false, false);\n\n        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);\n        _lender.liquidate(requestId, true);\n\n        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));\n\n        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));\n        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);\n        // for an active pcl borrowLimit == total amount lent\n        _totalSupply = lp.totalSupply(requestId);\n        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);\n        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);\n        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);\n\n        // now the admin terminates\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineTerminated(requestId);\n        admin.terminate(requestId);\n\n        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));\n\n        if (request.borrowAssetStrategy == compoundYieldAddress) {\n            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));\n        } else {\n            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));\n        }\n    }\n\n    function _helperDepositCollateral(\n        PCLUser _user,\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) private {\n        if (_amount != 0) {\n            _user.depositCollateral(_id, _amount, _fromSavingsAccount);\n        }\n    }\n}\n"} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:26:10 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStage is PCLParent {     using SafeMath for uint256;     using SafeMath for uint128; uint256 requestId;  // enum PooledCreditLineStatus { //     NOT_CREATED, //     REQUESTED, //     ACTIVE, //     CLOSED, //     EXPIRED, //     LIQUIDATED, //     CANCELLED // }  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE); }  function test_cannotStartActivePCL() public {     try borrower.start(requestId) {         revert('cannot start active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     // verified using the borrower verifier instead of lender verifier     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_nonLenderCannotWithdrawLiquidity() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);     try _pooledCreditLineLender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL1');     } }  function test_lenderCannotWithdrawLiquidity() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotLendToActivePCL() public {     LenderInfo memory info = lenders[0];     PCLUser lender = PCLUser(info.lenderAddress);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendToActivePCLNewLender() public {     // Creating a new lender for lending     PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     lender.registerSelf(mockAdminVerifier1);     admin.transferToken(request.borrowAsset, address(lender), 100_000);     lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin)); }  function test_onlyBorrowerCanBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;     PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker)); }  function assert_borrowByInvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _user = PCLUser(_actor);     if (_actor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try admin.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try _user.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotBorrowMoreThanPossible() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);      try borrower.borrow(_id, _amountBorrowable + 1) {         revert('Borrower should not be able to borrow more than possible');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB3');     } }  function test_borrowerCannotBorrowZeroAmount() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.borrow(_id, 0) {         revert('Borrower should not be able to borrow zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB1');     } }  function test_lenderDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress); }  function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress); }  function test_adminDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin)); }  function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin)); }  function assert_DepositAndCannotWithdrawCollateral_InvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _depositor,     address _withdrawer ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      // Depositing into PCL     if (_depositor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     } else {         PCLUser _user = PCLUser(_depositor);          admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     }      // withdrawing from PCL     if (_withdrawer == address(admin)) {         try admin.withdrawCollateral(_id, _collateralRequired, false) {             revert('Admin should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_withdrawer);          try _user.withdrawCollateral(_id, _collateralRequired, false) {             revert('Invalid actor should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     if (request.collateralRatio != 0) {         borrower.withdrawCollateral(_id, _withdrawableCollateral, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_lenderDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);     _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(_lender, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try _lender.withdrawAllCollateral(_id, false) {         revert('lender should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_adminDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(admin, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try admin.withdrawAllCollateral(_id, false) {         revert('admin should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_borrowerCannotWithdrawZeroAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     try borrower.withdrawAllCollateral(_id, false) {         revert('borrower should not be able to withdraw zero all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  function test_borrowerCannotWithdrawZeroCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try borrower.withdrawCollateral(_id, 0, false) {         revert('Withdrawing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC2');     } }  function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);      try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {         revert('Withdrawing more collateral than withdrawable should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  function test_borrowerCanWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_cannotCloseIfDebtIsNonZero() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow); }  function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));     borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));     // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));      try borrower.close(_id) {         revert('Borrower should not be able to close with non-zero debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  function test_lenderCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin)); }  function assert_invalidActorCannotClose(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, request.minBorrowAmount);      if (_actor == address(admin)) {         try admin.close(_id) {             revert('Admin should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.close(_id) {             revert('Invalid actor should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanRepayAndClose() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanRepayAndClose(_id, _amountToBorrow); }  function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(_id, _currentDebt);      _currentDebt = pcl.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0);      borrower.close(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED); }  function test_repayWithInsufficientBalance() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));     try borrower.repay(_id, _currentDebt) {         revert('REVERT: Insufficient Balance');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds allowance');         } else {             assertEq(reason, 'Dai/insufficient-allowance');         }     } }  function test_borrowerCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower)); }  function test_adminCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;     emit log_named_uint('request.borrowLimit', request.borrowLimit);     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin)); }  function assert_InvalidActorCannotLiquidate(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      if (_actor == address(admin)) {         try admin.liquidate(_id, true) {             revert('admin liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.liquidate(_id, true) {             revert('Invalid actor liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } }  function test_onlyLendersCanLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit / 3;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyLendersCanLiquidate(_id, _amountToBorrow); }  function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {     if (request.collateralRatio == 0) return;     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      PCLUser _lender = PCLUser(lenders[1].lenderAddress);     uint256 _amountLent = lenders[1].amount;     _lender.liquidate(_id, true);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_lenderCannotLiquidateZeroPrincipal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with zero principal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, _amountToBorrow / 2);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with if collateral ratio is more than ideal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  function test_borrowerCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotTerminate(_id); }  function assert_borrowerCannotTerminate(uint256 _id) public {     try borrower.terminate(_id) {         revert('Borrower terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_lenderCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotTerminate(_id); }  function assert_lenderCannotTerminate(uint256 _id) public {     PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));     try _lender.terminate(_id) {         revert('Lender terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_onlyAdminCanTerminate() public {     uint256 _amountToBorrow = request.borrowLimit;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyAdminCanTerminate(_id, _amountToBorrow); }  function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));     vm.roll(block.number + (request.duration / (2 * 20)));      uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));     admin.terminate(_id);     uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     } else {         assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     }     if (request.borrowAssetStrategy == compoundYieldAddress) {         assertGe(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } else {         assertEq(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } }  function test_depositCollateral() public {     uint256 _amount = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositCollateral(_id, _amount); }  function assert_depositCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());     admin.transferToken(address(collateralAsset), address(borrower), _amount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);     borrower.depositCollateral(_id, _amount, false);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));     assertEq(pcl.depositedCollateralInShares(_id), _shares); }  function test_depositCollateral_insufficientBalance() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);      admin.transferToken(address(collateralAsset), address(borrower), 10);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);     try borrower.depositCollateral(_id, 100, false) {         revert('Insufficient Balance of collateral tokens');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds balance');         } else {             assertEq(reason, 'SafeERC20: low-level call failed');         }     } }  function test_depositZeroCollateral() public {     uint256 _amount = 0;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositZeroCollateral(_id, _amount); }  function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));     borrower.setAllowance(         pooledCreditLineAddress,         address(collateralAsset),         100_000 * (10**ERC20(address(collateralAsset)).decimals())     );     try borrower.depositCollateral(_id, _amount, false) {         revert('Depositing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC1');     } }  function test_depositCollateralFromSavingsAccount() public {     request.collateralAssetStrategy = compoundYieldAddress;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));     emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);     if (request.collateralRatio != 0) {         borrower.depositToSavingsAccount(             savingsAccountAddress,             _collateralRequired,             address(collateralAsset),             compoundYieldAddress,             address(borrower)         );     }     uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));     emit log_named_uint('total tokens: ', _totalTokens);     uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);     emit log_named_uint('required collateral: ', _collateralRequired);     borrower.setAllowanceForSavingsAccount(         savingsAccountAddress,         _collateralRequired,         address(collateralAsset),         pooledCreditLineAddress     );     _helperDepositCollateral(borrower, _id, _collateralRequired, true);     uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);     emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);     // assertEq(_borrowAbleAmount, _amountToBorrow);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, true);     }     uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);     uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         pooledCreditLineAddress,         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);     assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14); }  function test_adminCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, address(admin)); }  function test_lenderCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress); }  function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {     if (_actor == address(admin)) {         try admin.cancelRequest(_id) {             revert('Admin cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);         try _user.cancelRequest(_id) {             revert('Invalid actor cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotCancelRequest() public {     assert_borrowerCannotCancelRequest(requestId); }  function assert_borrowerCannotCancelRequest(uint256 _id) public {     try borrower.cancelRequest(_id) {         revert('Canceling a PCL in active stage should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow); }  function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay zero current debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP3');     } }  function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow); }  function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay if interest is zero');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP4');     } }  function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     try _lender.transferLPTokens(address(borrower), _id, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_borrowerCannotReceivePoolTokens() public {     assert_borrowerCannotReceivePoolTokens(requestId);     request.borrowerVerifier = mockAdminVerifier1;     borrower.registerSelf(mockAdminVerifier1);     (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);     assert_borrowerCannotReceivePoolTokens(_id); }  function assert_canTransferPoolTokensToVerifiedUser(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     // borrowing some tokens     {         uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());         uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;         uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);         admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);         borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);         _helperDepositCollateral(borrower, _id, _collateralRequired, false);         borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);          // going ahead in time to generate interest         vm.warp(block.timestamp + 6 days);         // repaying the interest and some principal back         borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);         borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);     }      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender     _lender.withdrawInterest(_id);      uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     // calculating the receivers interest in shares     uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);     uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         receiverInterestInTokens,         address(borrowAsset)     );      uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);     _lender.transferLPTokens(_recevingAddress, _id, _amount);      uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);     assertEq(_finalBalance - _prevBalance, _amount);      uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;     curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;     assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14); }  function assert_cannotTransferEcxessPoolTokens(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _id, _amount) {         revert('balance less than the amount to transfer');     } catch Error(string memory reason) {         // assertEq(reason, 'ERC1155: insufficient balance for transfer');         assertEq(reason, 'SafeMath: subtraction overflow');     } }  function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     // testing when user is not verified     try _lender.transferLPTokens(_newUserAddress, _id, _balance) {         revert('should not have been possible to send LP tokens to not verified user');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT3');     } }  function test_lenderTransfersTokenToAnotherLender() public {     LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     address _recevingAddress = lenders[1].lenderAddress;     assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);     assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance); }  function test_lenderTransferTokenToNewUser() public {     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));      // testing when user is verified     _newUser.registerSelf(mockAdminVerifier1);      LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);      assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3); }  function test_areTokensTransferable() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     LenderInfo memory _lenderInfo = lenders[0];      address _recevingAddress = lenders[1].lenderAddress;     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  function test_canTransferPoolTokensWhenZeroInterest() public {     PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);     assertGe(_startBalanceLenderFrom, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);      PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);     uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);     assertGe(_startBalanceLenderTo, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);      _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);     assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));     assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo)); }  function test_cannotWithdrawZeroInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);      // cannot withdraw zero interest     vm.expectRevert(bytes('LP:WI1'));     _lender.withdrawInterest(requestId); }  function test_newPoolTokenHolderCanWithdrawInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _newUser.registerSelf(mockAdminVerifier1);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     _lender.transferLPTokens(address(_newUser), requestId, _balance);     uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);     assertEq(_newUserBalance, _balance);     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repaying the interest and some principal back     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // fetch borrowerInterestSharesWithdrawn for new user     uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     assertEq(_prevBISW, 0);     // get the interest for the new user     uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));     uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser     _newUser.withdrawInterest(requestId);     uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;     // match the interest shares withdrawn with the interest calculated     assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14); }  function test_stateAfterBorrow() public {     admin.updateProtocolFeeFraction(0);      uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('borrowable amount', _borrowableAmount);     assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);      uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));     borrower.borrow(requestId, _borrowableAmount);     uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));      assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);     assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14); }  function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());     _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     emit log_named_uint('_collateralRequired: ', _collateralRequired);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     // borrow some amount     uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());     if (_curBorrowAmount == _amountToBorrow) {         _curBorrowAmount = _curBorrowAmount.mul(90).div(100);     }     borrower.borrow(requestId, _curBorrowAmount);     // check borrow able amount     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     if (request.collateralRatio != 0) {         assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);     } else {         assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);     }     // now check withdrawableCollateral     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);     assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14); }  function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction); }  function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {     _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);     assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount)); }  function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {     if (request.collateralRatio == 0) return;     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);     uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));     emit log_named_uint('_maxCollateral: ', _maxCollateral);     emit log_named_uint('_minCollateral: ', _minCollateral);     _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);     emit log_named_uint('_collateralAmount: ', _collateralAmount);     _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);     emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);     // calulating what should borrowed to achieve _collateralRatioToAchieve     uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(         _collateralRatioToAchieve     );     emit log_named_uint('_amountToBorrow: ', _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);      uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('_maxBorrowable: ', _maxBorrowable);     if (         request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14     ) {         assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);         if (_amountToBorrow &gt; _maxBorrowable) {             _amountToBorrow = _maxBorrowable;         }     } else {         assertLe(_amountToBorrow, _maxBorrowable);     }      borrower.borrow(requestId, _amountToBorrow);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);      uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);     // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve     assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14); }  function test_closeActivePCLOncePrincipalPaidAndEnded() public {     // borrowing some tokens     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repay everything back     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _balance = borrowAsset.balanceOf(address(borrower));     if (_currentDebt &gt; _balance) {         admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));     }     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);     // go to end of pcl     vm.warp(block.timestamp + request.collectionPeriod + request.duration);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);     assertEq(0, borrowAsset.balanceOf(address(borrower))); }  event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);  function test_closeWhenNoCollateral() public {     vm.warp(block.timestamp + 6 days);     // close     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_closeWhenCollateral() public {     uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();     admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     vm.warp(block.timestamp + 6 days);     vm.roll(block.number + (6 * 86400) / 20);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));     vm.expectEmit(true, true, false, false);     emit CollateralSharesWithdrawn(requestId, _shares);     // close     borrower.close(requestId);     // this is equal only when no yield is used     // with compund this should be assertLe becuase deposited collateral would earn yield     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } else {         assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } }  event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare); event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);  function test_withdrawLiquidatedCollateral() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable.sub(10));     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable.sub(10),         address(borrowAsset)     );     // going ahead in time to make liquidation possible     vm.warp(block.timestamp + 50 days);     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);      uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;      vm.expectEmit(true, true, false, false);     emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } else {         assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } }  event PooledCreditLineTerminated(uint256 indexed id);  function test_terminateAfterLiquidation() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable);     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable,         address(borrowAsset)     );      // going ahead in time to make liquidation possible     vm.warp(block.timestamp + request.duration.mul(7).div(11));     vm.roll(block.number + request.duration.mul(7).div(11).div(20));     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;     vm.expectEmit(true, true, false, false);      emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);      uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));      uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));     emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);     // for an active pcl borrowLimit == total amount lent     _totalSupply = lp.totalSupply(requestId);     // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);     // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);     // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);      // now the admin terminates     vm.expectEmit(true, true, false, true);     emit PooledCreditLineTerminated(requestId);     admin.terminate(requestId);      assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));      if (request.borrowAssetStrategy == compoundYieldAddress) {         // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } else {         // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } }  function _helperDepositCollateral(     PCLUser _user,     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) private {     if (_amount != 0) {         _user.depositCollateral(_id, _amount, _fromSavingsAccount);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:26:10 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-27-08 09:26:15 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:26:15 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 34876
completion_tokens: 1
total_tokens: 34877
cost: $-1.000000


[2024-27-08 09:26:15 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
.]

Let's

[2024-27-08 09:26:18 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStage is PCLParent {     using SafeMath for uint256;     using SafeMath for uint128; uint256 requestId;  // enum PooledCreditLineStatus { //     NOT_CREATED, //     REQUESTED, //     ACTIVE, //     CLOSED, //     EXPIRED, //     LIQUIDATED, //     CANCELLED // }  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE); }  function test_cannotStartActivePCL() public {     try borrower.start(requestId) {         revert('cannot start active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     // verified using the borrower verifier instead of lender verifier     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_nonLenderCannotWithdrawLiquidity() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);     try _pooledCreditLineLender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL1');     } }  function test_lenderCannotWithdrawLiquidity() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotLendToActivePCL() public {     LenderInfo memory info = lenders[0];     PCLUser lender = PCLUser(info.lenderAddress);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendToActivePCLNewLender() public {     // Creating a new lender for lending     PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     lender.registerSelf(mockAdminVerifier1);     admin.transferToken(request.borrowAsset, address(lender), 100_000);     lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin)); }  function test_onlyBorrowerCanBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;     PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker)); }  function assert_borrowByInvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _user = PCLUser(_actor);     if (_actor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try admin.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try _user.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotBorrowMoreThanPossible() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);      try borrower.borrow(_id, _amountBorrowable + 1) {         revert('Borrower should not be able to borrow more than possible');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB3');     } }  function test_borrowerCannotBorrowZeroAmount() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.borrow(_id, 0) {         revert('Borrower should not be able to borrow zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB1');     } }  function test_lenderDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress); }  function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress); }  function test_adminDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin)); }  function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin)); }  function assert_DepositAndCannotWithdrawCollateral_InvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _depositor,     address _withdrawer ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      // Depositing into PCL     if (_depositor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     } else {         PCLUser _user = PCLUser(_depositor);          admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     }      // withdrawing from PCL     if (_withdrawer == address(admin)) {         try admin.withdrawCollateral(_id, _collateralRequired, false) {             revert('Admin should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_withdrawer);          try _user.withdrawCollateral(_id, _collateralRequired, false) {             revert('Invalid actor should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     if (request.collateralRatio != 0) {         borrower.withdrawCollateral(_id, _withdrawableCollateral, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_lenderDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);     _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(_lender, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try _lender.withdrawAllCollateral(_id, false) {         revert('lender should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_adminDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(admin, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try admin.withdrawAllCollateral(_id, false) {         revert('admin should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_borrowerCannotWithdrawZeroAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     try borrower.withdrawAllCollateral(_id, false) {         revert('borrower should not be able to withdraw zero all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  function test_borrowerCannotWithdrawZeroCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try borrower.withdrawCollateral(_id, 0, false) {         revert('Withdrawing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC2');     } }  function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);      try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {         revert('Withdrawing more collateral than withdrawable should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  function test_borrowerCanWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_cannotCloseIfDebtIsNonZero() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow); }  function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));     borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));     // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));      try borrower.close(_id) {         revert('Borrower should not be able to close with non-zero debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  function test_lenderCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin)); }  function assert_invalidActorCannotClose(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, request.minBorrowAmount);      if (_actor == address(admin)) {         try admin.close(_id) {             revert('Admin should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.close(_id) {             revert('Invalid actor should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanRepayAndClose() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanRepayAndClose(_id, _amountToBorrow); }  function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(_id, _currentDebt);      _currentDebt = pcl.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0);      borrower.close(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED); }  function test_repayWithInsufficientBalance() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));     try borrower.repay(_id, _currentDebt) {         revert('REVERT: Insufficient Balance');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds allowance');         } else {             assertEq(reason, 'Dai/insufficient-allowance');         }     } }  function test_borrowerCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower)); }  function test_adminCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;     emit log_named_uint('request.borrowLimit', request.borrowLimit);     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin)); }  function assert_InvalidActorCannotLiquidate(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      if (_actor == address(admin)) {         try admin.liquidate(_id, true) {             revert('admin liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.liquidate(_id, true) {             revert('Invalid actor liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } }  function test_onlyLendersCanLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit / 3;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyLendersCanLiquidate(_id, _amountToBorrow); }  function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {     if (request.collateralRatio == 0) return;     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      PCLUser _lender = PCLUser(lenders[1].lenderAddress);     uint256 _amountLent = lenders[1].amount;     _lender.liquidate(_id, true);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_lenderCannotLiquidateZeroPrincipal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with zero principal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, _amountToBorrow / 2);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with if collateral ratio is more than ideal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  function test_borrowerCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotTerminate(_id); }  function assert_borrowerCannotTerminate(uint256 _id) public {     try borrower.terminate(_id) {         revert('Borrower terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_lenderCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotTerminate(_id); }  function assert_lenderCannotTerminate(uint256 _id) public {     PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));     try _lender.terminate(_id) {         revert('Lender terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_onlyAdminCanTerminate() public {     uint256 _amountToBorrow = request.borrowLimit;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyAdminCanTerminate(_id, _amountToBorrow); }  function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));     vm.roll(block.number + (request.duration / (2 * 20)));      uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));     admin.terminate(_id);     uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     } else {         assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     }     if (request.borrowAssetStrategy == compoundYieldAddress) {         assertGe(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } else {         assertEq(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } }  function test_depositCollateral() public {     uint256 _amount = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositCollateral(_id, _amount); }  function assert_depositCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());     admin.transferToken(address(collateralAsset), address(borrower), _amount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);     borrower.depositCollateral(_id, _amount, false);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));     assertEq(pcl.depositedCollateralInShares(_id), _shares); }  function test_depositCollateral_insufficientBalance() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);      admin.transferToken(address(collateralAsset), address(borrower), 10);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);     try borrower.depositCollateral(_id, 100, false) {         revert('Insufficient Balance of collateral tokens');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds balance');         } else {             assertEq(reason, 'SafeERC20: low-level call failed');         }     } }  function test_depositZeroCollateral() public {     uint256 _amount = 0;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositZeroCollateral(_id, _amount); }  function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));     borrower.setAllowance(         pooledCreditLineAddress,         address(collateralAsset),         100_000 * (10**ERC20(address(collateralAsset)).decimals())     );     try borrower.depositCollateral(_id, _amount, false) {         revert('Depositing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC1');     } }  function test_depositCollateralFromSavingsAccount() public {     request.collateralAssetStrategy = compoundYieldAddress;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));     emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);     if (request.collateralRatio != 0) {         borrower.depositToSavingsAccount(             savingsAccountAddress,             _collateralRequired,             address(collateralAsset),             compoundYieldAddress,             address(borrower)         );     }     uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));     emit log_named_uint('total tokens: ', _totalTokens);     uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);     emit log_named_uint('required collateral: ', _collateralRequired);     borrower.setAllowanceForSavingsAccount(         savingsAccountAddress,         _collateralRequired,         address(collateralAsset),         pooledCreditLineAddress     );     _helperDepositCollateral(borrower, _id, _collateralRequired, true);     uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);     emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);     // assertEq(_borrowAbleAmount, _amountToBorrow);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, true);     }     uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);     uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         pooledCreditLineAddress,         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);     assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14); }  function test_adminCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, address(admin)); }  function test_lenderCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress); }  function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {     if (_actor == address(admin)) {         try admin.cancelRequest(_id) {             revert('Admin cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);         try _user.cancelRequest(_id) {             revert('Invalid actor cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotCancelRequest() public {     assert_borrowerCannotCancelRequest(requestId); }  function assert_borrowerCannotCancelRequest(uint256 _id) public {     try borrower.cancelRequest(_id) {         revert('Canceling a PCL in active stage should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow); }  function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay zero current debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP3');     } }  function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow); }  function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay if interest is zero');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP4');     } }  function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     try _lender.transferLPTokens(address(borrower), _id, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_borrowerCannotReceivePoolTokens() public {     assert_borrowerCannotReceivePoolTokens(requestId);     request.borrowerVerifier = mockAdminVerifier1;     borrower.registerSelf(mockAdminVerifier1);     (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);     assert_borrowerCannotReceivePoolTokens(_id); }  function assert_canTransferPoolTokensToVerifiedUser(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     // borrowing some tokens     {         uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());         uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;         uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);         admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);         borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);         _helperDepositCollateral(borrower, _id, _collateralRequired, false);         borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);          // going ahead in time to generate interest         vm.warp(block.timestamp + 6 days);         // repaying the interest and some principal back         borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);         borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);     }      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender     _lender.withdrawInterest(_id);      uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     // calculating the receivers interest in shares     uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);     uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         receiverInterestInTokens,         address(borrowAsset)     );      uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);     _lender.transferLPTokens(_recevingAddress, _id, _amount);      uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);     assertEq(_finalBalance - _prevBalance, _amount);      uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;     curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;     assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14); }  function assert_cannotTransferEcxessPoolTokens(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _id, _amount) {         revert('balance less than the amount to transfer');     } catch Error(string memory reason) {         // assertEq(reason, 'ERC1155: insufficient balance for transfer');         assertEq(reason, 'SafeMath: subtraction overflow');     } }  function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     // testing when user is not verified     try _lender.transferLPTokens(_newUserAddress, _id, _balance) {         revert('should not have been possible to send LP tokens to not verified user');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT3');     } }  function test_lenderTransfersTokenToAnotherLender() public {     LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     address _recevingAddress = lenders[1].lenderAddress;     assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);     assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance); }  function test_lenderTransferTokenToNewUser() public {     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));      // testing when user is verified     _newUser.registerSelf(mockAdminVerifier1);      LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);      assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3); }  function test_areTokensTransferable() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     LenderInfo memory _lenderInfo = lenders[0];      address _recevingAddress = lenders[1].lenderAddress;     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  function test_canTransferPoolTokensWhenZeroInterest() public {     PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);     assertGe(_startBalanceLenderFrom, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);      PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);     uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);     assertGe(_startBalanceLenderTo, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);      _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);     assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));     assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo)); }  function test_cannotWithdrawZeroInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);      // cannot withdraw zero interest     vm.expectRevert(bytes('LP:WI1'));     _lender.withdrawInterest(requestId); }  function test_newPoolTokenHolderCanWithdrawInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _newUser.registerSelf(mockAdminVerifier1);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     _lender.transferLPTokens(address(_newUser), requestId, _balance);     uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);     assertEq(_newUserBalance, _balance);     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repaying the interest and some principal back     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // fetch borrowerInterestSharesWithdrawn for new user     uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     assertEq(_prevBISW, 0);     // get the interest for the new user     uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));     uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser     _newUser.withdrawInterest(requestId);     uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;     // match the interest shares withdrawn with the interest calculated     assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14); }  function test_stateAfterBorrow() public {     admin.updateProtocolFeeFraction(0);      uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('borrowable amount', _borrowableAmount);     assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);      uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));     borrower.borrow(requestId, _borrowableAmount);     uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));      assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);     assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14); }  function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());     _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     emit log_named_uint('_collateralRequired: ', _collateralRequired);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     // borrow some amount     uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());     if (_curBorrowAmount == _amountToBorrow) {         _curBorrowAmount = _curBorrowAmount.mul(90).div(100);     }     borrower.borrow(requestId, _curBorrowAmount);     // check borrow able amount     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     if (request.collateralRatio != 0) {         assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);     } else {         assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);     }     // now check withdrawableCollateral     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);     assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14); }  function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction); }  function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {     _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);     assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount)); }  function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {     if (request.collateralRatio == 0) return;     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);     uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));     emit log_named_uint('_maxCollateral: ', _maxCollateral);     emit log_named_uint('_minCollateral: ', _minCollateral);     _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);     emit log_named_uint('_collateralAmount: ', _collateralAmount);     _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);     emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);     // calulating what should borrowed to achieve _collateralRatioToAchieve     uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(         _collateralRatioToAchieve     );     emit log_named_uint('_amountToBorrow: ', _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);      uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('_maxBorrowable: ', _maxBorrowable);     if (         request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14     ) {         assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);         if (_amountToBorrow &gt; _maxBorrowable) {             _amountToBorrow = _maxBorrowable;         }     } else {         assertLe(_amountToBorrow, _maxBorrowable);     }      borrower.borrow(requestId, _amountToBorrow);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);      uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);     // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve     assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14); }  function test_closeActivePCLOncePrincipalPaidAndEnded() public {     // borrowing some tokens     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repay everything back     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _balance = borrowAsset.balanceOf(address(borrower));     if (_currentDebt &gt; _balance) {         admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));     }     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);     // go to end of pcl     vm.warp(block.timestamp + request.collectionPeriod + request.duration);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);     assertEq(0, borrowAsset.balanceOf(address(borrower))); }  event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);  function test_closeWhenNoCollateral() public {     vm.warp(block.timestamp + 6 days);     // close     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_closeWhenCollateral() public {     uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();     admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     vm.warp(block.timestamp + 6 days);     vm.roll(block.number + (6 * 86400) / 20);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));     vm.expectEmit(true, true, false, false);     emit CollateralSharesWithdrawn(requestId, _shares);     // close     borrower.close(requestId);     // this is equal only when no yield is used     // with compund this should be assertLe becuase deposited collateral would earn yield     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } else {         assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } }  event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare); event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);  function test_withdrawLiquidatedCollateral() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable.sub(10));     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable.sub(10),         address(borrowAsset)     );     // going ahead in time to make liquidation possible     vm.warp(block.timestamp + 50 days);     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);      uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;      vm.expectEmit(true, true, false, false);     emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } else {         assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } }  event PooledCreditLineTerminated(uint256 indexed id);  function test_terminateAfterLiquidation() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable);     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable,         address(borrowAsset)     );      // going ahead in time to make liquidation possible     vm.warp(block.timestamp + request.duration.mul(7).div(11));     vm.roll(block.number + request.duration.mul(7).div(11).div(20));     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;     vm.expectEmit(true, true, false, false);      emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);      uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));      uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));     emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);     // for an active pcl borrowLimit == total amount lent     _totalSupply = lp.totalSupply(requestId);     // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);     // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);     // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);      // now the admin terminates     vm.expectEmit(true, true, false, true);     emit PooledCreditLineTerminated(requestId);     admin.terminate(requestId);      assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));      if (request.borrowAssetStrategy == compoundYieldAddress) {         // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } else {         // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } }  function _helperDepositCollateral(     PCLUser _user,     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) private {     if (_amount != 0) {         _user.depositCollateral(_id, _amount, _fromSavingsAccount);     } }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\ncontract PCLActiveStage is PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    uint256 requestId;\n    // enum PooledCreditLineStatus {\n    //     NOT_CREATED,\n    //     REQUESTED,\n    //     ACTIVE,\n    //     CLOSED,\n    //     EXPIRED,\n    //     LIQUIDATED,\n    //     CANCELLED\n    // }\n    function setUp() public virtual override {\n        super.setUp();\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n    }\n    function test_cannotStartActivePCL() public {\n        try borrower.start(requestId) {\n            revert(\'cannot start active pcl\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:S1\');\n        }\n    }\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert(\'External user cannot create\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert(\'External user cannot terminate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n    function test_cannotLendZeroAmount() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert(\'Lender cannot lend zero amount\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L1\');\n        }\n    }\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        // verified using the borrower verifier instead of lender verifier\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Unverified lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L2\');\n        }\n    }\n    function test_nonLenderCannotWithdrawLiquidity() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        try _pooledCreditLineLender.withdrawLiquidity(requestId) {\n            revert(\'Lender cannot withdraw liquidity\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWL1\');\n        }\n    }\n    function test_lenderCannotWithdrawLiquidity() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.withdrawLiquidity(requestId) {\n            revert(\'Lender cannot withdraw liquidity\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWL3\');\n        }\n    }\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Non lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WLC1\');\n        }\n    }\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWLC1\');\n        }\n    }\n    function test_cannotTransferLPTokensToSameAddress() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert(\'Lender cannot transfer LP tokens to itself\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT1\');\n        }\n    }\n    function test_cannotBurnPoolTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert(\'Lender cannot burn LP tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'ERC1155: transfer to the zero address\');\n        }\n    }\n    function test_cannotLendToActivePCL() public {\n        LenderInfo memory info = lenders[0];\n        PCLUser lender = PCLUser(info.lenderAddress);\n        try lender.lend(requestId, 100_000) {\n            revert(\'cannot lend to active pcl\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L3\');\n        }\n    }\n    function test_cannotLendToActivePCLNewLender() public {\n        // Creating a new lender for lending\n        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        lender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(request.borrowAsset, address(lender), 100_000);\n        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);\n        try lender.lend(requestId, 100_000) {\n            revert(\'cannot lend to active pcl\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L3\');\n        }\n    }\n    function test_lenderCannotBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);\n    }\n    function test_adminCannotBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));\n    }\n    function test_onlyBorrowerCanBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));\n    }\n    function assert_borrowByInvalidActor(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        PCLUser _user = PCLUser(_actor);\n        if (_actor == address(admin)) {\n            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n            _helperDepositCollateral(admin, _id, _collateralRequired, false);\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n            try admin.borrow(_id, _amountToBorrow) {\n                revert(\'Invalid user should not be able to borrow\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'PCL:OCLB1\');\n            }\n        } else {\n            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);\n            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n            _helperDepositCollateral(_user, _id, _collateralRequired, false);\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n            try _user.borrow(_id, _amountToBorrow) {\n                revert(\'Invalid user should not be able to borrow\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'PCL:OCLB1\');\n            }\n        }\n    }\n    function test_borrowerCannotBorrowMoreThanPossible() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);\n    }\n    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);\n        try borrower.borrow(_id, _amountBorrowable + 1) {\n            revert(\'Borrower should not be able to borrow more than possible\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:IB3\');\n        }\n    }\n    function test_borrowerCannotBorrowZeroAmount() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);\n    }\n    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        try borrower.borrow(_id, 0) {\n            revert(\'Borrower should not be able to borrow zero amount\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:IB1\');\n        }\n    }\n    function test_lenderDepositsAndCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);\n    }\n    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);\n    }\n    function test_adminDepositsAndCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));\n    }\n    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));\n    }\n    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _depositor,\n        address _withdrawer\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        // Depositing into PCL\n        if (_depositor == address(admin)) {\n            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n            _helperDepositCollateral(admin, _id, _collateralRequired, false);\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n        } else {\n            PCLUser _user = PCLUser(_depositor);\n            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);\n            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n            _helperDepositCollateral(_user, _id, _collateralRequired, false);\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n        }\n        // withdrawing from PCL\n        if (_withdrawer == address(admin)) {\n            try admin.withdrawCollateral(_id, _collateralRequired, false) {\n                revert(\'Admin should not be able to withdraw collateral\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'PCL:OCLB1\');\n            }\n        } else {\n            PCLUser _user = PCLUser(_withdrawer);\n            try _user.withdrawCollateral(_id, _collateralRequired, false) {\n                revert(\'Invalid actor should not be able to withdraw collateral\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'PCL:OCLB1\');\n            }\n        }\n    }\n    function test_borrowerCanWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);\n    }\n    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);\n        if (request.collateralRatio != 0) {\n            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);\n        }\n        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);\n    }\n    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);\n        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(_lender, _id, _collateralRequired, false);\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n        try _lender.withdrawAllCollateral(_id, false) {\n            revert(\'lender should not be able to withdraw all collateral\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:OCLB1\');\n        }\n    }\n    function test_adminDepositsAndCannotWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(admin, _id, _collateralRequired, false);\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n        try admin.withdrawAllCollateral(_id, false) {\n            revert(\'admin should not be able to withdraw all collateral\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:OCLB1\');\n        }\n    }\n    function test_borrowerCannotWithdrawZeroAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);\n    }\n    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        try borrower.withdrawAllCollateral(_id, false) {\n            revert(\'borrower should not be able to withdraw zero all collateral\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:WAC1\');\n        }\n    }\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);\n    }\n    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n        try borrower.withdrawCollateral(_id, 0, false) {\n            revert(\'Withdrawing zero collateral should fail\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:WC2\');\n        }\n    }\n    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);\n    }\n    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);\n        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {\n            revert(\'Withdrawing more collateral than withdrawable should fail\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:WC1\');\n        }\n    }\n    function test_borrowerCanWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        if (request.collateralRatio != 0) {\n            borrower.withdrawAllCollateral(_id, false);\n        }\n        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);\n    }\n    function test_cannotCloseIfDebtIsNonZero() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);\n    }\n    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));\n        borrower.borrow(_id, 90_000 * (10ERC20(address(borrowAsset)).decimals()));\n        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));\n        try borrower.close(_id) {\n            revert(\'Borrower should not be able to close with non-zero debt\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:C2\');\n        }\n    }\n    function test_lenderCannotClose() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);\n    }\n    function test_adminCannotClose() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));\n    }\n    function assert_invalidActorCannotClose(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, request.minBorrowAmount);\n        if (_actor == address(admin)) {\n            try admin.close(_id) {\n                revert(\'Admin should not be able to close PCL\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'PCL:OCLB1\');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n            try _user.close(_id) {\n                revert(\'Invalid actor should not be able to close PCL\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'PCL:OCLB1\');\n            }\n        }\n    }\n    function test_borrowerCanRepayAndClose() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);\n    }\n    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        vm.warp(block.timestamp + (request.duration / 2));\n        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(_id, _currentDebt);\n        _currentDebt = pcl.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0);\n        borrower.close(_id);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);\n    }\n    function test_repayWithInsufficientBalance() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        vm.warp(block.timestamp + (request.duration / 2));\n        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));\n        try borrower.repay(_id, _currentDebt) {\n            revert(\'REVERT: Insufficient Balance\');\n        } catch Error(string memory reason) {\n            if (!isForked) {\n                assertEq(reason, \'ERC20: transfer amount exceeds allowance\');\n            } else {\n                assertEq(reason, \'Dai/insufficient-allowance\');\n            }\n        }\n    }\n    function test_borrowerCannotLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));\n    }\n    function test_adminCannotLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        emit log_named_uint(\'request.borrowLimit\', request.borrowLimit);\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));\n    }\n    function assert_InvalidActorCannotLiquidate(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);\n        borrower.borrow(_id, _borrowable);\n        vm.warp(block.timestamp + (request.duration / 2));\n        if (!isForked) {\n            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);\n        }\n        if (_actor == address(admin)) {\n            try admin.liquidate(_id, true) {\n                revert(\'admin liquidating should revert\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'LP:LIQ1\');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n            try _user.liquidate(_id, true) {\n                revert(\'Invalid actor liquidating should revert\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'LP:LIQ1\');\n            }\n        }\n    }\n    function test_onlyLendersCanLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit / 3;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);\n    }\n    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {\n        if (request.collateralRatio == 0) return;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);\n        borrower.borrow(_id, _borrowable);\n        vm.warp(block.timestamp + (request.duration / 2));\n        if (!isForked) {\n            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);\n        }\n        PCLUser _lender = PCLUser(lenders[1].lenderAddress);\n        uint256 _amountLent = lenders[1].amount;\n        _lender.liquidate(_id, true);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n    function test_lenderCannotLiquidateZeroPrincipal() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);\n    }\n    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        vm.warp(block.timestamp + (request.duration / 2));\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.liquidate(_id, true) {\n            revert(\'Lender liquidating should revert with zero principal\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L1\');\n        }\n    }\n    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);\n    }\n    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, _amountToBorrow / 2);\n        vm.warp(block.timestamp + (request.duration / 2));\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.liquidate(_id, true) {\n            revert(\'Lender liquidating should revert with if collateral ratio is more than ideal\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L3\');\n        }\n    }\n    function test_borrowerCannotTerminate() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotTerminate(_id);\n    }\n    function assert_borrowerCannotTerminate(uint256 _id) public {\n        try borrower.terminate(_id) {\n            revert(\'Borrower terminating PCL should fail\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'Ownable: caller is not the owner\');\n        }\n    }\n    function test_lenderCannotTerminate() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotTerminate(_id);\n    }\n    function assert_lenderCannotTerminate(uint256 _id) public {\n        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));\n        try _lender.terminate(_id) {\n            revert(\'Lender terminating PCL should fail\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'Ownable: caller is not the owner\');\n        }\n    }\n    function test_onlyAdminCanTerminate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_onlyAdminCanTerminate(_id, _amountToBorrow);\n    }\n    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        vm.warp(block.timestamp + (request.duration / 2));\n        vm.roll(block.number + (request.duration / (2 * 20)));\n        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));\n        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));\n        admin.terminate(_id);\n        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));\n        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);\n        } else {\n            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);\n        }\n        if (request.borrowAssetStrategy == compoundYieldAddress) {\n            assertGe(\n                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,\n                (request.borrowLimit / 2) - 90_000 * 10(ERC20(address(borrowAsset)).decimals())\n            );\n        } else {\n            assertEq(\n                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,\n                (request.borrowLimit / 2) - 90_000 * 10(ERC20(address(borrowAsset)).decimals())\n            );\n        }\n    }\n    function test_depositCollateral() public {\n        uint256 _amount = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_depositCollateral(_id, _amount);\n    }\n    function assert_depositCollateral(uint256 _id, uint256 _amount) public {\n        // lender.lend(_id, _amount);\n        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());\n        admin.transferToken(address(collateralAsset), address(borrower), _amount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);\n        borrower.depositCollateral(_id, _amount, false);\n        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));\n        assertEq(pcl.depositedCollateralInShares(_id), _shares);\n    }\n    function test_depositCollateral_insufficientBalance() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        admin.transferToken(address(collateralAsset), address(borrower), 10);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);\n        try borrower.depositCollateral(_id, 100, false) {\n            revert(\'Insufficient Balance of collateral tokens\');\n        } catch Error(string memory reason) {\n            if (!isForked) {\n                assertEq(reason, \'ERC20: transfer amount exceeds balance\');\n            } else {\n                assertEq(reason, \'SafeERC20: low-level call failed\');\n            }\n        }\n    }\n    function test_depositZeroCollateral() public {\n        uint256 _amount = 0;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_depositZeroCollateral(_id, _amount);\n    }\n    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {\n        // lender.lend(_id, _amount);\n        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10ERC20(address(collateralAsset)).decimals()));\n        borrower.setAllowance(\n            pooledCreditLineAddress,\n            address(collateralAsset),\n            100_000 * (10ERC20(address(collateralAsset)).decimals())\n        );\n        try borrower.depositCollateral(_id, _amount, false) {\n            revert(\'Depositing zero collateral should fail\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:DC1\');\n        }\n    }\n    function test_depositCollateralFromSavingsAccount() public {\n        request.collateralAssetStrategy = compoundYieldAddress;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));\n        emit log_named_decimal_uint(\'_collateralRequired\', _collateralRequired, ERC20(address(collateralAsset)).decimals());\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);\n        if (request.collateralRatio != 0) {\n            borrower.depositToSavingsAccount(\n                savingsAccountAddress,\n                _collateralRequired,\n                address(collateralAsset),\n                compoundYieldAddress,\n                address(borrower)\n            );\n        }\n        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));\n        emit log_named_uint(\'total tokens: \', _totalTokens);\n        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            address(borrower),\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint(\'_curBalanceInShares: \', _curBalanceInShares);\n        emit log_named_uint(\'required collateral: \', _collateralRequired);\n        borrower.setAllowanceForSavingsAccount(\n            savingsAccountAddress,\n            _collateralRequired,\n            address(collateralAsset),\n            pooledCreditLineAddress\n        );\n        _helperDepositCollateral(borrower, _id, _collateralRequired, true);\n        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);\n        emit log_named_uint(\'_borrowAbleAmount: \', _borrowAbleAmount);\n        // assertEq(_borrowAbleAmount, _amountToBorrow);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);\n        emit log_named_uint(\'_withdrawableCollateral: \', _withdrawableCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.withdrawAllCollateral(_id, true);\n        }\n        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            address(borrower),\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint(\'_finalBalanceInShares: \', _finalBalanceInShares);\n        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            pooledCreditLineAddress,\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint(\'_pclBalanceInShares: \', _pclBalanceInShares);\n        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);\n    }\n    function test_adminCannotCancelRequest() public {\n        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));\n    }\n    function test_lenderCannotCancelRequest() public {\n        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);\n    }\n    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {\n        if (_actor == address(admin)) {\n            try admin.cancelRequest(_id) {\n                revert(\'Admin cannot cancel PCL\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'PCL:OCLB1\');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n            try _user.cancelRequest(_id) {\n                revert(\'Invalid actor cannot cancel PCL\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'PCL:OCLB1\');\n            }\n        }\n    }\n    function test_borrowerCannotCancelRequest() public {\n        assert_borrowerCannotCancelRequest(requestId);\n    }\n    function assert_borrowerCannotCancelRequest(uint256 _id) public {\n        try borrower.cancelRequest(_id) {\n            revert(\'Canceling a PCL in active stage should fail\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:CR1\');\n        }\n    }\n    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {\n        _seed = scaleToRange128(_seed, 1, 10);\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);\n        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);\n    }\n    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        try borrower.repay(_id, 1) {\n            revert(\'Borrower should not be able to repay zero current debt\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:REP3\');\n        }\n    }\n    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {\n        _seed = scaleToRange128(_seed, 1, 10);\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);\n        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);\n    }\n    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        uint256 _borrowAssetDecimalScaling = 10(ERC20(address(borrowAsset)).decimals());\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);\n        try borrower.repay(_id, 1) {\n            revert(\'Borrower should not be able to repay if interest is zero\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:REP4\');\n        }\n    }\n    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);\n        log_named_uint(\'lender lp balance: \', _balance);\n        try _lender.transferLPTokens(address(borrower), _id, _balance) {\n            revert(\'should not have been possible to send LP tokens to the borrower\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT2\');\n        }\n    }\n    function test_borrowerCannotReceivePoolTokens() public {\n        assert_borrowerCannotReceivePoolTokens(requestId);\n        request.borrowerVerifier = mockAdminVerifier1;\n        borrower.registerSelf(mockAdminVerifier1);\n        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);\n        assert_borrowerCannotReceivePoolTokens(_id);\n    }\n    function assert_canTransferPoolTokensToVerifiedUser(\n        uint256 _id,\n        address _recevingAddress,\n        uint256 _amount\n    ) public {\n        // borrowing some tokens\n        {\n            uint256 _borrowAssetDecimalScaling = 10(ERC20(address(borrowAsset)).decimals());\n            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;\n            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n            _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);\n            // going ahead in time to generate interest\n            vm.warp(block.timestamp + 6 days);\n            // repaying the interest and some principal back\n            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);\n            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);\n        }\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender\n        _lender.withdrawInterest(_id);\n        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;\n        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;\n        // calculating the receivers interest in shares\n        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);\n        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            receiverInterestInTokens,\n            address(borrowAsset)\n        );\n        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);\n        _lender.transferLPTokens(_recevingAddress, _id, _amount);\n        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);\n        assertEq(_finalBalance - _prevBalance, _amount);\n        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;\n        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;\n        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;\n        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;\n        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);\n    }\n    function assert_cannotTransferEcxessPoolTokens(\n        uint256 _id,\n        address _recevingAddress,\n        uint256 _amount\n    ) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {\n            revert(\'balance less than the amount to transfer\');\n        } catch Error(string memory reason) {\n            // assertEq(reason, \'ERC1155: insufficient balance for transfer\');\n            assertEq(reason, \'SafeMath: subtraction overflow\');\n        }\n    }\n    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);\n        log_named_uint(\'lender lp balance: \', _balance);\n        // testing when user is not verified\n        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {\n            revert(\'should not have been possible to send LP tokens to not verified user\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT3\');\n        }\n    }\n    function test_lenderTransfersTokenToAnotherLender() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n        address _recevingAddress = lenders[1].lenderAddress;\n        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);\n        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);\n    }\n    function test_lenderTransferTokenToNewUser() public {\n        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));\n        // testing when user is verified\n        _newUser.registerSelf(mockAdminVerifier1);\n        LenderInfo memory _lenderInfo = lenders[0];\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);\n    }\n    function test_areTokensTransferable() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        LenderInfo memory _lenderInfo = lenders[0];\n        address _recevingAddress = lenders[1].lenderAddress;\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {\n            revert(\'should not have been possible to send LP tokens to the borrower\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT5\');\n        }\n    }\n    function test_canTransferPoolTokensWhenZeroInterest() public {\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);\n        assertGe(_startBalanceLenderFrom, 0);\n        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);\n        assertGe(_startBalanceLenderTo, 0);\n        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);\n        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);\n        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));\n        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));\n    }\n    function test_cannotWithdrawZeroInterest() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        // cannot withdraw zero interest\n        vm.expectRevert(bytes(\'LP:WI1\'));\n        _lender.withdrawInterest(requestId);\n    }\n    function test_newPoolTokenHolderCanWithdrawInterest() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _newUser.registerSelf(mockAdminVerifier1);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n        _lender.transferLPTokens(address(_newUser), requestId, _balance);\n        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);\n        assertEq(_newUserBalance, _balance);\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        borrower.borrow(requestId, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // going ahead in time to generate interest\n        vm.warp(block.timestamp + 6 days);\n        // repaying the interest and some principal back\n        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        borrower.repay(requestId, 10_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // fetch borrowerInterestSharesWithdrawn for new user\n        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;\n        assertEq(_prevBISW, 0);\n        // get the interest for the new user\n        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));\n        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));\n        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser\n        _newUser.withdrawInterest(requestId);\n        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;\n        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;\n        // match the interest shares withdrawn with the interest calculated\n        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);\n    }\n    function test_stateAfterBorrow() public {\n        admin.updateProtocolFeeFraction(0);\n        uint256 _amountToBorrow = request.borrowLimit;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        emit log_named_uint(\'borrowable amount\', _borrowableAmount);\n        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);\n        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));\n        borrower.borrow(requestId, _borrowableAmount);\n        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));\n        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);\n        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);\n    }\n    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {\n        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());\n        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        emit log_named_uint(\'_collateralRequired: \', _collateralRequired);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        // borrow some amount\n        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());\n        if (_curBorrowAmount == _amountToBorrow) {\n            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);\n        }\n        borrower.borrow(requestId, _curBorrowAmount);\n        // check borrow able amount\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        if (request.collateralRatio != 0) {\n            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);\n        } else {\n            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);\n        }\n        // now check withdrawableCollateral\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);\n        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);\n    }\n    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {\n        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);\n    }\n    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {\n        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10_decimals).div(_ratioOfPrices);\n        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));\n    }\n    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {\n        if (request.collateralRatio == 0) return;\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);\n        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10ERC20(address(borrowAsset)).decimals()));\n        emit log_named_uint(\'_maxCollateral: \', _maxCollateral);\n        emit log_named_uint(\'_minCollateral: \', _minCollateral);\n        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);\n        emit log_named_uint(\'_collateralAmount: \', _collateralAmount);\n        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);\n        emit log_named_uint(\'_collateralRatioToAchieve: \', _collateralRatioToAchieve);\n        // calulating what should borrowed to achieve _collateralRatioToAchieve\n        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10_decimals).mul(pcl.SCALING_FACTOR()).div(\n            _collateralRatioToAchieve\n        );\n        emit log_named_uint(\'_amountToBorrow: \', _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);\n        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);\n        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);\n        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);\n        emit log_named_uint(\'_maxBorrowable: \', _maxBorrowable);\n        if (\n            request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14\n        ) {\n            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);\n            if (_amountToBorrow &gt; _maxBorrowable) {\n                _amountToBorrow = _maxBorrowable;\n            }\n        } else {\n            assertLe(_amountToBorrow, _maxBorrowable);\n        }\n        borrower.borrow(requestId, _amountToBorrow);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);\n        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        emit log_named_uint(\'_curCollateralRatio: \', _curCollateralRatio);\n        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve\n        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);\n    }\n    function test_closeActivePCLOncePrincipalPaidAndEnded() public {\n        // borrowing some tokens\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        borrower.borrow(requestId, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // going ahead in time to generate interest\n        vm.warp(block.timestamp + 6 days);\n        // repay everything back\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        uint256 _balance = borrowAsset.balanceOf(address(borrower));\n        if (_currentDebt &gt; _balance) {\n            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));\n        }\n        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n        // go to end of pcl\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n        assertEq(0, borrowAsset.balanceOf(address(borrower)));\n    }\n    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);\n    function test_closeWhenNoCollateral() public {\n        vm.warp(block.timestamp + 6 days);\n        // close\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n    function test_closeWhenCollateral() public {\n        uint256 _collateralAmount = 1e2 * 10ERC20(address(collateralAsset)).decimals();\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);\n        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);\n        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));\n        vm.warp(block.timestamp + 6 days);\n        vm.roll(block.number + (6 * 86400) / 20);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));\n        vm.expectEmit(true, true, false, false);\n        emit CollateralSharesWithdrawn(requestId, _shares);\n        // close\n        borrower.close(requestId);\n        // this is equal only when no yield is used\n        // with compund this should be assertLe becuase deposited collateral would earn yield\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));\n        } else {\n            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));\n        }\n    }\n    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);\n    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);\n    function test_withdrawLiquidatedCollateral() public {\n        if (request.collateralRatio == 0) return;\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);\n        borrower.borrow(requestId, _borrowable.sub(10));\n        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            request.borrowLimit - _borrowable.sub(10),\n            address(borrowAsset)\n        );\n        // going ahead in time to make liquidation possible\n        vm.warp(block.timestamp + 50 days);\n        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);\n        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _totalSupply = lp.totalSupply(requestId);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            _principalBorowable,\n            address(borrowAsset)\n        );\n        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +\n            _lenderYieldShares;\n        vm.expectEmit(true, true, false, false);\n        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);\n        _lender.liquidate(requestId, true);\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));\n        } else {\n            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));\n        }\n    }\n    event PooledCreditLineTerminated(uint256 indexed id);\n    function test_terminateAfterLiquidation() public {\n        if (request.collateralRatio == 0) return;\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);\n        borrower.borrow(requestId, _borrowable);\n        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            request.borrowLimit - _borrowable,\n            address(borrowAsset)\n        );\n        // going ahead in time to make liquidation possible\n        vm.warp(block.timestamp + request.duration.mul(7).div(11));\n        vm.roll(block.number + request.duration.mul(7).div(11).div(20));\n        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);\n        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _totalSupply = lp.totalSupply(requestId);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            _principalBorowable,\n            address(borrowAsset)\n        );\n        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +\n            _lenderYieldShares;\n        vm.expectEmit(true, true, false, false);\n        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);\n        _lender.liquidate(requestId, true);\n        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));\n        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));\n        emit log_named_uint(\'_lenderPoolCollateralAssetBalance: \', _lenderPoolCollateralAssetBalance);\n        // for an active pcl borrowLimit == total amount lent\n        _totalSupply = lp.totalSupply(requestId);\n        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);\n        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);\n        // emit log_named_uint(\'_borrowAssetInLenderPool: \', _borrowAssetInLenderPool);\n        // now the admin terminates\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineTerminated(requestId);\n        admin.terminate(requestId);\n        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));\n        if (request.borrowAssetStrategy == compoundYieldAddress) {\n            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));\n        } else {\n            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));\n        }\n    }\n    function _helperDepositCollateral(\n        PCLUser _user,\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) private {\n        if (_amount != 0) {\n            _user.depositCollateral(_id, _amount, _fromSavingsAccount);\n        }\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\ncontract PCLActiveStage is PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    uint256 requestId;\n    // enum PooledCreditLineStatus {\n    //     NOT_CREATED,\n    //     REQUESTED,\n    //     ACTIVE,\n    //     CLOSED,\n    //     EXPIRED,\n    //     LIQUIDATED,\n    //     CANCELLED\n    // }\n    function setUp() public virtual override {\n        super.setUp();\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n    }\n    function test_cannotStartActivePCL() public {\n        try borrower.start(requestId) {\n            revert(\'cannot start active pcl\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:S1\');\n        }\n    }\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert(\'External user cannot create\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert(\'External user cannot terminate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n    function test_cannotLendZeroAmount() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert(\'Lender cannot lend zero amount\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L1\');\n        }\n    }\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        // verified using the borrower verifier instead of lender verifier\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Unverified lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L2\');\n        }\n    }\n    function test_nonLenderCannotWithdrawLiquidity() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        try _pooledCreditLineLender.withdrawLiquidity(requestId) {\n            revert(\'Lender cannot withdraw liquidity\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWL1\');\n        }\n    }\n    function test_lenderCannotWithdrawLiquidity() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.withdrawLiquidity(requestId) {\n            revert(\'Lender cannot withdraw liquidity\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWL3\');\n        }\n    }\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Non lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WLC1\');\n        }\n    }\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWLC1\');\n        }\n    }\n    function test_cannotTransferLPTokensToSameAddress() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert(\'Lender cannot transfer LP tokens to itself\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT1\');\n        }\n    }\n    function test_cannotBurnPoolTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert(\'Lender cannot burn LP tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'ERC1155: transfer to the zero address\');\n        }\n    }\n    function test_cannotLendToActivePCL() public {\n        LenderInfo memory info = lenders[0];\n        PCLUser lender = PCLUser(info.lenderAddress);\n        try lender.lend(requestId, 100_000) {\n            revert(\'cannot lend to active pcl\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L3\');\n        }\n    }\n    function test_cannotLendToActivePCLNewLender() public {\n        // Creating a new lender for lending\n        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        lender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(request.borrowAsset, address(lender), 100_000);\n        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);\n        try lender.lend(requestId, 100_000) {\n            revert(\'cannot lend to active pcl\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L3\');\n        }\n    }\n    function test_lenderCannotBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);\n    }\n    function test_adminCannotBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));\n    }\n    function test_onlyBorrowerCanBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));\n    }\n    function assert_borrowByInvalidActor(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        PCLUser _user = PCLUser(_actor);\n        if (_actor == address(admin)) {\n            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n            _helperDepositCollateral(admin, _id, _collateralRequired, false);\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n            try admin.borrow(_id, _amountToBorrow) {\n                revert(\'Invalid user should not be able to borrow\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'PCL:OCLB1\');\n            }\n        } else {\n            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);\n            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n            _helperDepositCollateral(_user, _id, _collateralRequired, false);\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n            try _user.borrow(_id, _amountToBorrow) {\n                revert(\'Invalid user should not be able to borrow\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'PCL:OCLB1\');\n            }\n        }\n    }\n    function test_borrowerCannotBorrowMoreThanPossible() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);\n    }\n    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);\n        try borrower.borrow(_id, _amountBorrowable + 1) {\n            revert(\'Borrower should not be able to borrow more than possible\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:IB3\');\n        }\n    }\n    function test_borrowerCannotBorrowZeroAmount() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);\n    }\n    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        try borrower.borrow(_id, 0) {\n            revert(\'Borrower should not be able to borrow zero amount\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:IB1\');\n        }\n    }\n    function test_lenderDepositsAndCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);\n    }\n    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);\n    }\n    function test_adminDepositsAndCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));\n    }\n    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));\n    }\n    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _depositor,\n        address _withdrawer\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        // Depositing into PCL\n        if (_depositor == address(admin)) {\n            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n            _helperDepositCollateral(admin, _id, _collateralRequired, false);\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n        } else {\n            PCLUser _user = PCLUser(_depositor);\n            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);\n            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n            _helperDepositCollateral(_user, _id, _collateralRequired, false);\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n        }\n        // withdrawing from PCL\n        if (_withdrawer == address(admin)) {\n            try admin.withdrawCollateral(_id, _collateralRequired, false) {\n                revert(\'Admin should not be able to withdraw collateral\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'PCL:OCLB1\');\n            }\n        } else {\n            PCLUser _user = PCLUser(_withdrawer);\n            try _user.withdrawCollateral(_id, _collateralRequired, false) {\n                revert(\'Invalid actor should not be able to withdraw collateral\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'PCL:OCLB1\');\n            }\n        }\n    }\n    function test_borrowerCanWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);\n    }\n    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);\n        if (request.collateralRatio != 0) {\n            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);\n        }\n        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);\n    }\n    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);\n        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(_lender, _id, _collateralRequired, false);\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n        try _lender.withdrawAllCollateral(_id, false) {\n            revert(\'lender should not be able to withdraw all collateral\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:OCLB1\');\n        }\n    }\n    function test_adminDepositsAndCannotWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(admin, _id, _collateralRequired, false);\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n        try admin.withdrawAllCollateral(_id, false) {\n            revert(\'admin should not be able to withdraw all collateral\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:OCLB1\');\n        }\n    }\n    function test_borrowerCannotWithdrawZeroAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);\n    }\n    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        try borrower.withdrawAllCollateral(_id, false) {\n            revert(\'borrower should not be able to withdraw zero all collateral\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:WAC1\');\n        }\n    }\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);\n    }\n    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n        try borrower.withdrawCollateral(_id, 0, false) {\n            revert(\'Withdrawing zero collateral should fail\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:WC2\');\n        }\n    }\n    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);\n    }\n    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);\n        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {\n            revert(\'Withdrawing more collateral than withdrawable should fail\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:WC1\');\n        }\n    }\n    function test_borrowerCanWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        if (request.collateralRatio != 0) {\n            borrower.withdrawAllCollateral(_id, false);\n        }\n        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);\n    }\n    function test_cannotCloseIfDebtIsNonZero() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);\n    }\n    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));\n        borrower.borrow(_id, 90_000 * (10ERC20(address(borrowAsset)).decimals()));\n        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));\n        try borrower.close(_id) {\n            revert(\'Borrower should not be able to close with non-zero debt\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:C2\');\n        }\n    }\n    function test_lenderCannotClose() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);\n    }\n    function test_adminCannotClose() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));\n    }\n    function assert_invalidActorCannotClose(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, request.minBorrowAmount);\n        if (_actor == address(admin)) {\n            try admin.close(_id) {\n                revert(\'Admin should not be able to close PCL\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'PCL:OCLB1\');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n            try _user.close(_id) {\n                revert(\'Invalid actor should not be able to close PCL\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'PCL:OCLB1\');\n            }\n        }\n    }\n    function test_borrowerCanRepayAndClose() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);\n    }\n    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        vm.warp(block.timestamp + (request.duration / 2));\n        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(_id, _currentDebt);\n        _currentDebt = pcl.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0);\n        borrower.close(_id);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);\n    }\n    function test_repayWithInsufficientBalance() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        vm.warp(block.timestamp + (request.duration / 2));\n        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));\n        try borrower.repay(_id, _currentDebt) {\n            revert(\'REVERT: Insufficient Balance\');\n        } catch Error(string memory reason) {\n            if (!isForked) {\n                assertEq(reason, \'ERC20: transfer amount exceeds allowance\');\n            } else {\n                assertEq(reason, \'Dai/insufficient-allowance\');\n            }\n        }\n    }\n    function test_borrowerCannotLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));\n    }\n    function test_adminCannotLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        emit log_named_uint(\'request.borrowLimit\', request.borrowLimit);\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));\n    }\n    function assert_InvalidActorCannotLiquidate(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);\n        borrower.borrow(_id, _borrowable);\n        vm.warp(block.timestamp + (request.duration / 2));\n        if (!isForked) {\n            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);\n        }\n        if (_actor == address(admin)) {\n            try admin.liquidate(_id, true) {\n                revert(\'admin liquidating should revert\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'LP:LIQ1\');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n            try _user.liquidate(_id, true) {\n                revert(\'Invalid actor liquidating should revert\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'LP:LIQ1\');\n            }\n        }\n    }\n    function test_onlyLendersCanLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit / 3;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);\n    }\n    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {\n        if (request.collateralRatio == 0) return;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);\n        borrower.borrow(_id, _borrowable);\n        vm.warp(block.timestamp + (request.duration / 2));\n        if (!isForked) {\n            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);\n        }\n        PCLUser _lender = PCLUser(lenders[1].lenderAddress);\n        uint256 _amountLent = lenders[1].amount;\n        _lender.liquidate(_id, true);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n    function test_lenderCannotLiquidateZeroPrincipal() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);\n    }\n    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        vm.warp(block.timestamp + (request.duration / 2));\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.liquidate(_id, true) {\n            revert(\'Lender liquidating should revert with zero principal\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L1\');\n        }\n    }\n    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);\n    }\n    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, _amountToBorrow / 2);\n        vm.warp(block.timestamp + (request.duration / 2));\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.liquidate(_id, true) {\n            revert(\'Lender liquidating should revert with if collateral ratio is more than ideal\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L3\');\n        }\n    }\n    function test_borrowerCannotTerminate() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotTerminate(_id);\n    }\n    function assert_borrowerCannotTerminate(uint256 _id) public {\n        try borrower.terminate(_id) {\n            revert(\'Borrower terminating PCL should fail\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'Ownable: caller is not the owner\');\n        }\n    }\n    function test_lenderCannotTerminate() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotTerminate(_id);\n    }\n    function assert_lenderCannotTerminate(uint256 _id) public {\n        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));\n        try _lender.terminate(_id) {\n            revert(\'Lender terminating PCL should fail\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'Ownable: caller is not the owner\');\n        }\n    }\n    function test_onlyAdminCanTerminate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_onlyAdminCanTerminate(_id, _amountToBorrow);\n    }\n    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        vm.warp(block.timestamp + (request.duration / 2));\n        vm.roll(block.number + (request.duration / (2 * 20)));\n        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));\n        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));\n        admin.terminate(_id);\n        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));\n        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);\n        } else {\n            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);\n        }\n        if (request.borrowAssetStrategy == compoundYieldAddress) {\n            assertGe(\n                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,\n                (request.borrowLimit / 2) - 90_000 * 10(ERC20(address(borrowAsset)).decimals())\n            );\n        } else {\n            assertEq(\n                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,\n                (request.borrowLimit / 2) - 90_000 * 10(ERC20(address(borrowAsset)).decimals())\n            );\n        }\n    }\n    function test_depositCollateral() public {\n        uint256 _amount = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_depositCollateral(_id, _amount);\n    }\n    function assert_depositCollateral(uint256 _id, uint256 _amount) public {\n        // lender.lend(_id, _amount);\n        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());\n        admin.transferToken(address(collateralAsset), address(borrower), _amount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);\n        borrower.depositCollateral(_id, _amount, false);\n        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));\n        assertEq(pcl.depositedCollateralInShares(_id), _shares);\n    }\n    function test_depositCollateral_insufficientBalance() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        admin.transferToken(address(collateralAsset), address(borrower), 10);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);\n        try borrower.depositCollateral(_id, 100, false) {\n            revert(\'Insufficient Balance of collateral tokens\');\n        } catch Error(string memory reason) {\n            if (!isForked) {\n                assertEq(reason, \'ERC20: transfer amount exceeds balance\');\n            } else {\n                assertEq(reason, \'SafeERC20: low-level call failed\');\n            }\n        }\n    }\n    function test_depositZeroCollateral() public {\n        uint256 _amount = 0;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_depositZeroCollateral(_id, _amount);\n    }\n    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {\n        // lender.lend(_id, _amount);\n        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10ERC20(address(collateralAsset)).decimals()));\n        borrower.setAllowance(\n            pooledCreditLineAddress,\n            address(collateralAsset),\n            100_000 * (10ERC20(address(collateralAsset)).decimals())\n        );\n        try borrower.depositCollateral(_id, _amount, false) {\n            revert(\'Depositing zero collateral should fail\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:DC1\');\n        }\n    }\n    function test_depositCollateralFromSavingsAccount() public {\n        request.collateralAssetStrategy = compoundYieldAddress;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));\n        emit log_named_decimal_uint(\'_collateralRequired\', _collateralRequired, ERC20(address(collateralAsset)).decimals());\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);\n        if (request.collateralRatio != 0) {\n            borrower.depositToSavingsAccount(\n                savingsAccountAddress,\n                _collateralRequired,\n                address(collateralAsset),\n                compoundYieldAddress,\n                address(borrower)\n            );\n        }\n        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));\n        emit log_named_uint(\'total tokens: \', _totalTokens);\n        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            address(borrower),\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint(\'_curBalanceInShares: \', _curBalanceInShares);\n        emit log_named_uint(\'required collateral: \', _collateralRequired);\n        borrower.setAllowanceForSavingsAccount(\n            savingsAccountAddress,\n            _collateralRequired,\n            address(collateralAsset),\n            pooledCreditLineAddress\n        );\n        _helperDepositCollateral(borrower, _id, _collateralRequired, true);\n        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);\n        emit log_named_uint(\'_borrowAbleAmount: \', _borrowAbleAmount);\n        // assertEq(_borrowAbleAmount, _amountToBorrow);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);\n        emit log_named_uint(\'_withdrawableCollateral: \', _withdrawableCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.withdrawAllCollateral(_id, true);\n        }\n        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            address(borrower),\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint(\'_finalBalanceInShares: \', _finalBalanceInShares);\n        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            pooledCreditLineAddress,\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint(\'_pclBalanceInShares: \', _pclBalanceInShares);\n        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);\n    }\n    function test_adminCannotCancelRequest() public {\n        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));\n    }\n    function test_lenderCannotCancelRequest() public {\n        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);\n    }\n    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {\n        if (_actor == address(admin)) {\n            try admin.cancelRequest(_id) {\n                revert(\'Admin cannot cancel PCL\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'PCL:OCLB1\');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n            try _user.cancelRequest(_id) {\n                revert(\'Invalid actor cannot cancel PCL\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'PCL:OCLB1\');\n            }\n        }\n    }\n    function test_borrowerCannotCancelRequest() public {\n        assert_borrowerCannotCancelRequest(requestId);\n    }\n    function assert_borrowerCannotCancelRequest(uint256 _id) public {\n        try borrower.cancelRequest(_id) {\n            revert(\'Canceling a PCL in active stage should fail\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:CR1\');\n        }\n    }\n    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {\n        _seed = scaleToRange128(_seed, 1, 10);\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);\n        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);\n    }\n    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        try borrower.repay(_id, 1) {\n            revert(\'Borrower should not be able to repay zero current debt\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:REP3\');\n        }\n    }\n    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {\n        _seed = scaleToRange128(_seed, 1, 10);\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);\n        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);\n    }\n    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        uint256 _borrowAssetDecimalScaling = 10(ERC20(address(borrowAsset)).decimals());\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);\n        try borrower.repay(_id, 1) {\n            revert(\'Borrower should not be able to repay if interest is zero\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:REP4\');\n        }\n    }\n    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);\n        log_named_uint(\'lender lp balance: \', _balance);\n        try _lender.transferLPTokens(address(borrower), _id, _balance) {\n            revert(\'should not have been possible to send LP tokens to the borrower\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT2\');\n        }\n    }\n    function test_borrowerCannotReceivePoolTokens() public {\n        assert_borrowerCannotReceivePoolTokens(requestId);\n        request.borrowerVerifier = mockAdminVerifier1;\n        borrower.registerSelf(mockAdminVerifier1);\n        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);\n        assert_borrowerCannotReceivePoolTokens(_id);\n    }\n    function assert_canTransferPoolTokensToVerifiedUser(\n        uint256 _id,\n        address _recevingAddress,\n        uint256 _amount\n    ) public {\n        // borrowing some tokens\n        {\n            uint256 _borrowAssetDecimalScaling = 10(ERC20(address(borrowAsset)).decimals());\n            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;\n            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n            _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);\n            // going ahead in time to generate interest\n            vm.warp(block.timestamp + 6 days);\n            // repaying the interest and some principal back\n            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);\n            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);\n        }\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender\n        _lender.withdrawInterest(_id);\n        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;\n        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;\n        // calculating the receivers interest in shares\n        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);\n        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            receiverInterestInTokens,\n            address(borrowAsset)\n        );\n        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);\n        _lender.transferLPTokens(_recevingAddress, _id, _amount);\n        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);\n        assertEq(_finalBalance - _prevBalance, _amount);\n        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;\n        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;\n        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;\n        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;\n        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);\n    }\n    function assert_cannotTransferEcxessPoolTokens(\n        uint256 _id,\n        address _recevingAddress,\n        uint256 _amount\n    ) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {\n            revert(\'balance less than the amount to transfer\');\n        } catch Error(string memory reason) {\n            // assertEq(reason, \'ERC1155: insufficient balance for transfer\');\n            assertEq(reason, \'SafeMath: subtraction overflow\');\n        }\n    }\n    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);\n        log_named_uint(\'lender lp balance: \', _balance);\n        // testing when user is not verified\n        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {\n            revert(\'should not have been possible to send LP tokens to not verified user\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT3\');\n        }\n    }\n    function test_lenderTransfersTokenToAnotherLender() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n        address _recevingAddress = lenders[1].lenderAddress;\n        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);\n        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);\n    }\n    function test_lenderTransferTokenToNewUser() public {\n        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));\n        // testing when user is verified\n        _newUser.registerSelf(mockAdminVerifier1);\n        LenderInfo memory _lenderInfo = lenders[0];\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);\n    }\n    function test_areTokensTransferable() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        LenderInfo memory _lenderInfo = lenders[0];\n        address _recevingAddress = lenders[1].lenderAddress;\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {\n            revert(\'should not have been possible to send LP tokens to the borrower\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT5\');\n        }\n    }\n    function test_canTransferPoolTokensWhenZeroInterest() public {\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);\n        assertGe(_startBalanceLenderFrom, 0);\n        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);\n        assertGe(_startBalanceLenderTo, 0);\n        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);\n        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);\n        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));\n        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));\n    }\n    function test_cannotWithdrawZeroInterest() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        // cannot withdraw zero interest\n        vm.expectRevert(bytes(\'LP:WI1\'));\n        _lender.withdrawInterest(requestId);\n    }\n    function test_newPoolTokenHolderCanWithdrawInterest() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _newUser.registerSelf(mockAdminVerifier1);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n        _lender.transferLPTokens(address(_newUser), requestId, _balance);\n        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);\n        assertEq(_newUserBalance, _balance);\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        borrower.borrow(requestId, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // going ahead in time to generate interest\n        vm.warp(block.timestamp + 6 days);\n        // repaying the interest and some principal back\n        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        borrower.repay(requestId, 10_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // fetch borrowerInterestSharesWithdrawn for new user\n        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;\n        assertEq(_prevBISW, 0);\n        // get the interest for the new user\n        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));\n        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));\n        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser\n        _newUser.withdrawInterest(requestId);\n        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;\n        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;\n        // match the interest shares withdrawn with the interest calculated\n        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);\n    }\n    function test_stateAfterBorrow() public {\n        admin.updateProtocolFeeFraction(0);\n        uint256 _amountToBorrow = request.borrowLimit;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        emit log_named_uint(\'borrowable amount\', _borrowableAmount);\n        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);\n        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));\n        borrower.borrow(requestId, _borrowableAmount);\n        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));\n        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);\n        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);\n    }\n    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {\n        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());\n        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        emit log_named_uint(\'_collateralRequired: \', _collateralRequired);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        // borrow some amount\n        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());\n        if (_curBorrowAmount == _amountToBorrow) {\n            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);\n        }\n        borrower.borrow(requestId, _curBorrowAmount);\n        // check borrow able amount\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        if (request.collateralRatio != 0) {\n            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);\n        } else {\n            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);\n        }\n        // now check withdrawableCollateral\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);\n        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);\n    }\n    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {\n        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);\n    }\n    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {\n        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10_decimals).div(_ratioOfPrices);\n        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));\n    }\n    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {\n        if (request.collateralRatio == 0) return;\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);\n        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10ERC20(address(borrowAsset)).decimals()));\n        emit log_named_uint(\'_maxCollateral: \', _maxCollateral);\n        emit log_named_uint(\'_minCollateral: \', _minCollateral);\n        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);\n        emit log_named_uint(\'_collateralAmount: \', _collateralAmount);\n        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);\n        emit log_named_uint(\'_collateralRatioToAchieve: \', _collateralRatioToAchieve);\n        // calulating what should borrowed to achieve _collateralRatioToAchieve\n        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10_decimals).mul(pcl.SCALING_FACTOR()).div(\n            _collateralRatioToAchieve\n        );\n        emit log_named_uint(\'_amountToBorrow: \', _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);\n        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);\n        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);\n        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);\n        emit log_named_uint(\'_maxBorrowable: \', _maxBorrowable);\n        if (\n            request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14\n        ) {\n            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);\n            if (_amountToBorrow &gt; _maxBorrowable) {\n                _amountToBorrow = _maxBorrowable;\n            }\n        } else {\n            assertLe(_amountToBorrow, _maxBorrowable);\n        }\n        borrower.borrow(requestId, _amountToBorrow);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);\n        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        emit log_named_uint(\'_curCollateralRatio: \', _curCollateralRatio);\n        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve\n        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);\n    }\n    function test_closeActivePCLOncePrincipalPaidAndEnded() public {\n        // borrowing some tokens\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        borrower.borrow(requestId, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // going ahead in time to generate interest\n        vm.warp(block.timestamp + 6 days);\n        // repay everything back\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        uint256 _balance = borrowAsset.balanceOf(address(borrower));\n        if (_currentDebt &gt; _balance) {\n            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));\n        }\n        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n        // go to end of pcl\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n        assertEq(0, borrowAsset.balanceOf(address(borrower)));\n    }\n    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);\n    function test_closeWhenNoCollateral() public {\n        vm.warp(block.timestamp + 6 days);\n        // close\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n    function test_closeWhenCollateral() public {\n        uint256 _collateralAmount = 1e2 * 10ERC20(address(collateralAsset)).decimals();\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);\n        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);\n        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));\n        vm.warp(block.timestamp + 6 days);\n        vm.roll(block.number + (6 * 86400) / 20);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));\n        vm.expectEmit(true, true, false, false);\n        emit CollateralSharesWithdrawn(requestId, _shares);\n        // close\n        borrower.close(requestId);\n        // this is equal only when no yield is used\n        // with compund this should be assertLe becuase deposited collateral would earn yield\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));\n        } else {\n            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));\n        }\n    }\n    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);\n    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);\n    function test_withdrawLiquidatedCollateral() public {\n        if (request.collateralRatio == 0) return;\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);\n        borrower.borrow(requestId, _borrowable.sub(10));\n        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            request.borrowLimit - _borrowable.sub(10),\n            address(borrowAsset)\n        );\n        // going ahead in time to make liquidation possible\n        vm.warp(block.timestamp + 50 days);\n        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);\n        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _totalSupply = lp.totalSupply(requestId);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            _principalBorowable,\n            address(borrowAsset)\n        );\n        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +\n            _lenderYieldShares;\n        vm.expectEmit(true, true, false, false);\n        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);\n        _lender.liquidate(requestId, true);\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));\n        } else {\n            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));\n        }\n    }\n    event PooledCreditLineTerminated(uint256 indexed id);\n    function test_terminateAfterLiquidation() public {\n        if (request.collateralRatio == 0) return;\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);\n        borrower.borrow(requestId, _borrowable);\n        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            request.borrowLimit - _borrowable,\n            address(borrowAsset)\n        );\n        // going ahead in time to make liquidation possible\n        vm.warp(block.timestamp + request.duration.mul(7).div(11));\n        vm.roll(block.number + request.duration.mul(7).div(11).div(20));\n        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);\n        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _totalSupply = lp.totalSupply(requestId);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            _principalBorowable,\n            address(borrowAsset)\n        );\n        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +\n            _lenderYieldShares;\n        vm.expectEmit(true, true, false, false);\n        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);\n        _lender.liquidate(requestId, true);\n        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));\n        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));\n        emit log_named_uint(\'_lenderPoolCollateralAssetBalance: \', _lenderPoolCollateralAssetBalance);\n        // for an active pcl borrowLimit == total amount lent\n        _totalSupply = lp.totalSupply(requestId);\n        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);\n        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);\n        // emit log_named_uint(\'_borrowAssetInLenderPool: \', _borrowAssetInLenderPool);\n        // now the admin terminates\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineTerminated(requestId);\n        admin.terminate(requestId);\n        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));\n        if (request.borrowAssetStrategy == compoundYieldAddress) {\n            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));\n        } else {\n            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));\n        }\n    }\n    function _helperDepositCollateral(\n        PCLUser _user,\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) private {\n        if (_amount != 0) {\n            _user.depositCollateral(_id, _amount, _fromSavingsAccount);\n        }\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:26:18 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStage is PCLParent {     using SafeMath for uint256;     using SafeMath for uint128; uint256 requestId;  // enum PooledCreditLineStatus { //     NOT_CREATED, //     REQUESTED, //     ACTIVE, //     CLOSED, //     EXPIRED, //     LIQUIDATED, //     CANCELLED // }  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE); }  function test_cannotStartActivePCL() public {     try borrower.start(requestId) {         revert('cannot start active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     // verified using the borrower verifier instead of lender verifier     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_nonLenderCannotWithdrawLiquidity() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);     try _pooledCreditLineLender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL1');     } }  function test_lenderCannotWithdrawLiquidity() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotLendToActivePCL() public {     LenderInfo memory info = lenders[0];     PCLUser lender = PCLUser(info.lenderAddress);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendToActivePCLNewLender() public {     // Creating a new lender for lending     PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     lender.registerSelf(mockAdminVerifier1);     admin.transferToken(request.borrowAsset, address(lender), 100_000);     lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin)); }  function test_onlyBorrowerCanBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;     PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker)); }  function assert_borrowByInvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _user = PCLUser(_actor);     if (_actor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try admin.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try _user.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotBorrowMoreThanPossible() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);      try borrower.borrow(_id, _amountBorrowable + 1) {         revert('Borrower should not be able to borrow more than possible');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB3');     } }  function test_borrowerCannotBorrowZeroAmount() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.borrow(_id, 0) {         revert('Borrower should not be able to borrow zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB1');     } }  function test_lenderDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress); }  function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress); }  function test_adminDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin)); }  function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin)); }  function assert_DepositAndCannotWithdrawCollateral_InvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _depositor,     address _withdrawer ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      // Depositing into PCL     if (_depositor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     } else {         PCLUser _user = PCLUser(_depositor);          admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     }      // withdrawing from PCL     if (_withdrawer == address(admin)) {         try admin.withdrawCollateral(_id, _collateralRequired, false) {             revert('Admin should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_withdrawer);          try _user.withdrawCollateral(_id, _collateralRequired, false) {             revert('Invalid actor should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     if (request.collateralRatio != 0) {         borrower.withdrawCollateral(_id, _withdrawableCollateral, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_lenderDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);     _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(_lender, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try _lender.withdrawAllCollateral(_id, false) {         revert('lender should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_adminDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(admin, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try admin.withdrawAllCollateral(_id, false) {         revert('admin should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_borrowerCannotWithdrawZeroAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     try borrower.withdrawAllCollateral(_id, false) {         revert('borrower should not be able to withdraw zero all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  function test_borrowerCannotWithdrawZeroCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try borrower.withdrawCollateral(_id, 0, false) {         revert('Withdrawing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC2');     } }  function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);      try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {         revert('Withdrawing more collateral than withdrawable should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  function test_borrowerCanWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_cannotCloseIfDebtIsNonZero() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow); }  function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));     borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));     // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));      try borrower.close(_id) {         revert('Borrower should not be able to close with non-zero debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  function test_lenderCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin)); }  function assert_invalidActorCannotClose(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, request.minBorrowAmount);      if (_actor == address(admin)) {         try admin.close(_id) {             revert('Admin should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.close(_id) {             revert('Invalid actor should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanRepayAndClose() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanRepayAndClose(_id, _amountToBorrow); }  function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(_id, _currentDebt);      _currentDebt = pcl.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0);      borrower.close(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED); }  function test_repayWithInsufficientBalance() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));     try borrower.repay(_id, _currentDebt) {         revert('REVERT: Insufficient Balance');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds allowance');         } else {             assertEq(reason, 'Dai/insufficient-allowance');         }     } }  function test_borrowerCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower)); }  function test_adminCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;     emit log_named_uint('request.borrowLimit', request.borrowLimit);     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin)); }  function assert_InvalidActorCannotLiquidate(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      if (_actor == address(admin)) {         try admin.liquidate(_id, true) {             revert('admin liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.liquidate(_id, true) {             revert('Invalid actor liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } }  function test_onlyLendersCanLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit / 3;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyLendersCanLiquidate(_id, _amountToBorrow); }  function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {     if (request.collateralRatio == 0) return;     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      PCLUser _lender = PCLUser(lenders[1].lenderAddress);     uint256 _amountLent = lenders[1].amount;     _lender.liquidate(_id, true);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_lenderCannotLiquidateZeroPrincipal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with zero principal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, _amountToBorrow / 2);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with if collateral ratio is more than ideal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  function test_borrowerCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotTerminate(_id); }  function assert_borrowerCannotTerminate(uint256 _id) public {     try borrower.terminate(_id) {         revert('Borrower terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_lenderCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotTerminate(_id); }  function assert_lenderCannotTerminate(uint256 _id) public {     PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));     try _lender.terminate(_id) {         revert('Lender terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_onlyAdminCanTerminate() public {     uint256 _amountToBorrow = request.borrowLimit;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyAdminCanTerminate(_id, _amountToBorrow); }  function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));     vm.roll(block.number + (request.duration / (2 * 20)));      uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));     admin.terminate(_id);     uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     } else {         assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     }     if (request.borrowAssetStrategy == compoundYieldAddress) {         assertGe(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } else {         assertEq(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } }  function test_depositCollateral() public {     uint256 _amount = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositCollateral(_id, _amount); }  function assert_depositCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());     admin.transferToken(address(collateralAsset), address(borrower), _amount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);     borrower.depositCollateral(_id, _amount, false);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));     assertEq(pcl.depositedCollateralInShares(_id), _shares); }  function test_depositCollateral_insufficientBalance() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);      admin.transferToken(address(collateralAsset), address(borrower), 10);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);     try borrower.depositCollateral(_id, 100, false) {         revert('Insufficient Balance of collateral tokens');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds balance');         } else {             assertEq(reason, 'SafeERC20: low-level call failed');         }     } }  function test_depositZeroCollateral() public {     uint256 _amount = 0;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositZeroCollateral(_id, _amount); }  function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));     borrower.setAllowance(         pooledCreditLineAddress,         address(collateralAsset),         100_000 * (10**ERC20(address(collateralAsset)).decimals())     );     try borrower.depositCollateral(_id, _amount, false) {         revert('Depositing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC1');     } }  function test_depositCollateralFromSavingsAccount() public {     request.collateralAssetStrategy = compoundYieldAddress;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));     emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);     if (request.collateralRatio != 0) {         borrower.depositToSavingsAccount(             savingsAccountAddress,             _collateralRequired,             address(collateralAsset),             compoundYieldAddress,             address(borrower)         );     }     uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));     emit log_named_uint('total tokens: ', _totalTokens);     uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);     emit log_named_uint('required collateral: ', _collateralRequired);     borrower.setAllowanceForSavingsAccount(         savingsAccountAddress,         _collateralRequired,         address(collateralAsset),         pooledCreditLineAddress     );     _helperDepositCollateral(borrower, _id, _collateralRequired, true);     uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);     emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);     // assertEq(_borrowAbleAmount, _amountToBorrow);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, true);     }     uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);     uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         pooledCreditLineAddress,         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);     assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14); }  function test_adminCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, address(admin)); }  function test_lenderCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress); }  function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {     if (_actor == address(admin)) {         try admin.cancelRequest(_id) {             revert('Admin cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);         try _user.cancelRequest(_id) {             revert('Invalid actor cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotCancelRequest() public {     assert_borrowerCannotCancelRequest(requestId); }  function assert_borrowerCannotCancelRequest(uint256 _id) public {     try borrower.cancelRequest(_id) {         revert('Canceling a PCL in active stage should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow); }  function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay zero current debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP3');     } }  function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow); }  function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay if interest is zero');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP4');     } }  function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     try _lender.transferLPTokens(address(borrower), _id, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_borrowerCannotReceivePoolTokens() public {     assert_borrowerCannotReceivePoolTokens(requestId);     request.borrowerVerifier = mockAdminVerifier1;     borrower.registerSelf(mockAdminVerifier1);     (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);     assert_borrowerCannotReceivePoolTokens(_id); }  function assert_canTransferPoolTokensToVerifiedUser(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     // borrowing some tokens     {         uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());         uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;         uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);         admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);         borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);         _helperDepositCollateral(borrower, _id, _collateralRequired, false);         borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);          // going ahead in time to generate interest         vm.warp(block.timestamp + 6 days);         // repaying the interest and some principal back         borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);         borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);     }      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender     _lender.withdrawInterest(_id);      uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     // calculating the receivers interest in shares     uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);     uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         receiverInterestInTokens,         address(borrowAsset)     );      uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);     _lender.transferLPTokens(_recevingAddress, _id, _amount);      uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);     assertEq(_finalBalance - _prevBalance, _amount);      uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;     curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;     assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14); }  function assert_cannotTransferEcxessPoolTokens(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _id, _amount) {         revert('balance less than the amount to transfer');     } catch Error(string memory reason) {         // assertEq(reason, 'ERC1155: insufficient balance for transfer');         assertEq(reason, 'SafeMath: subtraction overflow');     } }  function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     // testing when user is not verified     try _lender.transferLPTokens(_newUserAddress, _id, _balance) {         revert('should not have been possible to send LP tokens to not verified user');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT3');     } }  function test_lenderTransfersTokenToAnotherLender() public {     LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     address _recevingAddress = lenders[1].lenderAddress;     assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);     assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance); }  function test_lenderTransferTokenToNewUser() public {     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));      // testing when user is verified     _newUser.registerSelf(mockAdminVerifier1);      LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);      assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3); }  function test_areTokensTransferable() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     LenderInfo memory _lenderInfo = lenders[0];      address _recevingAddress = lenders[1].lenderAddress;     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  function test_canTransferPoolTokensWhenZeroInterest() public {     PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);     assertGe(_startBalanceLenderFrom, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);      PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);     uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);     assertGe(_startBalanceLenderTo, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);      _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);     assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));     assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo)); }  function test_cannotWithdrawZeroInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);      // cannot withdraw zero interest     vm.expectRevert(bytes('LP:WI1'));     _lender.withdrawInterest(requestId); }  function test_newPoolTokenHolderCanWithdrawInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _newUser.registerSelf(mockAdminVerifier1);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     _lender.transferLPTokens(address(_newUser), requestId, _balance);     uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);     assertEq(_newUserBalance, _balance);     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repaying the interest and some principal back     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // fetch borrowerInterestSharesWithdrawn for new user     uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     assertEq(_prevBISW, 0);     // get the interest for the new user     uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));     uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser     _newUser.withdrawInterest(requestId);     uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;     // match the interest shares withdrawn with the interest calculated     assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14); }  function test_stateAfterBorrow() public {     admin.updateProtocolFeeFraction(0);      uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('borrowable amount', _borrowableAmount);     assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);      uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));     borrower.borrow(requestId, _borrowableAmount);     uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));      assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);     assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14); }  function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());     _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     emit log_named_uint('_collateralRequired: ', _collateralRequired);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     // borrow some amount     uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());     if (_curBorrowAmount == _amountToBorrow) {         _curBorrowAmount = _curBorrowAmount.mul(90).div(100);     }     borrower.borrow(requestId, _curBorrowAmount);     // check borrow able amount     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     if (request.collateralRatio != 0) {         assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);     } else {         assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);     }     // now check withdrawableCollateral     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);     assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14); }  function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction); }  function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {     _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);     assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount)); }  function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {     if (request.collateralRatio == 0) return;     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);     uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));     emit log_named_uint('_maxCollateral: ', _maxCollateral);     emit log_named_uint('_minCollateral: ', _minCollateral);     _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);     emit log_named_uint('_collateralAmount: ', _collateralAmount);     _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);     emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);     // calulating what should borrowed to achieve _collateralRatioToAchieve     uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(         _collateralRatioToAchieve     );     emit log_named_uint('_amountToBorrow: ', _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);      uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('_maxBorrowable: ', _maxBorrowable);     if (         request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14     ) {         assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);         if (_amountToBorrow &gt; _maxBorrowable) {             _amountToBorrow = _maxBorrowable;         }     } else {         assertLe(_amountToBorrow, _maxBorrowable);     }      borrower.borrow(requestId, _amountToBorrow);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);      uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);     // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve     assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14); }  function test_closeActivePCLOncePrincipalPaidAndEnded() public {     // borrowing some tokens     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repay everything back     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _balance = borrowAsset.balanceOf(address(borrower));     if (_currentDebt &gt; _balance) {         admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));     }     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);     // go to end of pcl     vm.warp(block.timestamp + request.collectionPeriod + request.duration);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);     assertEq(0, borrowAsset.balanceOf(address(borrower))); }  event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);  function test_closeWhenNoCollateral() public {     vm.warp(block.timestamp + 6 days);     // close     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_closeWhenCollateral() public {     uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();     admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     vm.warp(block.timestamp + 6 days);     vm.roll(block.number + (6 * 86400) / 20);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));     vm.expectEmit(true, true, false, false);     emit CollateralSharesWithdrawn(requestId, _shares);     // close     borrower.close(requestId);     // this is equal only when no yield is used     // with compund this should be assertLe becuase deposited collateral would earn yield     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } else {         assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } }  event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare); event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);  function test_withdrawLiquidatedCollateral() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable.sub(10));     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable.sub(10),         address(borrowAsset)     );     // going ahead in time to make liquidation possible     vm.warp(block.timestamp + 50 days);     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);      uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;      vm.expectEmit(true, true, false, false);     emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } else {         assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } }  event PooledCreditLineTerminated(uint256 indexed id);  function test_terminateAfterLiquidation() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable);     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable,         address(borrowAsset)     );      // going ahead in time to make liquidation possible     vm.warp(block.timestamp + request.duration.mul(7).div(11));     vm.roll(block.number + request.duration.mul(7).div(11).div(20));     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;     vm.expectEmit(true, true, false, false);      emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);      uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));      uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));     emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);     // for an active pcl borrowLimit == total amount lent     _totalSupply = lp.totalSupply(requestId);     // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);     // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);     // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);      // now the admin terminates     vm.expectEmit(true, true, false, true);     emit PooledCreditLineTerminated(requestId);     admin.terminate(requestId);      assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));      if (request.borrowAssetStrategy == compoundYieldAddress) {         // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } else {         // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } }  function _helperDepositCollateral(     PCLUser _user,     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) private {     if (_amount != 0) {         _user.depositCollateral(_id, _amount, _fromSavingsAccount);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:26:18 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;
import '@openzeppelin/contracts/math/SafeMath.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    uint256 requestId;
    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }
    function setUp() public virtual override {
        super.setUp();
        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }
    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }
    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }
    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }
    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }
    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }
    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }
    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }
    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }
    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }
    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);
        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }
    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);
        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }
    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }
    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }
    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }
    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }
    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }
    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(admin, _id, _collateralRequired, false);
            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(_user, _id, _collateralRequired, false);
            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }
    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }
    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);
        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }
    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }
    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }
    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }
    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }
    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }
    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }
    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(admin, _id, _collateralRequired, false);
            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(_user, _id, _collateralRequired, false);
            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }
        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);
            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }
    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }
    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);
        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }
    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }
    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(_lender, _id, _collateralRequired, false);
        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);
        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }
    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }
    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);
        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);
        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }
    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }
    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }
    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }
    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);
        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }
    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }
    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);
        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }
    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }
    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);
        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }
    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }
    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }
    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }
    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }
    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, request.minBorrowAmount);
        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }
    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }
    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        vm.warp(block.timestamp + (request.duration / 2));
        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);
        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);
        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }
    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        vm.warp(block.timestamp + (request.duration / 2));
        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }
    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }
    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }
    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);
        vm.warp(block.timestamp + (request.duration / 2));
        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }
        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }
    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }
    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);
        vm.warp(block.timestamp + (request.duration / 2));
        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }
        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }
    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }
    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }
    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }
    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);
        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }
    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }
    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }
    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }
    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }
    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }
    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));
        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }
    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }
    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }
    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }
    function test_depositZeroCollateral() public {
        uint256 _amount = 0;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }
    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }
    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }
    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }
    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }
    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }
    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }
    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }
    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }
    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }
    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }
    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);
        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }
    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }
    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }
    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);
            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);
        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );
        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);
        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);
        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }
    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }
    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }
    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }
    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));
        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }
    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];
        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);
        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }
    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }
    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }
    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);
        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));
        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }
    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }
    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }
    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }
    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);
        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }
        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);
        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }
    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }
    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);
    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }
    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);
    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }
    event PooledCreditLineTerminated(uint256 indexed id);
    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));
        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);
        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);
        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }
    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;
import '@openzeppelin/contracts/math/SafeMath.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    uint256 requestId;
    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }
    function setUp() public virtual override {
        super.setUp();
        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }
    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }
    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }
    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }
    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }
    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }
    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }
    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }
    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }
    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }
    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);
        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }
    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);
        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }
    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }
    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }
    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }
    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }
    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }
    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(admin, _id, _collateralRequired, false);
            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(_user, _id, _collateralRequired, false);
            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }
    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }
    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);
        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }
    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }
    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }
    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }
    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }
    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }
    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }
    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(admin, _id, _collateralRequired, false);
            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(_user, _id, _collateralRequired, false);
            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }
        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);
            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }
    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }
    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);
        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }
    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }
    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(_lender, _id, _collateralRequired, false);
        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);
        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }
    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }
    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);
        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);
        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }
    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }
    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }
    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }
    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);
        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }
    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }
    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);
        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }
    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }
    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);
        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }
    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }
    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }
    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }
    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }
    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, request.minBorrowAmount);
        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }
    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }
    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        vm.warp(block.timestamp + (request.duration / 2));
        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);
        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);
        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }
    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        vm.warp(block.timestamp + (request.duration / 2));
        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }
    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }
    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }
    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);
        vm.warp(block.timestamp + (request.duration / 2));
        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }
        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }
    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }
    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);
        vm.warp(block.timestamp + (request.duration / 2));
        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }
        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }
    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }
    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }
    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }
    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);
        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }
    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }
    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }
    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }
    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }
    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }
    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));
        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }
    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }
    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }
    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }
    function test_depositZeroCollateral() public {
        uint256 _amount = 0;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }
    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }
    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }
    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }
    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }
    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }
    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }
    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }
    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }
    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }
    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }
    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);
        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }
    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }
    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }
    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);
            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);
        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );
        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);
        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);
        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }
    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }
    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }
    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }
    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));
        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }
    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];
        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);
        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }
    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }
    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }
    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);
        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));
        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }
    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }
    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }
    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }
    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);
        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }
        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);
        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }
    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }
    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);
    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }
    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);
    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }
    event PooledCreditLineTerminated(uint256 indexed id);
    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));
        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);
        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);
        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }
    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-27-08 09:26:23 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:26:23 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 52369
completion_tokens: 1
total_tokens: 52370
cost: $-1.000000


[2024-27-08 09:26:23 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
.]

Security

[2024-27-08 09:26:23 INFO] **[Seminar Conclusion]**:

 Security

[2024-27-08 09:26:23 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-27-08 09:26:23 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-27-08 09:26:24 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStage is PCLParent {     using SafeMath for uint256;     using SafeMath for uint128; uint256 requestId;  // enum PooledCreditLineStatus { //     NOT_CREATED, //     REQUESTED, //     ACTIVE, //     CLOSED, //     EXPIRED, //     LIQUIDATED, //     CANCELLED // }  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE); }  function test_cannotStartActivePCL() public {     try borrower.start(requestId) {         revert('cannot start active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     // verified using the borrower verifier instead of lender verifier     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_nonLenderCannotWithdrawLiquidity() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);     try _pooledCreditLineLender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL1');     } }  function test_lenderCannotWithdrawLiquidity() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotLendToActivePCL() public {     LenderInfo memory info = lenders[0];     PCLUser lender = PCLUser(info.lenderAddress);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendToActivePCLNewLender() public {     // Creating a new lender for lending     PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     lender.registerSelf(mockAdminVerifier1);     admin.transferToken(request.borrowAsset, address(lender), 100_000);     lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin)); }  function test_onlyBorrowerCanBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;     PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker)); }  function assert_borrowByInvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _user = PCLUser(_actor);     if (_actor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try admin.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try _user.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotBorrowMoreThanPossible() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);      try borrower.borrow(_id, _amountBorrowable + 1) {         revert('Borrower should not be able to borrow more than possible');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB3');     } }  function test_borrowerCannotBorrowZeroAmount() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.borrow(_id, 0) {         revert('Borrower should not be able to borrow zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB1');     } }  function test_lenderDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress); }  function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress); }  function test_adminDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin)); }  function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin)); }  function assert_DepositAndCannotWithdrawCollateral_InvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _depositor,     address _withdrawer ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      // Depositing into PCL     if (_depositor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     } else {         PCLUser _user = PCLUser(_depositor);          admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     }      // withdrawing from PCL     if (_withdrawer == address(admin)) {         try admin.withdrawCollateral(_id, _collateralRequired, false) {             revert('Admin should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_withdrawer);          try _user.withdrawCollateral(_id, _collateralRequired, false) {             revert('Invalid actor should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     if (request.collateralRatio != 0) {         borrower.withdrawCollateral(_id, _withdrawableCollateral, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_lenderDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);     _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(_lender, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try _lender.withdrawAllCollateral(_id, false) {         revert('lender should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_adminDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(admin, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try admin.withdrawAllCollateral(_id, false) {         revert('admin should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_borrowerCannotWithdrawZeroAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     try borrower.withdrawAllCollateral(_id, false) {         revert('borrower should not be able to withdraw zero all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  function test_borrowerCannotWithdrawZeroCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try borrower.withdrawCollateral(_id, 0, false) {         revert('Withdrawing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC2');     } }  function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);      try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {         revert('Withdrawing more collateral than withdrawable should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  function test_borrowerCanWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_cannotCloseIfDebtIsNonZero() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow); }  function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));     borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));     // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));      try borrower.close(_id) {         revert('Borrower should not be able to close with non-zero debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  function test_lenderCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin)); }  function assert_invalidActorCannotClose(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, request.minBorrowAmount);      if (_actor == address(admin)) {         try admin.close(_id) {             revert('Admin should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.close(_id) {             revert('Invalid actor should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanRepayAndClose() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanRepayAndClose(_id, _amountToBorrow); }  function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(_id, _currentDebt);      _currentDebt = pcl.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0);      borrower.close(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED); }  function test_repayWithInsufficientBalance() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));     try borrower.repay(_id, _currentDebt) {         revert('REVERT: Insufficient Balance');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds allowance');         } else {             assertEq(reason, 'Dai/insufficient-allowance');         }     } }  function test_borrowerCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower)); }  function test_adminCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;     emit log_named_uint('request.borrowLimit', request.borrowLimit);     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin)); }  function assert_InvalidActorCannotLiquidate(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      if (_actor == address(admin)) {         try admin.liquidate(_id, true) {             revert('admin liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.liquidate(_id, true) {             revert('Invalid actor liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } }  function test_onlyLendersCanLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit / 3;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyLendersCanLiquidate(_id, _amountToBorrow); }  function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {     if (request.collateralRatio == 0) return;     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      PCLUser _lender = PCLUser(lenders[1].lenderAddress);     uint256 _amountLent = lenders[1].amount;     _lender.liquidate(_id, true);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_lenderCannotLiquidateZeroPrincipal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with zero principal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, _amountToBorrow / 2);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with if collateral ratio is more than ideal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  function test_borrowerCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotTerminate(_id); }  function assert_borrowerCannotTerminate(uint256 _id) public {     try borrower.terminate(_id) {         revert('Borrower terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_lenderCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotTerminate(_id); }  function assert_lenderCannotTerminate(uint256 _id) public {     PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));     try _lender.terminate(_id) {         revert('Lender terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_onlyAdminCanTerminate() public {     uint256 _amountToBorrow = request.borrowLimit;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyAdminCanTerminate(_id, _amountToBorrow); }  function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));     vm.roll(block.number + (request.duration / (2 * 20)));      uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));     admin.terminate(_id);     uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     } else {         assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     }     if (request.borrowAssetStrategy == compoundYieldAddress) {         assertGe(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } else {         assertEq(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } }  function test_depositCollateral() public {     uint256 _amount = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositCollateral(_id, _amount); }  function assert_depositCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());     admin.transferToken(address(collateralAsset), address(borrower), _amount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);     borrower.depositCollateral(_id, _amount, false);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));     assertEq(pcl.depositedCollateralInShares(_id), _shares); }  function test_depositCollateral_insufficientBalance() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);      admin.transferToken(address(collateralAsset), address(borrower), 10);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);     try borrower.depositCollateral(_id, 100, false) {         revert('Insufficient Balance of collateral tokens');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds balance');         } else {             assertEq(reason, 'SafeERC20: low-level call failed');         }     } }  function test_depositZeroCollateral() public {     uint256 _amount = 0;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositZeroCollateral(_id, _amount); }  function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));     borrower.setAllowance(         pooledCreditLineAddress,         address(collateralAsset),         100_000 * (10**ERC20(address(collateralAsset)).decimals())     );     try borrower.depositCollateral(_id, _amount, false) {         revert('Depositing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC1');     } }  function test_depositCollateralFromSavingsAccount() public {     request.collateralAssetStrategy = compoundYieldAddress;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));     emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);     if (request.collateralRatio != 0) {         borrower.depositToSavingsAccount(             savingsAccountAddress,             _collateralRequired,             address(collateralAsset),             compoundYieldAddress,             address(borrower)         );     }     uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));     emit log_named_uint('total tokens: ', _totalTokens);     uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);     emit log_named_uint('required collateral: ', _collateralRequired);     borrower.setAllowanceForSavingsAccount(         savingsAccountAddress,         _collateralRequired,         address(collateralAsset),         pooledCreditLineAddress     );     _helperDepositCollateral(borrower, _id, _collateralRequired, true);     uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);     emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);     // assertEq(_borrowAbleAmount, _amountToBorrow);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, true);     }     uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);     uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         pooledCreditLineAddress,         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);     assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14); }  function test_adminCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, address(admin)); }  function test_lenderCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress); }  function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {     if (_actor == address(admin)) {         try admin.cancelRequest(_id) {             revert('Admin cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);         try _user.cancelRequest(_id) {             revert('Invalid actor cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotCancelRequest() public {     assert_borrowerCannotCancelRequest(requestId); }  function assert_borrowerCannotCancelRequest(uint256 _id) public {     try borrower.cancelRequest(_id) {         revert('Canceling a PCL in active stage should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow); }  function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay zero current debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP3');     } }  function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow); }  function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay if interest is zero');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP4');     } }  function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     try _lender.transferLPTokens(address(borrower), _id, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_borrowerCannotReceivePoolTokens() public {     assert_borrowerCannotReceivePoolTokens(requestId);     request.borrowerVerifier = mockAdminVerifier1;     borrower.registerSelf(mockAdminVerifier1);     (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);     assert_borrowerCannotReceivePoolTokens(_id); }  function assert_canTransferPoolTokensToVerifiedUser(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     // borrowing some tokens     {         uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());         uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;         uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);         admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);         borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);         _helperDepositCollateral(borrower, _id, _collateralRequired, false);         borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);          // going ahead in time to generate interest         vm.warp(block.timestamp + 6 days);         // repaying the interest and some principal back         borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);         borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);     }      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender     _lender.withdrawInterest(_id);      uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     // calculating the receivers interest in shares     uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);     uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         receiverInterestInTokens,         address(borrowAsset)     );      uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);     _lender.transferLPTokens(_recevingAddress, _id, _amount);      uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);     assertEq(_finalBalance - _prevBalance, _amount);      uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;     curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;     assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14); }  function assert_cannotTransferEcxessPoolTokens(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _id, _amount) {         revert('balance less than the amount to transfer');     } catch Error(string memory reason) {         // assertEq(reason, 'ERC1155: insufficient balance for transfer');         assertEq(reason, 'SafeMath: subtraction overflow');     } }  function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     // testing when user is not verified     try _lender.transferLPTokens(_newUserAddress, _id, _balance) {         revert('should not have been possible to send LP tokens to not verified user');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT3');     } }  function test_lenderTransfersTokenToAnotherLender() public {     LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     address _recevingAddress = lenders[1].lenderAddress;     assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);     assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance); }  function test_lenderTransferTokenToNewUser() public {     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));      // testing when user is verified     _newUser.registerSelf(mockAdminVerifier1);      LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);      assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3); }  function test_areTokensTransferable() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     LenderInfo memory _lenderInfo = lenders[0];      address _recevingAddress = lenders[1].lenderAddress;     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  function test_canTransferPoolTokensWhenZeroInterest() public {     PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);     assertGe(_startBalanceLenderFrom, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);      PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);     uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);     assertGe(_startBalanceLenderTo, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);      _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);     assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));     assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo)); }  function test_cannotWithdrawZeroInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);      // cannot withdraw zero interest     vm.expectRevert(bytes('LP:WI1'));     _lender.withdrawInterest(requestId); }  function test_newPoolTokenHolderCanWithdrawInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _newUser.registerSelf(mockAdminVerifier1);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     _lender.transferLPTokens(address(_newUser), requestId, _balance);     uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);     assertEq(_newUserBalance, _balance);     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repaying the interest and some principal back     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // fetch borrowerInterestSharesWithdrawn for new user     uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     assertEq(_prevBISW, 0);     // get the interest for the new user     uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));     uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser     _newUser.withdrawInterest(requestId);     uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;     // match the interest shares withdrawn with the interest calculated     assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14); }  function test_stateAfterBorrow() public {     admin.updateProtocolFeeFraction(0);      uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('borrowable amount', _borrowableAmount);     assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);      uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));     borrower.borrow(requestId, _borrowableAmount);     uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));      assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);     assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14); }  function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());     _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     emit log_named_uint('_collateralRequired: ', _collateralRequired);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     // borrow some amount     uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());     if (_curBorrowAmount == _amountToBorrow) {         _curBorrowAmount = _curBorrowAmount.mul(90).div(100);     }     borrower.borrow(requestId, _curBorrowAmount);     // check borrow able amount     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     if (request.collateralRatio != 0) {         assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);     } else {         assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);     }     // now check withdrawableCollateral     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);     assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14); }  function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction); }  function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {     _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);     assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount)); }  function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {     if (request.collateralRatio == 0) return;     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);     uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));     emit log_named_uint('_maxCollateral: ', _maxCollateral);     emit log_named_uint('_minCollateral: ', _minCollateral);     _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);     emit log_named_uint('_collateralAmount: ', _collateralAmount);     _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);     emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);     // calulating what should borrowed to achieve _collateralRatioToAchieve     uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(         _collateralRatioToAchieve     );     emit log_named_uint('_amountToBorrow: ', _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);      uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('_maxBorrowable: ', _maxBorrowable);     if (         request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14     ) {         assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);         if (_amountToBorrow &gt; _maxBorrowable) {             _amountToBorrow = _maxBorrowable;         }     } else {         assertLe(_amountToBorrow, _maxBorrowable);     }      borrower.borrow(requestId, _amountToBorrow);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);      uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);     // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve     assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14); }  function test_closeActivePCLOncePrincipalPaidAndEnded() public {     // borrowing some tokens     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repay everything back     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _balance = borrowAsset.balanceOf(address(borrower));     if (_currentDebt &gt; _balance) {         admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));     }     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);     // go to end of pcl     vm.warp(block.timestamp + request.collectionPeriod + request.duration);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);     assertEq(0, borrowAsset.balanceOf(address(borrower))); }  event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);  function test_closeWhenNoCollateral() public {     vm.warp(block.timestamp + 6 days);     // close     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_closeWhenCollateral() public {     uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();     admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     vm.warp(block.timestamp + 6 days);     vm.roll(block.number + (6 * 86400) / 20);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));     vm.expectEmit(true, true, false, false);     emit CollateralSharesWithdrawn(requestId, _shares);     // close     borrower.close(requestId);     // this is equal only when no yield is used     // with compund this should be assertLe becuase deposited collateral would earn yield     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } else {         assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } }  event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare); event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);  function test_withdrawLiquidatedCollateral() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable.sub(10));     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable.sub(10),         address(borrowAsset)     );     // going ahead in time to make liquidation possible     vm.warp(block.timestamp + 50 days);     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);      uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;      vm.expectEmit(true, true, false, false);     emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } else {         assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } }  event PooledCreditLineTerminated(uint256 indexed id);  function test_terminateAfterLiquidation() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable);     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable,         address(borrowAsset)     );      // going ahead in time to make liquidation possible     vm.warp(block.timestamp + request.duration.mul(7).div(11));     vm.roll(block.number + request.duration.mul(7).div(11).div(20));     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;     vm.expectEmit(true, true, false, false);      emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);      uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));      uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));     emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);     // for an active pcl borrowLimit == total amount lent     _totalSupply = lp.totalSupply(requestId);     // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);     // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);     // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);      // now the admin terminates     vm.expectEmit(true, true, false, true);     emit PooledCreditLineTerminated(requestId);     admin.terminate(requestId);      assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));      if (request.borrowAssetStrategy == compoundYieldAddress) {         // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } else {         // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } }  function _helperDepositCollateral(     PCLUser _user,     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) private {     if (_amount != 0) {         _user.depositCollateral(_id, _amount, _fromSavingsAccount);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLActiveStage is PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n\n    uint256 requestId;\n\n    // enum PooledCreditLineStatus {\n    //     NOT_CREATED,\n    //     REQUESTED,\n    //     ACTIVE,\n    //     CLOSED,\n    //     EXPIRED,\n    //     LIQUIDATED,\n    //     CANCELLED\n    // }\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function test_cannotStartActivePCL() public {\n        try borrower.start(requestId) {\n            revert('cannot start active pcl');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:S1');\n        }\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert('External user cannot create');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert('External user cannot terminate');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert('Lender cannot lend zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L1');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        // verified using the borrower verifier instead of lender verifier\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Unverified lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L2');\n        }\n    }\n\n    function test_nonLenderCannotWithdrawLiquidity() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        try _pooledCreditLineLender.withdrawLiquidity(requestId) {\n            revert('Lender cannot withdraw liquidity');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL1');\n        }\n    }\n\n    function test_lenderCannotWithdrawLiquidity() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.withdrawLiquidity(requestId) {\n            revert('Lender cannot withdraw liquidity');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n    }\n\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert('Non lender cannot withdraw liquidated collateral tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:WLC1');\n        }\n    }\n\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert('Lender cannot withdraw liquidated collateral tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    function test_cannotTransferLPTokensToSameAddress() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert('Lender cannot transfer LP tokens to itself');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT1');\n        }\n    }\n\n    function test_cannotBurnPoolTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert('Lender cannot burn LP tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'ERC1155: transfer to the zero address');\n        }\n    }\n\n    function test_cannotLendToActivePCL() public {\n        LenderInfo memory info = lenders[0];\n        PCLUser lender = PCLUser(info.lenderAddress);\n        try lender.lend(requestId, 100_000) {\n            revert('cannot lend to active pcl');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    function test_cannotLendToActivePCLNewLender() public {\n        // Creating a new lender for lending\n        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        lender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(request.borrowAsset, address(lender), 100_000);\n        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);\n        try lender.lend(requestId, 100_000) {\n            revert('cannot lend to active pcl');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    function test_lenderCannotBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);\n    }\n\n    function test_adminCannotBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));\n    }\n\n    function test_onlyBorrowerCanBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));\n    }\n\n    function assert_borrowByInvalidActor(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        PCLUser _user = PCLUser(_actor);\n        if (_actor == address(admin)) {\n            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n            _helperDepositCollateral(admin, _id, _collateralRequired, false);\n\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n            try admin.borrow(_id, _amountToBorrow) {\n                revert('Invalid user should not be able to borrow');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        } else {\n            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);\n            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n            _helperDepositCollateral(_user, _id, _collateralRequired, false);\n\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n            try _user.borrow(_id, _amountToBorrow) {\n                revert('Invalid user should not be able to borrow');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        }\n    }\n\n    function test_borrowerCannotBorrowMoreThanPossible() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);\n\n        try borrower.borrow(_id, _amountBorrowable + 1) {\n            revert('Borrower should not be able to borrow more than possible');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:IB3');\n        }\n    }\n\n    function test_borrowerCannotBorrowZeroAmount() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        try borrower.borrow(_id, 0) {\n            revert('Borrower should not be able to borrow zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:IB1');\n        }\n    }\n\n    function test_lenderDepositsAndCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);\n    }\n\n    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);\n    }\n\n    function test_adminDepositsAndCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));\n    }\n\n    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));\n    }\n\n    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _depositor,\n        address _withdrawer\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        // Depositing into PCL\n        if (_depositor == address(admin)) {\n            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n            _helperDepositCollateral(admin, _id, _collateralRequired, false);\n\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n        } else {\n            PCLUser _user = PCLUser(_depositor);\n\n            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);\n            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n            _helperDepositCollateral(_user, _id, _collateralRequired, false);\n\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n        }\n\n        // withdrawing from PCL\n        if (_withdrawer == address(admin)) {\n            try admin.withdrawCollateral(_id, _collateralRequired, false) {\n                revert('Admin should not be able to withdraw collateral');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        } else {\n            PCLUser _user = PCLUser(_withdrawer);\n\n            try _user.withdrawCollateral(_id, _collateralRequired, false) {\n                revert('Invalid actor should not be able to withdraw collateral');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        }\n    }\n\n    function test_borrowerCanWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);\n        if (request.collateralRatio != 0) {\n            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);\n        }\n        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);\n    }\n\n    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);\n        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(_lender, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        try _lender.withdrawAllCollateral(_id, false) {\n            revert('lender should not be able to withdraw all collateral');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:OCLB1');\n        }\n    }\n\n    function test_adminDepositsAndCannotWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(admin, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        try admin.withdrawAllCollateral(_id, false) {\n            revert('admin should not be able to withdraw all collateral');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:OCLB1');\n        }\n    }\n\n    function test_borrowerCannotWithdrawZeroAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        try borrower.withdrawAllCollateral(_id, false) {\n            revert('borrower should not be able to withdraw zero all collateral');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WAC1');\n        }\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        try borrower.withdrawCollateral(_id, 0, false) {\n            revert('Withdrawing zero collateral should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC2');\n        }\n    }\n\n    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);\n\n        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {\n            revert('Withdrawing more collateral than withdrawable should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC1');\n        }\n    }\n\n    function test_borrowerCanWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        if (request.collateralRatio != 0) {\n            borrower.withdrawAllCollateral(_id, false);\n        }\n        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);\n    }\n\n    function test_cannotCloseIfDebtIsNonZero() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);\n    }\n\n    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));\n        borrower.borrow(_id, 90_000 * (10ERC20(address(borrowAsset)).decimals()));\n        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));\n\n        try borrower.close(_id) {\n            revert('Borrower should not be able to close with non-zero debt');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C2');\n        }\n    }\n\n    function test_lenderCannotClose() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);\n    }\n\n    function test_adminCannotClose() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));\n    }\n\n    function assert_invalidActorCannotClose(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        borrower.borrow(_id, request.minBorrowAmount);\n\n        if (_actor == address(admin)) {\n            try admin.close(_id) {\n                revert('Admin should not be able to close PCL');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n\n            try _user.close(_id) {\n                revert('Invalid actor should not be able to close PCL');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        }\n    }\n\n    function test_borrowerCanRepayAndClose() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n\n        vm.warp(block.timestamp + (request.duration / 2));\n\n        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(_id, _currentDebt);\n\n        _currentDebt = pcl.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0);\n\n        borrower.close(_id);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_repayWithInsufficientBalance() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n\n        vm.warp(block.timestamp + (request.duration / 2));\n\n        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));\n        try borrower.repay(_id, _currentDebt) {\n            revert('REVERT: Insufficient Balance');\n        } catch Error(string memory reason) {\n            if (!isForked) {\n                assertEq(reason, 'ERC20: transfer amount exceeds allowance');\n            } else {\n                assertEq(reason, 'Dai/insufficient-allowance');\n            }\n        }\n    }\n\n    function test_borrowerCannotLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));\n    }\n\n    function test_adminCannotLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        emit log_named_uint('request.borrowLimit', request.borrowLimit);\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));\n    }\n\n    function assert_InvalidActorCannotLiquidate(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);\n        borrower.borrow(_id, _borrowable);\n\n        vm.warp(block.timestamp + (request.duration / 2));\n\n        if (!isForked) {\n            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);\n        }\n\n        if (_actor == address(admin)) {\n            try admin.liquidate(_id, true) {\n                revert('admin liquidating should revert');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'LP:LIQ1');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n\n            try _user.liquidate(_id, true) {\n                revert('Invalid actor liquidating should revert');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'LP:LIQ1');\n            }\n        }\n    }\n\n    function test_onlyLendersCanLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit / 3;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);\n    }\n\n    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {\n        if (request.collateralRatio == 0) return;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);\n        borrower.borrow(_id, _borrowable);\n\n        vm.warp(block.timestamp + (request.duration / 2));\n\n        if (!isForked) {\n            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);\n        }\n\n        PCLUser _lender = PCLUser(lenders[1].lenderAddress);\n        uint256 _amountLent = lenders[1].amount;\n        _lender.liquidate(_id, true);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_lenderCannotLiquidateZeroPrincipal() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);\n    }\n\n    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        vm.warp(block.timestamp + (request.duration / 2));\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.liquidate(_id, true) {\n            revert('Lender liquidating should revert with zero principal');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L1');\n        }\n    }\n\n    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);\n    }\n\n    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, _amountToBorrow / 2);\n\n        vm.warp(block.timestamp + (request.duration / 2));\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.liquidate(_id, true) {\n            revert('Lender liquidating should revert with if collateral ratio is more than ideal');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    function test_borrowerCannotTerminate() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotTerminate(_id);\n    }\n\n    function assert_borrowerCannotTerminate(uint256 _id) public {\n        try borrower.terminate(_id) {\n            revert('Borrower terminating PCL should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'Ownable: caller is not the owner');\n        }\n    }\n\n    function test_lenderCannotTerminate() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotTerminate(_id);\n    }\n\n    function assert_lenderCannotTerminate(uint256 _id) public {\n        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));\n        try _lender.terminate(_id) {\n            revert('Lender terminating PCL should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'Ownable: caller is not the owner');\n        }\n    }\n\n    function test_onlyAdminCanTerminate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_onlyAdminCanTerminate(_id, _amountToBorrow);\n    }\n\n    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n\n        vm.warp(block.timestamp + (request.duration / 2));\n        vm.roll(block.number + (request.duration / (2 * 20)));\n\n        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));\n        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));\n        admin.terminate(_id);\n        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));\n        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);\n        } else {\n            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);\n        }\n        if (request.borrowAssetStrategy == compoundYieldAddress) {\n            assertGe(\n                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,\n                (request.borrowLimit / 2) - 90_000 * 10(ERC20(address(borrowAsset)).decimals())\n            );\n        } else {\n            assertEq(\n                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,\n                (request.borrowLimit / 2) - 90_000 * 10(ERC20(address(borrowAsset)).decimals())\n            );\n        }\n    }\n\n    function test_depositCollateral() public {\n        uint256 _amount = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_depositCollateral(_id, _amount);\n    }\n\n    function assert_depositCollateral(uint256 _id, uint256 _amount) public {\n        // lender.lend(_id, _amount);\n        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());\n        admin.transferToken(address(collateralAsset), address(borrower), _amount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);\n        borrower.depositCollateral(_id, _amount, false);\n        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));\n        assertEq(pcl.depositedCollateralInShares(_id), _shares);\n    }\n\n    function test_depositCollateral_insufficientBalance() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n\n        admin.transferToken(address(collateralAsset), address(borrower), 10);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);\n        try borrower.depositCollateral(_id, 100, false) {\n            revert('Insufficient Balance of collateral tokens');\n        } catch Error(string memory reason) {\n            if (!isForked) {\n                assertEq(reason, 'ERC20: transfer amount exceeds balance');\n            } else {\n                assertEq(reason, 'SafeERC20: low-level call failed');\n            }\n        }\n    }\n\n    function test_depositZeroCollateral() public {\n        uint256 _amount = 0;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_depositZeroCollateral(_id, _amount);\n    }\n\n    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {\n        // lender.lend(_id, _amount);\n        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10ERC20(address(collateralAsset)).decimals()));\n        borrower.setAllowance(\n            pooledCreditLineAddress,\n            address(collateralAsset),\n            100_000 * (10ERC20(address(collateralAsset)).decimals())\n        );\n        try borrower.depositCollateral(_id, _amount, false) {\n            revert('Depositing zero collateral should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:DC1');\n        }\n    }\n\n    function test_depositCollateralFromSavingsAccount() public {\n        request.collateralAssetStrategy = compoundYieldAddress;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));\n        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);\n        if (request.collateralRatio != 0) {\n            borrower.depositToSavingsAccount(\n                savingsAccountAddress,\n                _collateralRequired,\n                address(collateralAsset),\n                compoundYieldAddress,\n                address(borrower)\n            );\n        }\n        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));\n        emit log_named_uint('total tokens: ', _totalTokens);\n        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            address(borrower),\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);\n        emit log_named_uint('required collateral: ', _collateralRequired);\n        borrower.setAllowanceForSavingsAccount(\n            savingsAccountAddress,\n            _collateralRequired,\n            address(collateralAsset),\n            pooledCreditLineAddress\n        );\n        _helperDepositCollateral(borrower, _id, _collateralRequired, true);\n        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);\n        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);\n        // assertEq(_borrowAbleAmount, _amountToBorrow);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);\n        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.withdrawAllCollateral(_id, true);\n        }\n        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            address(borrower),\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);\n        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            pooledCreditLineAddress,\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);\n        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);\n    }\n\n    function test_adminCannotCancelRequest() public {\n        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));\n    }\n\n    function test_lenderCannotCancelRequest() public {\n        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);\n    }\n\n    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {\n        if (_actor == address(admin)) {\n            try admin.cancelRequest(_id) {\n                revert('Admin cannot cancel PCL');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n            try _user.cancelRequest(_id) {\n                revert('Invalid actor cannot cancel PCL');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        }\n    }\n\n    function test_borrowerCannotCancelRequest() public {\n        assert_borrowerCannotCancelRequest(requestId);\n    }\n\n    function assert_borrowerCannotCancelRequest(uint256 _id) public {\n        try borrower.cancelRequest(_id) {\n            revert('Canceling a PCL in active stage should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {\n        _seed = scaleToRange128(_seed, 1, 10);\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);\n        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        try borrower.repay(_id, 1) {\n            revert('Borrower should not be able to repay zero current debt');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:REP3');\n        }\n    }\n\n    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {\n        _seed = scaleToRange128(_seed, 1, 10);\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);\n        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        uint256 _borrowAssetDecimalScaling = 10(ERC20(address(borrowAsset)).decimals());\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);\n\n        try borrower.repay(_id, 1) {\n            revert('Borrower should not be able to repay if interest is zero');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:REP4');\n        }\n    }\n\n    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);\n        log_named_uint('lender lp balance: ', _balance);\n        try _lender.transferLPTokens(address(borrower), _id, _balance) {\n            revert('should not have been possible to send LP tokens to the borrower');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT2');\n        }\n    }\n\n    function test_borrowerCannotReceivePoolTokens() public {\n        assert_borrowerCannotReceivePoolTokens(requestId);\n        request.borrowerVerifier = mockAdminVerifier1;\n        borrower.registerSelf(mockAdminVerifier1);\n        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);\n        assert_borrowerCannotReceivePoolTokens(_id);\n    }\n\n    function assert_canTransferPoolTokensToVerifiedUser(\n        uint256 _id,\n        address _recevingAddress,\n        uint256 _amount\n    ) public {\n        // borrowing some tokens\n        {\n            uint256 _borrowAssetDecimalScaling = 10(ERC20(address(borrowAsset)).decimals());\n            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;\n            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n            _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);\n\n            // going ahead in time to generate interest\n            vm.warp(block.timestamp + 6 days);\n            // repaying the interest and some principal back\n            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);\n            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);\n        }\n\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender\n        _lender.withdrawInterest(_id);\n\n        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;\n        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;\n        // calculating the receivers interest in shares\n        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);\n        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            receiverInterestInTokens,\n            address(borrowAsset)\n        );\n\n        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);\n        _lender.transferLPTokens(_recevingAddress, _id, _amount);\n\n        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);\n        assertEq(_finalBalance - _prevBalance, _amount);\n\n        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;\n        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;\n        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;\n        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;\n        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);\n    }\n\n    function assert_cannotTransferEcxessPoolTokens(\n        uint256 _id,\n        address _recevingAddress,\n        uint256 _amount\n    ) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {\n            revert('balance less than the amount to transfer');\n        } catch Error(string memory reason) {\n            // assertEq(reason, 'ERC1155: insufficient balance for transfer');\n            assertEq(reason, 'SafeMath: subtraction overflow');\n        }\n    }\n\n    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);\n        log_named_uint('lender lp balance: ', _balance);\n        // testing when user is not verified\n        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {\n            revert('should not have been possible to send LP tokens to not verified user');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT3');\n        }\n    }\n\n    function test_lenderTransfersTokenToAnotherLender() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n        address _recevingAddress = lenders[1].lenderAddress;\n        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);\n        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);\n    }\n\n    function test_lenderTransferTokenToNewUser() public {\n        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));\n\n        // testing when user is verified\n        _newUser.registerSelf(mockAdminVerifier1);\n\n        LenderInfo memory _lenderInfo = lenders[0];\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n\n        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);\n    }\n\n    function test_areTokensTransferable() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        LenderInfo memory _lenderInfo = lenders[0];\n\n        address _recevingAddress = lenders[1].lenderAddress;\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {\n            revert('should not have been possible to send LP tokens to the borrower');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT5');\n        }\n    }\n\n    function test_canTransferPoolTokensWhenZeroInterest() public {\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);\n        assertGe(_startBalanceLenderFrom, 0);\n        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);\n\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);\n        assertGe(_startBalanceLenderTo, 0);\n        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);\n\n        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);\n        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));\n        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));\n    }\n\n    function test_cannotWithdrawZeroInterest() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n\n        // cannot withdraw zero interest\n        vm.expectRevert(bytes('LP:WI1'));\n        _lender.withdrawInterest(requestId);\n    }\n\n    function test_newPoolTokenHolderCanWithdrawInterest() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _newUser.registerSelf(mockAdminVerifier1);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n        _lender.transferLPTokens(address(_newUser), requestId, _balance);\n        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);\n        assertEq(_newUserBalance, _balance);\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        borrower.borrow(requestId, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // going ahead in time to generate interest\n        vm.warp(block.timestamp + 6 days);\n        // repaying the interest and some principal back\n        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        borrower.repay(requestId, 10_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // fetch borrowerInterestSharesWithdrawn for new user\n        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;\n        assertEq(_prevBISW, 0);\n        // get the interest for the new user\n        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));\n        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));\n        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser\n        _newUser.withdrawInterest(requestId);\n        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;\n        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;\n        // match the interest shares withdrawn with the interest calculated\n        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);\n    }\n\n    function test_stateAfterBorrow() public {\n        admin.updateProtocolFeeFraction(0);\n\n        uint256 _amountToBorrow = request.borrowLimit;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        emit log_named_uint('borrowable amount', _borrowableAmount);\n        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);\n\n        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));\n        borrower.borrow(requestId, _borrowableAmount);\n        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));\n\n        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);\n        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);\n    }\n\n    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {\n        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());\n        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        emit log_named_uint('_collateralRequired: ', _collateralRequired);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        // borrow some amount\n        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());\n        if (_curBorrowAmount == _amountToBorrow) {\n            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);\n        }\n        borrower.borrow(requestId, _curBorrowAmount);\n        // check borrow able amount\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        if (request.collateralRatio != 0) {\n            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);\n        } else {\n            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);\n        }\n        // now check withdrawableCollateral\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);\n        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);\n    }\n\n    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {\n        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);\n    }\n\n    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {\n        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10_decimals).div(_ratioOfPrices);\n        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));\n    }\n\n    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {\n        if (request.collateralRatio == 0) return;\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);\n        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10ERC20(address(borrowAsset)).decimals()));\n        emit log_named_uint('_maxCollateral: ', _maxCollateral);\n        emit log_named_uint('_minCollateral: ', _minCollateral);\n        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);\n        emit log_named_uint('_collateralAmount: ', _collateralAmount);\n        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);\n        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);\n        // calulating what should borrowed to achieve _collateralRatioToAchieve\n        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10_decimals).mul(pcl.SCALING_FACTOR()).div(\n            _collateralRatioToAchieve\n        );\n        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);\n        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);\n        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);\n\n        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);\n        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);\n        if (\n            request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14\n        ) {\n            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);\n            if (_amountToBorrow &gt; _maxBorrowable) {\n                _amountToBorrow = _maxBorrowable;\n            }\n        } else {\n            assertLe(_amountToBorrow, _maxBorrowable);\n        }\n\n        borrower.borrow(requestId, _amountToBorrow);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);\n\n        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);\n        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve\n        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);\n    }\n\n    function test_closeActivePCLOncePrincipalPaidAndEnded() public {\n        // borrowing some tokens\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        borrower.borrow(requestId, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // going ahead in time to generate interest\n        vm.warp(block.timestamp + 6 days);\n        // repay everything back\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        uint256 _balance = borrowAsset.balanceOf(address(borrower));\n        if (_currentDebt &gt; _balance) {\n            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));\n        }\n        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n        // go to end of pcl\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n        assertEq(0, borrowAsset.balanceOf(address(borrower)));\n    }\n\n    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);\n\n    function test_closeWhenNoCollateral() public {\n        vm.warp(block.timestamp + 6 days);\n        // close\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_closeWhenCollateral() public {\n        uint256 _collateralAmount = 1e2 * 10ERC20(address(collateralAsset)).decimals();\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);\n        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);\n        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));\n        vm.warp(block.timestamp + 6 days);\n        vm.roll(block.number + (6 * 86400) / 20);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));\n        vm.expectEmit(true, true, false, false);\n        emit CollateralSharesWithdrawn(requestId, _shares);\n        // close\n        borrower.close(requestId);\n        // this is equal only when no yield is used\n        // with compund this should be assertLe becuase deposited collateral would earn yield\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));\n        } else {\n            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));\n        }\n    }\n\n    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);\n    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);\n\n    function test_withdrawLiquidatedCollateral() public {\n        if (request.collateralRatio == 0) return;\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);\n        borrower.borrow(requestId, _borrowable.sub(10));\n        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            request.borrowLimit - _borrowable.sub(10),\n            address(borrowAsset)\n        );\n        // going ahead in time to make liquidation possible\n        vm.warp(block.timestamp + 50 days);\n        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);\n        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));\n\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _totalSupply = lp.totalSupply(requestId);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n\n        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            _principalBorowable,\n            address(borrowAsset)\n        );\n        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +\n            _lenderYieldShares;\n\n        vm.expectEmit(true, true, false, false);\n        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);\n        _lender.liquidate(requestId, true);\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));\n        } else {\n            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));\n        }\n    }\n\n    event PooledCreditLineTerminated(uint256 indexed id);\n\n    function test_terminateAfterLiquidation() public {\n        if (request.collateralRatio == 0) return;\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);\n        borrower.borrow(requestId, _borrowable);\n        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            request.borrowLimit - _borrowable,\n            address(borrowAsset)\n        );\n\n        // going ahead in time to make liquidation possible\n        vm.warp(block.timestamp + request.duration.mul(7).div(11));\n        vm.roll(block.number + request.duration.mul(7).div(11).div(20));\n        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);\n        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));\n\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _totalSupply = lp.totalSupply(requestId);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            _principalBorowable,\n            address(borrowAsset)\n        );\n        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +\n            _lenderYieldShares;\n        vm.expectEmit(true, true, false, false);\n\n        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);\n        _lender.liquidate(requestId, true);\n\n        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));\n\n        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));\n        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);\n        // for an active pcl borrowLimit == total amount lent\n        _totalSupply = lp.totalSupply(requestId);\n        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);\n        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);\n        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);\n\n        // now the admin terminates\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineTerminated(requestId);\n        admin.terminate(requestId);\n\n        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));\n\n        if (request.borrowAssetStrategy == compoundYieldAddress) {\n            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));\n        } else {\n            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));\n        }\n    }\n\n    function _helperDepositCollateral(\n        PCLUser _user,\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) private {\n        if (_amount != 0) {\n            _user.depositCollateral(_id, _amount, _fromSavingsAccount);\n        }\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:26:24 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStage is PCLParent {     using SafeMath for uint256;     using SafeMath for uint128; uint256 requestId;  // enum PooledCreditLineStatus { //     NOT_CREATED, //     REQUESTED, //     ACTIVE, //     CLOSED, //     EXPIRED, //     LIQUIDATED, //     CANCELLED // }  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE); }  function test_cannotStartActivePCL() public {     try borrower.start(requestId) {         revert('cannot start active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     // verified using the borrower verifier instead of lender verifier     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_nonLenderCannotWithdrawLiquidity() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);     try _pooledCreditLineLender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL1');     } }  function test_lenderCannotWithdrawLiquidity() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotLendToActivePCL() public {     LenderInfo memory info = lenders[0];     PCLUser lender = PCLUser(info.lenderAddress);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendToActivePCLNewLender() public {     // Creating a new lender for lending     PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     lender.registerSelf(mockAdminVerifier1);     admin.transferToken(request.borrowAsset, address(lender), 100_000);     lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin)); }  function test_onlyBorrowerCanBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;     PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker)); }  function assert_borrowByInvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _user = PCLUser(_actor);     if (_actor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try admin.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try _user.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotBorrowMoreThanPossible() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);      try borrower.borrow(_id, _amountBorrowable + 1) {         revert('Borrower should not be able to borrow more than possible');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB3');     } }  function test_borrowerCannotBorrowZeroAmount() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.borrow(_id, 0) {         revert('Borrower should not be able to borrow zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB1');     } }  function test_lenderDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress); }  function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress); }  function test_adminDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin)); }  function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin)); }  function assert_DepositAndCannotWithdrawCollateral_InvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _depositor,     address _withdrawer ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      // Depositing into PCL     if (_depositor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     } else {         PCLUser _user = PCLUser(_depositor);          admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     }      // withdrawing from PCL     if (_withdrawer == address(admin)) {         try admin.withdrawCollateral(_id, _collateralRequired, false) {             revert('Admin should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_withdrawer);          try _user.withdrawCollateral(_id, _collateralRequired, false) {             revert('Invalid actor should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     if (request.collateralRatio != 0) {         borrower.withdrawCollateral(_id, _withdrawableCollateral, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_lenderDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);     _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(_lender, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try _lender.withdrawAllCollateral(_id, false) {         revert('lender should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_adminDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(admin, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try admin.withdrawAllCollateral(_id, false) {         revert('admin should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_borrowerCannotWithdrawZeroAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     try borrower.withdrawAllCollateral(_id, false) {         revert('borrower should not be able to withdraw zero all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  function test_borrowerCannotWithdrawZeroCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try borrower.withdrawCollateral(_id, 0, false) {         revert('Withdrawing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC2');     } }  function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);      try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {         revert('Withdrawing more collateral than withdrawable should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  function test_borrowerCanWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_cannotCloseIfDebtIsNonZero() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow); }  function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));     borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));     // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));      try borrower.close(_id) {         revert('Borrower should not be able to close with non-zero debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  function test_lenderCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin)); }  function assert_invalidActorCannotClose(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, request.minBorrowAmount);      if (_actor == address(admin)) {         try admin.close(_id) {             revert('Admin should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.close(_id) {             revert('Invalid actor should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanRepayAndClose() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanRepayAndClose(_id, _amountToBorrow); }  function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(_id, _currentDebt);      _currentDebt = pcl.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0);      borrower.close(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED); }  function test_repayWithInsufficientBalance() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));     try borrower.repay(_id, _currentDebt) {         revert('REVERT: Insufficient Balance');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds allowance');         } else {             assertEq(reason, 'Dai/insufficient-allowance');         }     } }  function test_borrowerCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower)); }  function test_adminCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;     emit log_named_uint('request.borrowLimit', request.borrowLimit);     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin)); }  function assert_InvalidActorCannotLiquidate(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      if (_actor == address(admin)) {         try admin.liquidate(_id, true) {             revert('admin liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.liquidate(_id, true) {             revert('Invalid actor liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } }  function test_onlyLendersCanLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit / 3;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyLendersCanLiquidate(_id, _amountToBorrow); }  function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {     if (request.collateralRatio == 0) return;     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      PCLUser _lender = PCLUser(lenders[1].lenderAddress);     uint256 _amountLent = lenders[1].amount;     _lender.liquidate(_id, true);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_lenderCannotLiquidateZeroPrincipal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with zero principal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, _amountToBorrow / 2);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with if collateral ratio is more than ideal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  function test_borrowerCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotTerminate(_id); }  function assert_borrowerCannotTerminate(uint256 _id) public {     try borrower.terminate(_id) {         revert('Borrower terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_lenderCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotTerminate(_id); }  function assert_lenderCannotTerminate(uint256 _id) public {     PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));     try _lender.terminate(_id) {         revert('Lender terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_onlyAdminCanTerminate() public {     uint256 _amountToBorrow = request.borrowLimit;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyAdminCanTerminate(_id, _amountToBorrow); }  function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));     vm.roll(block.number + (request.duration / (2 * 20)));      uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));     admin.terminate(_id);     uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     } else {         assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     }     if (request.borrowAssetStrategy == compoundYieldAddress) {         assertGe(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } else {         assertEq(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } }  function test_depositCollateral() public {     uint256 _amount = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositCollateral(_id, _amount); }  function assert_depositCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());     admin.transferToken(address(collateralAsset), address(borrower), _amount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);     borrower.depositCollateral(_id, _amount, false);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));     assertEq(pcl.depositedCollateralInShares(_id), _shares); }  function test_depositCollateral_insufficientBalance() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);      admin.transferToken(address(collateralAsset), address(borrower), 10);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);     try borrower.depositCollateral(_id, 100, false) {         revert('Insufficient Balance of collateral tokens');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds balance');         } else {             assertEq(reason, 'SafeERC20: low-level call failed');         }     } }  function test_depositZeroCollateral() public {     uint256 _amount = 0;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositZeroCollateral(_id, _amount); }  function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));     borrower.setAllowance(         pooledCreditLineAddress,         address(collateralAsset),         100_000 * (10**ERC20(address(collateralAsset)).decimals())     );     try borrower.depositCollateral(_id, _amount, false) {         revert('Depositing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC1');     } }  function test_depositCollateralFromSavingsAccount() public {     request.collateralAssetStrategy = compoundYieldAddress;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));     emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);     if (request.collateralRatio != 0) {         borrower.depositToSavingsAccount(             savingsAccountAddress,             _collateralRequired,             address(collateralAsset),             compoundYieldAddress,             address(borrower)         );     }     uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));     emit log_named_uint('total tokens: ', _totalTokens);     uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);     emit log_named_uint('required collateral: ', _collateralRequired);     borrower.setAllowanceForSavingsAccount(         savingsAccountAddress,         _collateralRequired,         address(collateralAsset),         pooledCreditLineAddress     );     _helperDepositCollateral(borrower, _id, _collateralRequired, true);     uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);     emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);     // assertEq(_borrowAbleAmount, _amountToBorrow);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, true);     }     uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);     uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         pooledCreditLineAddress,         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);     assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14); }  function test_adminCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, address(admin)); }  function test_lenderCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress); }  function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {     if (_actor == address(admin)) {         try admin.cancelRequest(_id) {             revert('Admin cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);         try _user.cancelRequest(_id) {             revert('Invalid actor cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotCancelRequest() public {     assert_borrowerCannotCancelRequest(requestId); }  function assert_borrowerCannotCancelRequest(uint256 _id) public {     try borrower.cancelRequest(_id) {         revert('Canceling a PCL in active stage should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow); }  function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay zero current debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP3');     } }  function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow); }  function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay if interest is zero');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP4');     } }  function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     try _lender.transferLPTokens(address(borrower), _id, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_borrowerCannotReceivePoolTokens() public {     assert_borrowerCannotReceivePoolTokens(requestId);     request.borrowerVerifier = mockAdminVerifier1;     borrower.registerSelf(mockAdminVerifier1);     (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);     assert_borrowerCannotReceivePoolTokens(_id); }  function assert_canTransferPoolTokensToVerifiedUser(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     // borrowing some tokens     {         uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());         uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;         uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);         admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);         borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);         _helperDepositCollateral(borrower, _id, _collateralRequired, false);         borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);          // going ahead in time to generate interest         vm.warp(block.timestamp + 6 days);         // repaying the interest and some principal back         borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);         borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);     }      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender     _lender.withdrawInterest(_id);      uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     // calculating the receivers interest in shares     uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);     uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         receiverInterestInTokens,         address(borrowAsset)     );      uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);     _lender.transferLPTokens(_recevingAddress, _id, _amount);      uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);     assertEq(_finalBalance - _prevBalance, _amount);      uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;     curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;     assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14); }  function assert_cannotTransferEcxessPoolTokens(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _id, _amount) {         revert('balance less than the amount to transfer');     } catch Error(string memory reason) {         // assertEq(reason, 'ERC1155: insufficient balance for transfer');         assertEq(reason, 'SafeMath: subtraction overflow');     } }  function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     // testing when user is not verified     try _lender.transferLPTokens(_newUserAddress, _id, _balance) {         revert('should not have been possible to send LP tokens to not verified user');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT3');     } }  function test_lenderTransfersTokenToAnotherLender() public {     LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     address _recevingAddress = lenders[1].lenderAddress;     assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);     assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance); }  function test_lenderTransferTokenToNewUser() public {     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));      // testing when user is verified     _newUser.registerSelf(mockAdminVerifier1);      LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);      assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3); }  function test_areTokensTransferable() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     LenderInfo memory _lenderInfo = lenders[0];      address _recevingAddress = lenders[1].lenderAddress;     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  function test_canTransferPoolTokensWhenZeroInterest() public {     PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);     assertGe(_startBalanceLenderFrom, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);      PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);     uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);     assertGe(_startBalanceLenderTo, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);      _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);     assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));     assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo)); }  function test_cannotWithdrawZeroInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);      // cannot withdraw zero interest     vm.expectRevert(bytes('LP:WI1'));     _lender.withdrawInterest(requestId); }  function test_newPoolTokenHolderCanWithdrawInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _newUser.registerSelf(mockAdminVerifier1);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     _lender.transferLPTokens(address(_newUser), requestId, _balance);     uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);     assertEq(_newUserBalance, _balance);     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repaying the interest and some principal back     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // fetch borrowerInterestSharesWithdrawn for new user     uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     assertEq(_prevBISW, 0);     // get the interest for the new user     uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));     uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser     _newUser.withdrawInterest(requestId);     uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;     // match the interest shares withdrawn with the interest calculated     assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14); }  function test_stateAfterBorrow() public {     admin.updateProtocolFeeFraction(0);      uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('borrowable amount', _borrowableAmount);     assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);      uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));     borrower.borrow(requestId, _borrowableAmount);     uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));      assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);     assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14); }  function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());     _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     emit log_named_uint('_collateralRequired: ', _collateralRequired);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     // borrow some amount     uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());     if (_curBorrowAmount == _amountToBorrow) {         _curBorrowAmount = _curBorrowAmount.mul(90).div(100);     }     borrower.borrow(requestId, _curBorrowAmount);     // check borrow able amount     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     if (request.collateralRatio != 0) {         assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);     } else {         assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);     }     // now check withdrawableCollateral     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);     assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14); }  function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction); }  function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {     _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);     assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount)); }  function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {     if (request.collateralRatio == 0) return;     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);     uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));     emit log_named_uint('_maxCollateral: ', _maxCollateral);     emit log_named_uint('_minCollateral: ', _minCollateral);     _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);     emit log_named_uint('_collateralAmount: ', _collateralAmount);     _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);     emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);     // calulating what should borrowed to achieve _collateralRatioToAchieve     uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(         _collateralRatioToAchieve     );     emit log_named_uint('_amountToBorrow: ', _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);      uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('_maxBorrowable: ', _maxBorrowable);     if (         request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14     ) {         assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);         if (_amountToBorrow &gt; _maxBorrowable) {             _amountToBorrow = _maxBorrowable;         }     } else {         assertLe(_amountToBorrow, _maxBorrowable);     }      borrower.borrow(requestId, _amountToBorrow);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);      uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);     // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve     assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14); }  function test_closeActivePCLOncePrincipalPaidAndEnded() public {     // borrowing some tokens     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repay everything back     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _balance = borrowAsset.balanceOf(address(borrower));     if (_currentDebt &gt; _balance) {         admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));     }     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);     // go to end of pcl     vm.warp(block.timestamp + request.collectionPeriod + request.duration);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);     assertEq(0, borrowAsset.balanceOf(address(borrower))); }  event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);  function test_closeWhenNoCollateral() public {     vm.warp(block.timestamp + 6 days);     // close     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_closeWhenCollateral() public {     uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();     admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     vm.warp(block.timestamp + 6 days);     vm.roll(block.number + (6 * 86400) / 20);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));     vm.expectEmit(true, true, false, false);     emit CollateralSharesWithdrawn(requestId, _shares);     // close     borrower.close(requestId);     // this is equal only when no yield is used     // with compund this should be assertLe becuase deposited collateral would earn yield     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } else {         assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } }  event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare); event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);  function test_withdrawLiquidatedCollateral() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable.sub(10));     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable.sub(10),         address(borrowAsset)     );     // going ahead in time to make liquidation possible     vm.warp(block.timestamp + 50 days);     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);      uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;      vm.expectEmit(true, true, false, false);     emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } else {         assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } }  event PooledCreditLineTerminated(uint256 indexed id);  function test_terminateAfterLiquidation() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable);     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable,         address(borrowAsset)     );      // going ahead in time to make liquidation possible     vm.warp(block.timestamp + request.duration.mul(7).div(11));     vm.roll(block.number + request.duration.mul(7).div(11).div(20));     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;     vm.expectEmit(true, true, false, false);      emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);      uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));      uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));     emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);     // for an active pcl borrowLimit == total amount lent     _totalSupply = lp.totalSupply(requestId);     // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);     // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);     // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);      // now the admin terminates     vm.expectEmit(true, true, false, true);     emit PooledCreditLineTerminated(requestId);     admin.terminate(requestId);      assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));      if (request.borrowAssetStrategy == compoundYieldAddress) {         // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } else {         // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } }  function _helperDepositCollateral(     PCLUser _user,     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) private {     if (_amount != 0) {         _user.depositCollateral(_id, _amount, _fromSavingsAccount);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:26:24 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:26:28 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:26:28 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 34867
completion_tokens: 1
total_tokens: 34868
cost: $-1.000000


[2024-27-08 09:26:28 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
.]

###

[2024-27-08 09:26:28 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:26:28 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-27-08 09:26:28 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStage is PCLParent {     using SafeMath for uint256;     using SafeMath for uint128; uint256 requestId;  // enum PooledCreditLineStatus { //     NOT_CREATED, //     REQUESTED, //     ACTIVE, //     CLOSED, //     EXPIRED, //     LIQUIDATED, //     CANCELLED // }  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE); }  function test_cannotStartActivePCL() public {     try borrower.start(requestId) {         revert('cannot start active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     // verified using the borrower verifier instead of lender verifier     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_nonLenderCannotWithdrawLiquidity() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);     try _pooledCreditLineLender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL1');     } }  function test_lenderCannotWithdrawLiquidity() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotLendToActivePCL() public {     LenderInfo memory info = lenders[0];     PCLUser lender = PCLUser(info.lenderAddress);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendToActivePCLNewLender() public {     // Creating a new lender for lending     PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     lender.registerSelf(mockAdminVerifier1);     admin.transferToken(request.borrowAsset, address(lender), 100_000);     lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin)); }  function test_onlyBorrowerCanBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;     PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker)); }  function assert_borrowByInvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _user = PCLUser(_actor);     if (_actor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try admin.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try _user.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotBorrowMoreThanPossible() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);      try borrower.borrow(_id, _amountBorrowable + 1) {         revert('Borrower should not be able to borrow more than possible');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB3');     } }  function test_borrowerCannotBorrowZeroAmount() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.borrow(_id, 0) {         revert('Borrower should not be able to borrow zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB1');     } }  function test_lenderDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress); }  function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress); }  function test_adminDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin)); }  function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin)); }  function assert_DepositAndCannotWithdrawCollateral_InvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _depositor,     address _withdrawer ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      // Depositing into PCL     if (_depositor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     } else {         PCLUser _user = PCLUser(_depositor);          admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     }      // withdrawing from PCL     if (_withdrawer == address(admin)) {         try admin.withdrawCollateral(_id, _collateralRequired, false) {             revert('Admin should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_withdrawer);          try _user.withdrawCollateral(_id, _collateralRequired, false) {             revert('Invalid actor should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     if (request.collateralRatio != 0) {         borrower.withdrawCollateral(_id, _withdrawableCollateral, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_lenderDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);     _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(_lender, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try _lender.withdrawAllCollateral(_id, false) {         revert('lender should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_adminDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(admin, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try admin.withdrawAllCollateral(_id, false) {         revert('admin should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_borrowerCannotWithdrawZeroAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     try borrower.withdrawAllCollateral(_id, false) {         revert('borrower should not be able to withdraw zero all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  function test_borrowerCannotWithdrawZeroCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try borrower.withdrawCollateral(_id, 0, false) {         revert('Withdrawing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC2');     } }  function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);      try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {         revert('Withdrawing more collateral than withdrawable should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  function test_borrowerCanWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_cannotCloseIfDebtIsNonZero() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow); }  function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));     borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));     // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));      try borrower.close(_id) {         revert('Borrower should not be able to close with non-zero debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  function test_lenderCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin)); }  function assert_invalidActorCannotClose(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, request.minBorrowAmount);      if (_actor == address(admin)) {         try admin.close(_id) {             revert('Admin should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.close(_id) {             revert('Invalid actor should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanRepayAndClose() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanRepayAndClose(_id, _amountToBorrow); }  function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(_id, _currentDebt);      _currentDebt = pcl.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0);      borrower.close(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED); }  function test_repayWithInsufficientBalance() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));     try borrower.repay(_id, _currentDebt) {         revert('REVERT: Insufficient Balance');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds allowance');         } else {             assertEq(reason, 'Dai/insufficient-allowance');         }     } }  function test_borrowerCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower)); }  function test_adminCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;     emit log_named_uint('request.borrowLimit', request.borrowLimit);     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin)); }  function assert_InvalidActorCannotLiquidate(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      if (_actor == address(admin)) {         try admin.liquidate(_id, true) {             revert('admin liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.liquidate(_id, true) {             revert('Invalid actor liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } }  function test_onlyLendersCanLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit / 3;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyLendersCanLiquidate(_id, _amountToBorrow); }  function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {     if (request.collateralRatio == 0) return;     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      PCLUser _lender = PCLUser(lenders[1].lenderAddress);     uint256 _amountLent = lenders[1].amount;     _lender.liquidate(_id, true);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_lenderCannotLiquidateZeroPrincipal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with zero principal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, _amountToBorrow / 2);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with if collateral ratio is more than ideal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  function test_borrowerCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotTerminate(_id); }  function assert_borrowerCannotTerminate(uint256 _id) public {     try borrower.terminate(_id) {         revert('Borrower terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_lenderCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotTerminate(_id); }  function assert_lenderCannotTerminate(uint256 _id) public {     PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));     try _lender.terminate(_id) {         revert('Lender terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_onlyAdminCanTerminate() public {     uint256 _amountToBorrow = request.borrowLimit;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyAdminCanTerminate(_id, _amountToBorrow); }  function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));     vm.roll(block.number + (request.duration / (2 * 20)));      uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));     admin.terminate(_id);     uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     } else {         assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     }     if (request.borrowAssetStrategy == compoundYieldAddress) {         assertGe(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } else {         assertEq(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } }  function test_depositCollateral() public {     uint256 _amount = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositCollateral(_id, _amount); }  function assert_depositCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());     admin.transferToken(address(collateralAsset), address(borrower), _amount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);     borrower.depositCollateral(_id, _amount, false);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));     assertEq(pcl.depositedCollateralInShares(_id), _shares); }  function test_depositCollateral_insufficientBalance() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);      admin.transferToken(address(collateralAsset), address(borrower), 10);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);     try borrower.depositCollateral(_id, 100, false) {         revert('Insufficient Balance of collateral tokens');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds balance');         } else {             assertEq(reason, 'SafeERC20: low-level call failed');         }     } }  function test_depositZeroCollateral() public {     uint256 _amount = 0;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositZeroCollateral(_id, _amount); }  function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));     borrower.setAllowance(         pooledCreditLineAddress,         address(collateralAsset),         100_000 * (10**ERC20(address(collateralAsset)).decimals())     );     try borrower.depositCollateral(_id, _amount, false) {         revert('Depositing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC1');     } }  function test_depositCollateralFromSavingsAccount() public {     request.collateralAssetStrategy = compoundYieldAddress;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));     emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);     if (request.collateralRatio != 0) {         borrower.depositToSavingsAccount(             savingsAccountAddress,             _collateralRequired,             address(collateralAsset),             compoundYieldAddress,             address(borrower)         );     }     uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));     emit log_named_uint('total tokens: ', _totalTokens);     uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);     emit log_named_uint('required collateral: ', _collateralRequired);     borrower.setAllowanceForSavingsAccount(         savingsAccountAddress,         _collateralRequired,         address(collateralAsset),         pooledCreditLineAddress     );     _helperDepositCollateral(borrower, _id, _collateralRequired, true);     uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);     emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);     // assertEq(_borrowAbleAmount, _amountToBorrow);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, true);     }     uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);     uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         pooledCreditLineAddress,         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);     assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14); }  function test_adminCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, address(admin)); }  function test_lenderCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress); }  function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {     if (_actor == address(admin)) {         try admin.cancelRequest(_id) {             revert('Admin cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);         try _user.cancelRequest(_id) {             revert('Invalid actor cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotCancelRequest() public {     assert_borrowerCannotCancelRequest(requestId); }  function assert_borrowerCannotCancelRequest(uint256 _id) public {     try borrower.cancelRequest(_id) {         revert('Canceling a PCL in active stage should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow); }  function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay zero current debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP3');     } }  function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow); }  function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay if interest is zero');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP4');     } }  function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     try _lender.transferLPTokens(address(borrower), _id, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_borrowerCannotReceivePoolTokens() public {     assert_borrowerCannotReceivePoolTokens(requestId);     request.borrowerVerifier = mockAdminVerifier1;     borrower.registerSelf(mockAdminVerifier1);     (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);     assert_borrowerCannotReceivePoolTokens(_id); }  function assert_canTransferPoolTokensToVerifiedUser(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     // borrowing some tokens     {         uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());         uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;         uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);         admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);         borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);         _helperDepositCollateral(borrower, _id, _collateralRequired, false);         borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);          // going ahead in time to generate interest         vm.warp(block.timestamp + 6 days);         // repaying the interest and some principal back         borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);         borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);     }      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender     _lender.withdrawInterest(_id);      uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     // calculating the receivers interest in shares     uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);     uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         receiverInterestInTokens,         address(borrowAsset)     );      uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);     _lender.transferLPTokens(_recevingAddress, _id, _amount);      uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);     assertEq(_finalBalance - _prevBalance, _amount);      uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;     curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;     assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14); }  function assert_cannotTransferEcxessPoolTokens(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _id, _amount) {         revert('balance less than the amount to transfer');     } catch Error(string memory reason) {         // assertEq(reason, 'ERC1155: insufficient balance for transfer');         assertEq(reason, 'SafeMath: subtraction overflow');     } }  function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     // testing when user is not verified     try _lender.transferLPTokens(_newUserAddress, _id, _balance) {         revert('should not have been possible to send LP tokens to not verified user');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT3');     } }  function test_lenderTransfersTokenToAnotherLender() public {     LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     address _recevingAddress = lenders[1].lenderAddress;     assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);     assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance); }  function test_lenderTransferTokenToNewUser() public {     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));      // testing when user is verified     _newUser.registerSelf(mockAdminVerifier1);      LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);      assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3); }  function test_areTokensTransferable() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     LenderInfo memory _lenderInfo = lenders[0];      address _recevingAddress = lenders[1].lenderAddress;     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  function test_canTransferPoolTokensWhenZeroInterest() public {     PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);     assertGe(_startBalanceLenderFrom, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);      PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);     uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);     assertGe(_startBalanceLenderTo, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);      _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);     assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));     assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo)); }  function test_cannotWithdrawZeroInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);      // cannot withdraw zero interest     vm.expectRevert(bytes('LP:WI1'));     _lender.withdrawInterest(requestId); }  function test_newPoolTokenHolderCanWithdrawInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _newUser.registerSelf(mockAdminVerifier1);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     _lender.transferLPTokens(address(_newUser), requestId, _balance);     uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);     assertEq(_newUserBalance, _balance);     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repaying the interest and some principal back     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // fetch borrowerInterestSharesWithdrawn for new user     uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     assertEq(_prevBISW, 0);     // get the interest for the new user     uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));     uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser     _newUser.withdrawInterest(requestId);     uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;     // match the interest shares withdrawn with the interest calculated     assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14); }  function test_stateAfterBorrow() public {     admin.updateProtocolFeeFraction(0);      uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('borrowable amount', _borrowableAmount);     assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);      uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));     borrower.borrow(requestId, _borrowableAmount);     uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));      assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);     assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14); }  function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());     _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     emit log_named_uint('_collateralRequired: ', _collateralRequired);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     // borrow some amount     uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());     if (_curBorrowAmount == _amountToBorrow) {         _curBorrowAmount = _curBorrowAmount.mul(90).div(100);     }     borrower.borrow(requestId, _curBorrowAmount);     // check borrow able amount     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     if (request.collateralRatio != 0) {         assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);     } else {         assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);     }     // now check withdrawableCollateral     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);     assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14); }  function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction); }  function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {     _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);     assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount)); }  function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {     if (request.collateralRatio == 0) return;     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);     uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));     emit log_named_uint('_maxCollateral: ', _maxCollateral);     emit log_named_uint('_minCollateral: ', _minCollateral);     _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);     emit log_named_uint('_collateralAmount: ', _collateralAmount);     _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);     emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);     // calulating what should borrowed to achieve _collateralRatioToAchieve     uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(         _collateralRatioToAchieve     );     emit log_named_uint('_amountToBorrow: ', _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);      uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('_maxBorrowable: ', _maxBorrowable);     if (         request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14     ) {         assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);         if (_amountToBorrow &gt; _maxBorrowable) {             _amountToBorrow = _maxBorrowable;         }     } else {         assertLe(_amountToBorrow, _maxBorrowable);     }      borrower.borrow(requestId, _amountToBorrow);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);      uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);     // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve     assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14); }  function test_closeActivePCLOncePrincipalPaidAndEnded() public {     // borrowing some tokens     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repay everything back     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _balance = borrowAsset.balanceOf(address(borrower));     if (_currentDebt &gt; _balance) {         admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));     }     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);     // go to end of pcl     vm.warp(block.timestamp + request.collectionPeriod + request.duration);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);     assertEq(0, borrowAsset.balanceOf(address(borrower))); }  event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);  function test_closeWhenNoCollateral() public {     vm.warp(block.timestamp + 6 days);     // close     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_closeWhenCollateral() public {     uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();     admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     vm.warp(block.timestamp + 6 days);     vm.roll(block.number + (6 * 86400) / 20);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));     vm.expectEmit(true, true, false, false);     emit CollateralSharesWithdrawn(requestId, _shares);     // close     borrower.close(requestId);     // this is equal only when no yield is used     // with compund this should be assertLe becuase deposited collateral would earn yield     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } else {         assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } }  event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare); event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);  function test_withdrawLiquidatedCollateral() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable.sub(10));     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable.sub(10),         address(borrowAsset)     );     // going ahead in time to make liquidation possible     vm.warp(block.timestamp + 50 days);     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);      uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;      vm.expectEmit(true, true, false, false);     emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } else {         assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } }  event PooledCreditLineTerminated(uint256 indexed id);  function test_terminateAfterLiquidation() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable);     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable,         address(borrowAsset)     );      // going ahead in time to make liquidation possible     vm.warp(block.timestamp + request.duration.mul(7).div(11));     vm.roll(block.number + request.duration.mul(7).div(11).div(20));     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;     vm.expectEmit(true, true, false, false);      emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);      uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));      uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));     emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);     // for an active pcl borrowLimit == total amount lent     _totalSupply = lp.totalSupply(requestId);     // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);     // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);     // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);      // now the admin terminates     vm.expectEmit(true, true, false, true);     emit PooledCreditLineTerminated(requestId);     admin.terminate(requestId);      assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));      if (request.borrowAssetStrategy == compoundYieldAddress) {         // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } else {         // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } }  function _helperDepositCollateral(     PCLUser _user,     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) private {     if (_amount != 0) {         _user.depositCollateral(_id, _amount, _fromSavingsAccount);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:26:28 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStage is PCLParent {     using SafeMath for uint256;     using SafeMath for uint128; uint256 requestId;  // enum PooledCreditLineStatus { //     NOT_CREATED, //     REQUESTED, //     ACTIVE, //     CLOSED, //     EXPIRED, //     LIQUIDATED, //     CANCELLED // }  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE); }  function test_cannotStartActivePCL() public {     try borrower.start(requestId) {         revert('cannot start active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     // verified using the borrower verifier instead of lender verifier     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_nonLenderCannotWithdrawLiquidity() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);     try _pooledCreditLineLender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL1');     } }  function test_lenderCannotWithdrawLiquidity() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotLendToActivePCL() public {     LenderInfo memory info = lenders[0];     PCLUser lender = PCLUser(info.lenderAddress);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendToActivePCLNewLender() public {     // Creating a new lender for lending     PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     lender.registerSelf(mockAdminVerifier1);     admin.transferToken(request.borrowAsset, address(lender), 100_000);     lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin)); }  function test_onlyBorrowerCanBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;     PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker)); }  function assert_borrowByInvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _user = PCLUser(_actor);     if (_actor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try admin.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try _user.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotBorrowMoreThanPossible() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);      try borrower.borrow(_id, _amountBorrowable + 1) {         revert('Borrower should not be able to borrow more than possible');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB3');     } }  function test_borrowerCannotBorrowZeroAmount() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.borrow(_id, 0) {         revert('Borrower should not be able to borrow zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB1');     } }  function test_lenderDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress); }  function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress); }  function test_adminDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin)); }  function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin)); }  function assert_DepositAndCannotWithdrawCollateral_InvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _depositor,     address _withdrawer ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      // Depositing into PCL     if (_depositor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     } else {         PCLUser _user = PCLUser(_depositor);          admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     }      // withdrawing from PCL     if (_withdrawer == address(admin)) {         try admin.withdrawCollateral(_id, _collateralRequired, false) {             revert('Admin should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_withdrawer);          try _user.withdrawCollateral(_id, _collateralRequired, false) {             revert('Invalid actor should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     if (request.collateralRatio != 0) {         borrower.withdrawCollateral(_id, _withdrawableCollateral, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_lenderDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);     _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(_lender, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try _lender.withdrawAllCollateral(_id, false) {         revert('lender should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_adminDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(admin, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try admin.withdrawAllCollateral(_id, false) {         revert('admin should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_borrowerCannotWithdrawZeroAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     try borrower.withdrawAllCollateral(_id, false) {         revert('borrower should not be able to withdraw zero all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  function test_borrowerCannotWithdrawZeroCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try borrower.withdrawCollateral(_id, 0, false) {         revert('Withdrawing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC2');     } }  function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);      try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {         revert('Withdrawing more collateral than withdrawable should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  function test_borrowerCanWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_cannotCloseIfDebtIsNonZero() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow); }  function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));     borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));     // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));      try borrower.close(_id) {         revert('Borrower should not be able to close with non-zero debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  function test_lenderCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin)); }  function assert_invalidActorCannotClose(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, request.minBorrowAmount);      if (_actor == address(admin)) {         try admin.close(_id) {             revert('Admin should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.close(_id) {             revert('Invalid actor should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanRepayAndClose() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanRepayAndClose(_id, _amountToBorrow); }  function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(_id, _currentDebt);      _currentDebt = pcl.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0);      borrower.close(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED); }  function test_repayWithInsufficientBalance() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));     try borrower.repay(_id, _currentDebt) {         revert('REVERT: Insufficient Balance');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds allowance');         } else {             assertEq(reason, 'Dai/insufficient-allowance');         }     } }  function test_borrowerCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower)); }  function test_adminCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;     emit log_named_uint('request.borrowLimit', request.borrowLimit);     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin)); }  function assert_InvalidActorCannotLiquidate(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      if (_actor == address(admin)) {         try admin.liquidate(_id, true) {             revert('admin liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.liquidate(_id, true) {             revert('Invalid actor liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } }  function test_onlyLendersCanLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit / 3;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyLendersCanLiquidate(_id, _amountToBorrow); }  function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {     if (request.collateralRatio == 0) return;     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      PCLUser _lender = PCLUser(lenders[1].lenderAddress);     uint256 _amountLent = lenders[1].amount;     _lender.liquidate(_id, true);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_lenderCannotLiquidateZeroPrincipal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with zero principal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, _amountToBorrow / 2);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with if collateral ratio is more than ideal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  function test_borrowerCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotTerminate(_id); }  function assert_borrowerCannotTerminate(uint256 _id) public {     try borrower.terminate(_id) {         revert('Borrower terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_lenderCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotTerminate(_id); }  function assert_lenderCannotTerminate(uint256 _id) public {     PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));     try _lender.terminate(_id) {         revert('Lender terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_onlyAdminCanTerminate() public {     uint256 _amountToBorrow = request.borrowLimit;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyAdminCanTerminate(_id, _amountToBorrow); }  function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));     vm.roll(block.number + (request.duration / (2 * 20)));      uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));     admin.terminate(_id);     uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     } else {         assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     }     if (request.borrowAssetStrategy == compoundYieldAddress) {         assertGe(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } else {         assertEq(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } }  function test_depositCollateral() public {     uint256 _amount = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositCollateral(_id, _amount); }  function assert_depositCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());     admin.transferToken(address(collateralAsset), address(borrower), _amount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);     borrower.depositCollateral(_id, _amount, false);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));     assertEq(pcl.depositedCollateralInShares(_id), _shares); }  function test_depositCollateral_insufficientBalance() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);      admin.transferToken(address(collateralAsset), address(borrower), 10);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);     try borrower.depositCollateral(_id, 100, false) {         revert('Insufficient Balance of collateral tokens');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds balance');         } else {             assertEq(reason, 'SafeERC20: low-level call failed');         }     } }  function test_depositZeroCollateral() public {     uint256 _amount = 0;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositZeroCollateral(_id, _amount); }  function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));     borrower.setAllowance(         pooledCreditLineAddress,         address(collateralAsset),         100_000 * (10**ERC20(address(collateralAsset)).decimals())     );     try borrower.depositCollateral(_id, _amount, false) {         revert('Depositing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC1');     } }  function test_depositCollateralFromSavingsAccount() public {     request.collateralAssetStrategy = compoundYieldAddress;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));     emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);     if (request.collateralRatio != 0) {         borrower.depositToSavingsAccount(             savingsAccountAddress,             _collateralRequired,             address(collateralAsset),             compoundYieldAddress,             address(borrower)         );     }     uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));     emit log_named_uint('total tokens: ', _totalTokens);     uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);     emit log_named_uint('required collateral: ', _collateralRequired);     borrower.setAllowanceForSavingsAccount(         savingsAccountAddress,         _collateralRequired,         address(collateralAsset),         pooledCreditLineAddress     );     _helperDepositCollateral(borrower, _id, _collateralRequired, true);     uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);     emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);     // assertEq(_borrowAbleAmount, _amountToBorrow);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, true);     }     uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);     uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         pooledCreditLineAddress,         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);     assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14); }  function test_adminCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, address(admin)); }  function test_lenderCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress); }  function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {     if (_actor == address(admin)) {         try admin.cancelRequest(_id) {             revert('Admin cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);         try _user.cancelRequest(_id) {             revert('Invalid actor cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotCancelRequest() public {     assert_borrowerCannotCancelRequest(requestId); }  function assert_borrowerCannotCancelRequest(uint256 _id) public {     try borrower.cancelRequest(_id) {         revert('Canceling a PCL in active stage should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow); }  function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay zero current debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP3');     } }  function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow); }  function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay if interest is zero');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP4');     } }  function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     try _lender.transferLPTokens(address(borrower), _id, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_borrowerCannotReceivePoolTokens() public {     assert_borrowerCannotReceivePoolTokens(requestId);     request.borrowerVerifier = mockAdminVerifier1;     borrower.registerSelf(mockAdminVerifier1);     (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);     assert_borrowerCannotReceivePoolTokens(_id); }  function assert_canTransferPoolTokensToVerifiedUser(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     // borrowing some tokens     {         uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());         uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;         uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);         admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);         borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);         _helperDepositCollateral(borrower, _id, _collateralRequired, false);         borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);          // going ahead in time to generate interest         vm.warp(block.timestamp + 6 days);         // repaying the interest and some principal back         borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);         borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);     }      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender     _lender.withdrawInterest(_id);      uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     // calculating the receivers interest in shares     uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);     uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         receiverInterestInTokens,         address(borrowAsset)     );      uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);     _lender.transferLPTokens(_recevingAddress, _id, _amount);      uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);     assertEq(_finalBalance - _prevBalance, _amount);      uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;     curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;     assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14); }  function assert_cannotTransferEcxessPoolTokens(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _id, _amount) {         revert('balance less than the amount to transfer');     } catch Error(string memory reason) {         // assertEq(reason, 'ERC1155: insufficient balance for transfer');         assertEq(reason, 'SafeMath: subtraction overflow');     } }  function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     // testing when user is not verified     try _lender.transferLPTokens(_newUserAddress, _id, _balance) {         revert('should not have been possible to send LP tokens to not verified user');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT3');     } }  function test_lenderTransfersTokenToAnotherLender() public {     LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     address _recevingAddress = lenders[1].lenderAddress;     assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);     assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance); }  function test_lenderTransferTokenToNewUser() public {     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));      // testing when user is verified     _newUser.registerSelf(mockAdminVerifier1);      LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);      assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3); }  function test_areTokensTransferable() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     LenderInfo memory _lenderInfo = lenders[0];      address _recevingAddress = lenders[1].lenderAddress;     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  function test_canTransferPoolTokensWhenZeroInterest() public {     PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);     assertGe(_startBalanceLenderFrom, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);      PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);     uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);     assertGe(_startBalanceLenderTo, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);      _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);     assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));     assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo)); }  function test_cannotWithdrawZeroInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);      // cannot withdraw zero interest     vm.expectRevert(bytes('LP:WI1'));     _lender.withdrawInterest(requestId); }  function test_newPoolTokenHolderCanWithdrawInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _newUser.registerSelf(mockAdminVerifier1);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     _lender.transferLPTokens(address(_newUser), requestId, _balance);     uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);     assertEq(_newUserBalance, _balance);     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repaying the interest and some principal back     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // fetch borrowerInterestSharesWithdrawn for new user     uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     assertEq(_prevBISW, 0);     // get the interest for the new user     uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));     uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser     _newUser.withdrawInterest(requestId);     uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;     // match the interest shares withdrawn with the interest calculated     assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14); }  function test_stateAfterBorrow() public {     admin.updateProtocolFeeFraction(0);      uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('borrowable amount', _borrowableAmount);     assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);      uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));     borrower.borrow(requestId, _borrowableAmount);     uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));      assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);     assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14); }  function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());     _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     emit log_named_uint('_collateralRequired: ', _collateralRequired);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     // borrow some amount     uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());     if (_curBorrowAmount == _amountToBorrow) {         _curBorrowAmount = _curBorrowAmount.mul(90).div(100);     }     borrower.borrow(requestId, _curBorrowAmount);     // check borrow able amount     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     if (request.collateralRatio != 0) {         assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);     } else {         assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);     }     // now check withdrawableCollateral     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);     assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14); }  function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction); }  function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {     _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);     assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount)); }  function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {     if (request.collateralRatio == 0) return;     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);     uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));     emit log_named_uint('_maxCollateral: ', _maxCollateral);     emit log_named_uint('_minCollateral: ', _minCollateral);     _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);     emit log_named_uint('_collateralAmount: ', _collateralAmount);     _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);     emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);     // calulating what should borrowed to achieve _collateralRatioToAchieve     uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(         _collateralRatioToAchieve     );     emit log_named_uint('_amountToBorrow: ', _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);      uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('_maxBorrowable: ', _maxBorrowable);     if (         request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14     ) {         assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);         if (_amountToBorrow &gt; _maxBorrowable) {             _amountToBorrow = _maxBorrowable;         }     } else {         assertLe(_amountToBorrow, _maxBorrowable);     }      borrower.borrow(requestId, _amountToBorrow);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);      uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);     // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve     assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14); }  function test_closeActivePCLOncePrincipalPaidAndEnded() public {     // borrowing some tokens     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repay everything back     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _balance = borrowAsset.balanceOf(address(borrower));     if (_currentDebt &gt; _balance) {         admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));     }     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);     // go to end of pcl     vm.warp(block.timestamp + request.collectionPeriod + request.duration);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);     assertEq(0, borrowAsset.balanceOf(address(borrower))); }  event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);  function test_closeWhenNoCollateral() public {     vm.warp(block.timestamp + 6 days);     // close     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_closeWhenCollateral() public {     uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();     admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     vm.warp(block.timestamp + 6 days);     vm.roll(block.number + (6 * 86400) / 20);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));     vm.expectEmit(true, true, false, false);     emit CollateralSharesWithdrawn(requestId, _shares);     // close     borrower.close(requestId);     // this is equal only when no yield is used     // with compund this should be assertLe becuase deposited collateral would earn yield     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } else {         assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } }  event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare); event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);  function test_withdrawLiquidatedCollateral() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable.sub(10));     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable.sub(10),         address(borrowAsset)     );     // going ahead in time to make liquidation possible     vm.warp(block.timestamp + 50 days);     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);      uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;      vm.expectEmit(true, true, false, false);     emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } else {         assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } }  event PooledCreditLineTerminated(uint256 indexed id);  function test_terminateAfterLiquidation() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable);     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable,         address(borrowAsset)     );      // going ahead in time to make liquidation possible     vm.warp(block.timestamp + request.duration.mul(7).div(11));     vm.roll(block.number + request.duration.mul(7).div(11).div(20));     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;     vm.expectEmit(true, true, false, false);      emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);      uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));      uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));     emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);     // for an active pcl borrowLimit == total amount lent     _totalSupply = lp.totalSupply(requestId);     // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);     // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);     // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);      // now the admin terminates     vm.expectEmit(true, true, false, true);     emit PooledCreditLineTerminated(requestId);     admin.terminate(requestId);      assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));      if (request.borrowAssetStrategy == compoundYieldAddress) {         // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } else {         // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } }  function _helperDepositCollateral(     PCLUser _user,     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) private {     if (_amount != 0) {         _user.depositCollateral(_id, _amount, _fromSavingsAccount);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:26:28 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:26:31 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:26:31 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 17493
completion_tokens: 1
total_tokens: 17494
cost: $-1.000000


[2024-27-08 09:26:31 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
.]

Based

[2024-27-08 09:26:31 INFO] **[Seminar Conclusion]**:

 Based

[2024-27-08 09:26:31 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-27-08 09:26:32 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStage is PCLParent {     using SafeMath for uint256;     using SafeMath for uint128; uint256 requestId;  // enum PooledCreditLineStatus { //     NOT_CREATED, //     REQUESTED, //     ACTIVE, //     CLOSED, //     EXPIRED, //     LIQUIDATED, //     CANCELLED // }  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE); }  function test_cannotStartActivePCL() public {     try borrower.start(requestId) {         revert('cannot start active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     // verified using the borrower verifier instead of lender verifier     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_nonLenderCannotWithdrawLiquidity() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);     try _pooledCreditLineLender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL1');     } }  function test_lenderCannotWithdrawLiquidity() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotLendToActivePCL() public {     LenderInfo memory info = lenders[0];     PCLUser lender = PCLUser(info.lenderAddress);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendToActivePCLNewLender() public {     // Creating a new lender for lending     PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     lender.registerSelf(mockAdminVerifier1);     admin.transferToken(request.borrowAsset, address(lender), 100_000);     lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin)); }  function test_onlyBorrowerCanBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;     PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker)); }  function assert_borrowByInvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _user = PCLUser(_actor);     if (_actor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try admin.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try _user.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotBorrowMoreThanPossible() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);      try borrower.borrow(_id, _amountBorrowable + 1) {         revert('Borrower should not be able to borrow more than possible');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB3');     } }  function test_borrowerCannotBorrowZeroAmount() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.borrow(_id, 0) {         revert('Borrower should not be able to borrow zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB1');     } }  function test_lenderDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress); }  function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress); }  function test_adminDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin)); }  function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin)); }  function assert_DepositAndCannotWithdrawCollateral_InvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _depositor,     address _withdrawer ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      // Depositing into PCL     if (_depositor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     } else {         PCLUser _user = PCLUser(_depositor);          admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     }      // withdrawing from PCL     if (_withdrawer == address(admin)) {         try admin.withdrawCollateral(_id, _collateralRequired, false) {             revert('Admin should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_withdrawer);          try _user.withdrawCollateral(_id, _collateralRequired, false) {             revert('Invalid actor should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     if (request.collateralRatio != 0) {         borrower.withdrawCollateral(_id, _withdrawableCollateral, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_lenderDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);     _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(_lender, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try _lender.withdrawAllCollateral(_id, false) {         revert('lender should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_adminDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(admin, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try admin.withdrawAllCollateral(_id, false) {         revert('admin should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_borrowerCannotWithdrawZeroAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     try borrower.withdrawAllCollateral(_id, false) {         revert('borrower should not be able to withdraw zero all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  function test_borrowerCannotWithdrawZeroCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try borrower.withdrawCollateral(_id, 0, false) {         revert('Withdrawing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC2');     } }  function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);      try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {         revert('Withdrawing more collateral than withdrawable should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  function test_borrowerCanWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_cannotCloseIfDebtIsNonZero() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow); }  function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));     borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));     // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));      try borrower.close(_id) {         revert('Borrower should not be able to close with non-zero debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  function test_lenderCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin)); }  function assert_invalidActorCannotClose(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, request.minBorrowAmount);      if (_actor == address(admin)) {         try admin.close(_id) {             revert('Admin should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.close(_id) {             revert('Invalid actor should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanRepayAndClose() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanRepayAndClose(_id, _amountToBorrow); }  function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(_id, _currentDebt);      _currentDebt = pcl.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0);      borrower.close(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED); }  function test_repayWithInsufficientBalance() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));     try borrower.repay(_id, _currentDebt) {         revert('REVERT: Insufficient Balance');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds allowance');         } else {             assertEq(reason, 'Dai/insufficient-allowance');         }     } }  function test_borrowerCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower)); }  function test_adminCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;     emit log_named_uint('request.borrowLimit', request.borrowLimit);     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin)); }  function assert_InvalidActorCannotLiquidate(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      if (_actor == address(admin)) {         try admin.liquidate(_id, true) {             revert('admin liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.liquidate(_id, true) {             revert('Invalid actor liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } }  function test_onlyLendersCanLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit / 3;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyLendersCanLiquidate(_id, _amountToBorrow); }  function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {     if (request.collateralRatio == 0) return;     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      PCLUser _lender = PCLUser(lenders[1].lenderAddress);     uint256 _amountLent = lenders[1].amount;     _lender.liquidate(_id, true);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_lenderCannotLiquidateZeroPrincipal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with zero principal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, _amountToBorrow / 2);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with if collateral ratio is more than ideal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  function test_borrowerCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotTerminate(_id); }  function assert_borrowerCannotTerminate(uint256 _id) public {     try borrower.terminate(_id) {         revert('Borrower terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_lenderCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotTerminate(_id); }  function assert_lenderCannotTerminate(uint256 _id) public {     PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));     try _lender.terminate(_id) {         revert('Lender terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_onlyAdminCanTerminate() public {     uint256 _amountToBorrow = request.borrowLimit;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyAdminCanTerminate(_id, _amountToBorrow); }  function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));     vm.roll(block.number + (request.duration / (2 * 20)));      uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));     admin.terminate(_id);     uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     } else {         assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     }     if (request.borrowAssetStrategy == compoundYieldAddress) {         assertGe(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } else {         assertEq(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } }  function test_depositCollateral() public {     uint256 _amount = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositCollateral(_id, _amount); }  function assert_depositCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());     admin.transferToken(address(collateralAsset), address(borrower), _amount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);     borrower.depositCollateral(_id, _amount, false);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));     assertEq(pcl.depositedCollateralInShares(_id), _shares); }  function test_depositCollateral_insufficientBalance() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);      admin.transferToken(address(collateralAsset), address(borrower), 10);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);     try borrower.depositCollateral(_id, 100, false) {         revert('Insufficient Balance of collateral tokens');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds balance');         } else {             assertEq(reason, 'SafeERC20: low-level call failed');         }     } }  function test_depositZeroCollateral() public {     uint256 _amount = 0;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositZeroCollateral(_id, _amount); }  function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));     borrower.setAllowance(         pooledCreditLineAddress,         address(collateralAsset),         100_000 * (10**ERC20(address(collateralAsset)).decimals())     );     try borrower.depositCollateral(_id, _amount, false) {         revert('Depositing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC1');     } }  function test_depositCollateralFromSavingsAccount() public {     request.collateralAssetStrategy = compoundYieldAddress;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));     emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);     if (request.collateralRatio != 0) {         borrower.depositToSavingsAccount(             savingsAccountAddress,             _collateralRequired,             address(collateralAsset),             compoundYieldAddress,             address(borrower)         );     }     uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));     emit log_named_uint('total tokens: ', _totalTokens);     uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);     emit log_named_uint('required collateral: ', _collateralRequired);     borrower.setAllowanceForSavingsAccount(         savingsAccountAddress,         _collateralRequired,         address(collateralAsset),         pooledCreditLineAddress     );     _helperDepositCollateral(borrower, _id, _collateralRequired, true);     uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);     emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);     // assertEq(_borrowAbleAmount, _amountToBorrow);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, true);     }     uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);     uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         pooledCreditLineAddress,         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);     assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14); }  function test_adminCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, address(admin)); }  function test_lenderCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress); }  function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {     if (_actor == address(admin)) {         try admin.cancelRequest(_id) {             revert('Admin cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);         try _user.cancelRequest(_id) {             revert('Invalid actor cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotCancelRequest() public {     assert_borrowerCannotCancelRequest(requestId); }  function assert_borrowerCannotCancelRequest(uint256 _id) public {     try borrower.cancelRequest(_id) {         revert('Canceling a PCL in active stage should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow); }  function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay zero current debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP3');     } }  function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow); }  function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay if interest is zero');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP4');     } }  function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     try _lender.transferLPTokens(address(borrower), _id, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_borrowerCannotReceivePoolTokens() public {     assert_borrowerCannotReceivePoolTokens(requestId);     request.borrowerVerifier = mockAdminVerifier1;     borrower.registerSelf(mockAdminVerifier1);     (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);     assert_borrowerCannotReceivePoolTokens(_id); }  function assert_canTransferPoolTokensToVerifiedUser(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     // borrowing some tokens     {         uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());         uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;         uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);         admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);         borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);         _helperDepositCollateral(borrower, _id, _collateralRequired, false);         borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);          // going ahead in time to generate interest         vm.warp(block.timestamp + 6 days);         // repaying the interest and some principal back         borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);         borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);     }      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender     _lender.withdrawInterest(_id);      uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     // calculating the receivers interest in shares     uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);     uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         receiverInterestInTokens,         address(borrowAsset)     );      uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);     _lender.transferLPTokens(_recevingAddress, _id, _amount);      uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);     assertEq(_finalBalance - _prevBalance, _amount);      uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;     curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;     assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14); }  function assert_cannotTransferEcxessPoolTokens(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _id, _amount) {         revert('balance less than the amount to transfer');     } catch Error(string memory reason) {         // assertEq(reason, 'ERC1155: insufficient balance for transfer');         assertEq(reason, 'SafeMath: subtraction overflow');     } }  function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     // testing when user is not verified     try _lender.transferLPTokens(_newUserAddress, _id, _balance) {         revert('should not have been possible to send LP tokens to not verified user');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT3');     } }  function test_lenderTransfersTokenToAnotherLender() public {     LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     address _recevingAddress = lenders[1].lenderAddress;     assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);     assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance); }  function test_lenderTransferTokenToNewUser() public {     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));      // testing when user is verified     _newUser.registerSelf(mockAdminVerifier1);      LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);      assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3); }  function test_areTokensTransferable() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     LenderInfo memory _lenderInfo = lenders[0];      address _recevingAddress = lenders[1].lenderAddress;     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  function test_canTransferPoolTokensWhenZeroInterest() public {     PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);     assertGe(_startBalanceLenderFrom, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);      PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);     uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);     assertGe(_startBalanceLenderTo, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);      _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);     assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));     assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo)); }  function test_cannotWithdrawZeroInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);      // cannot withdraw zero interest     vm.expectRevert(bytes('LP:WI1'));     _lender.withdrawInterest(requestId); }  function test_newPoolTokenHolderCanWithdrawInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _newUser.registerSelf(mockAdminVerifier1);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     _lender.transferLPTokens(address(_newUser), requestId, _balance);     uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);     assertEq(_newUserBalance, _balance);     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repaying the interest and some principal back     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // fetch borrowerInterestSharesWithdrawn for new user     uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     assertEq(_prevBISW, 0);     // get the interest for the new user     uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));     uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser     _newUser.withdrawInterest(requestId);     uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;     // match the interest shares withdrawn with the interest calculated     assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14); }  function test_stateAfterBorrow() public {     admin.updateProtocolFeeFraction(0);      uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('borrowable amount', _borrowableAmount);     assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);      uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));     borrower.borrow(requestId, _borrowableAmount);     uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));      assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);     assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14); }  function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());     _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     emit log_named_uint('_collateralRequired: ', _collateralRequired);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     // borrow some amount     uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());     if (_curBorrowAmount == _amountToBorrow) {         _curBorrowAmount = _curBorrowAmount.mul(90).div(100);     }     borrower.borrow(requestId, _curBorrowAmount);     // check borrow able amount     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     if (request.collateralRatio != 0) {         assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);     } else {         assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);     }     // now check withdrawableCollateral     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);     assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14); }  function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction); }  function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {     _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);     assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount)); }  function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {     if (request.collateralRatio == 0) return;     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);     uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));     emit log_named_uint('_maxCollateral: ', _maxCollateral);     emit log_named_uint('_minCollateral: ', _minCollateral);     _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);     emit log_named_uint('_collateralAmount: ', _collateralAmount);     _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);     emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);     // calulating what should borrowed to achieve _collateralRatioToAchieve     uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(         _collateralRatioToAchieve     );     emit log_named_uint('_amountToBorrow: ', _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);      uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('_maxBorrowable: ', _maxBorrowable);     if (         request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14     ) {         assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);         if (_amountToBorrow &gt; _maxBorrowable) {             _amountToBorrow = _maxBorrowable;         }     } else {         assertLe(_amountToBorrow, _maxBorrowable);     }      borrower.borrow(requestId, _amountToBorrow);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);      uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);     // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve     assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14); }  function test_closeActivePCLOncePrincipalPaidAndEnded() public {     // borrowing some tokens     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repay everything back     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _balance = borrowAsset.balanceOf(address(borrower));     if (_currentDebt &gt; _balance) {         admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));     }     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);     // go to end of pcl     vm.warp(block.timestamp + request.collectionPeriod + request.duration);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);     assertEq(0, borrowAsset.balanceOf(address(borrower))); }  event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);  function test_closeWhenNoCollateral() public {     vm.warp(block.timestamp + 6 days);     // close     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_closeWhenCollateral() public {     uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();     admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     vm.warp(block.timestamp + 6 days);     vm.roll(block.number + (6 * 86400) / 20);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));     vm.expectEmit(true, true, false, false);     emit CollateralSharesWithdrawn(requestId, _shares);     // close     borrower.close(requestId);     // this is equal only when no yield is used     // with compund this should be assertLe becuase deposited collateral would earn yield     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } else {         assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } }  event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare); event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);  function test_withdrawLiquidatedCollateral() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable.sub(10));     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable.sub(10),         address(borrowAsset)     );     // going ahead in time to make liquidation possible     vm.warp(block.timestamp + 50 days);     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);      uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;      vm.expectEmit(true, true, false, false);     emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } else {         assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } }  event PooledCreditLineTerminated(uint256 indexed id);  function test_terminateAfterLiquidation() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable);     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable,         address(borrowAsset)     );      // going ahead in time to make liquidation possible     vm.warp(block.timestamp + request.duration.mul(7).div(11));     vm.roll(block.number + request.duration.mul(7).div(11).div(20));     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;     vm.expectEmit(true, true, false, false);      emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);      uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));      uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));     emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);     // for an active pcl borrowLimit == total amount lent     _totalSupply = lp.totalSupply(requestId);     // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);     // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);     // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);      // now the admin terminates     vm.expectEmit(true, true, false, true);     emit PooledCreditLineTerminated(requestId);     admin.terminate(requestId);      assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));      if (request.borrowAssetStrategy == compoundYieldAddress) {         // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } else {         // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } }  function _helperDepositCollateral(     PCLUser _user,     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) private {     if (_amount != 0) {         _user.depositCollateral(_id, _amount, _fromSavingsAccount);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLActiveStage is PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n\n    uint256 requestId;\n\n    // enum PooledCreditLineStatus {\n    //     NOT_CREATED,\n    //     REQUESTED,\n    //     ACTIVE,\n    //     CLOSED,\n    //     EXPIRED,\n    //     LIQUIDATED,\n    //     CANCELLED\n    // }\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function test_cannotStartActivePCL() public {\n        try borrower.start(requestId) {\n            revert('cannot start active pcl');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:S1');\n        }\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert('External user cannot create');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert('External user cannot terminate');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert('Lender cannot lend zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L1');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        // verified using the borrower verifier instead of lender verifier\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Unverified lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L2');\n        }\n    }\n\n    function test_nonLenderCannotWithdrawLiquidity() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        try _pooledCreditLineLender.withdrawLiquidity(requestId) {\n            revert('Lender cannot withdraw liquidity');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL1');\n        }\n    }\n\n    function test_lenderCannotWithdrawLiquidity() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.withdrawLiquidity(requestId) {\n            revert('Lender cannot withdraw liquidity');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n    }\n\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert('Non lender cannot withdraw liquidated collateral tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:WLC1');\n        }\n    }\n\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert('Lender cannot withdraw liquidated collateral tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    function test_cannotTransferLPTokensToSameAddress() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert('Lender cannot transfer LP tokens to itself');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT1');\n        }\n    }\n\n    function test_cannotBurnPoolTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert('Lender cannot burn LP tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'ERC1155: transfer to the zero address');\n        }\n    }\n\n    function test_cannotLendToActivePCL() public {\n        LenderInfo memory info = lenders[0];\n        PCLUser lender = PCLUser(info.lenderAddress);\n        try lender.lend(requestId, 100_000) {\n            revert('cannot lend to active pcl');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    function test_cannotLendToActivePCLNewLender() public {\n        // Creating a new lender for lending\n        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        lender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(request.borrowAsset, address(lender), 100_000);\n        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);\n        try lender.lend(requestId, 100_000) {\n            revert('cannot lend to active pcl');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    function test_lenderCannotBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);\n    }\n\n    function test_adminCannotBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));\n    }\n\n    function test_onlyBorrowerCanBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));\n    }\n\n    function assert_borrowByInvalidActor(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        PCLUser _user = PCLUser(_actor);\n        if (_actor == address(admin)) {\n            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n            _helperDepositCollateral(admin, _id, _collateralRequired, false);\n\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n            try admin.borrow(_id, _amountToBorrow) {\n                revert('Invalid user should not be able to borrow');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        } else {\n            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);\n            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n            _helperDepositCollateral(_user, _id, _collateralRequired, false);\n\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n            try _user.borrow(_id, _amountToBorrow) {\n                revert('Invalid user should not be able to borrow');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        }\n    }\n\n    function test_borrowerCannotBorrowMoreThanPossible() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);\n\n        try borrower.borrow(_id, _amountBorrowable + 1) {\n            revert('Borrower should not be able to borrow more than possible');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:IB3');\n        }\n    }\n\n    function test_borrowerCannotBorrowZeroAmount() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        try borrower.borrow(_id, 0) {\n            revert('Borrower should not be able to borrow zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:IB1');\n        }\n    }\n\n    function test_lenderDepositsAndCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);\n    }\n\n    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);\n    }\n\n    function test_adminDepositsAndCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));\n    }\n\n    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));\n    }\n\n    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _depositor,\n        address _withdrawer\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        // Depositing into PCL\n        if (_depositor == address(admin)) {\n            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n            _helperDepositCollateral(admin, _id, _collateralRequired, false);\n\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n        } else {\n            PCLUser _user = PCLUser(_depositor);\n\n            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);\n            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n            _helperDepositCollateral(_user, _id, _collateralRequired, false);\n\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n        }\n\n        // withdrawing from PCL\n        if (_withdrawer == address(admin)) {\n            try admin.withdrawCollateral(_id, _collateralRequired, false) {\n                revert('Admin should not be able to withdraw collateral');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        } else {\n            PCLUser _user = PCLUser(_withdrawer);\n\n            try _user.withdrawCollateral(_id, _collateralRequired, false) {\n                revert('Invalid actor should not be able to withdraw collateral');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        }\n    }\n\n    function test_borrowerCanWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);\n        if (request.collateralRatio != 0) {\n            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);\n        }\n        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);\n    }\n\n    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);\n        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(_lender, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        try _lender.withdrawAllCollateral(_id, false) {\n            revert('lender should not be able to withdraw all collateral');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:OCLB1');\n        }\n    }\n\n    function test_adminDepositsAndCannotWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(admin, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        try admin.withdrawAllCollateral(_id, false) {\n            revert('admin should not be able to withdraw all collateral');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:OCLB1');\n        }\n    }\n\n    function test_borrowerCannotWithdrawZeroAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        try borrower.withdrawAllCollateral(_id, false) {\n            revert('borrower should not be able to withdraw zero all collateral');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WAC1');\n        }\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        try borrower.withdrawCollateral(_id, 0, false) {\n            revert('Withdrawing zero collateral should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC2');\n        }\n    }\n\n    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);\n\n        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {\n            revert('Withdrawing more collateral than withdrawable should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC1');\n        }\n    }\n\n    function test_borrowerCanWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        if (request.collateralRatio != 0) {\n            borrower.withdrawAllCollateral(_id, false);\n        }\n        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);\n    }\n\n    function test_cannotCloseIfDebtIsNonZero() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);\n    }\n\n    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));\n        borrower.borrow(_id, 90_000 * (10ERC20(address(borrowAsset)).decimals()));\n        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));\n\n        try borrower.close(_id) {\n            revert('Borrower should not be able to close with non-zero debt');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C2');\n        }\n    }\n\n    function test_lenderCannotClose() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);\n    }\n\n    function test_adminCannotClose() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));\n    }\n\n    function assert_invalidActorCannotClose(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        borrower.borrow(_id, request.minBorrowAmount);\n\n        if (_actor == address(admin)) {\n            try admin.close(_id) {\n                revert('Admin should not be able to close PCL');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n\n            try _user.close(_id) {\n                revert('Invalid actor should not be able to close PCL');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        }\n    }\n\n    function test_borrowerCanRepayAndClose() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n\n        vm.warp(block.timestamp + (request.duration / 2));\n\n        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(_id, _currentDebt);\n\n        _currentDebt = pcl.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0);\n\n        borrower.close(_id);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_repayWithInsufficientBalance() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n\n        vm.warp(block.timestamp + (request.duration / 2));\n\n        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));\n        try borrower.repay(_id, _currentDebt) {\n            revert('REVERT: Insufficient Balance');\n        } catch Error(string memory reason) {\n            if (!isForked) {\n                assertEq(reason, 'ERC20: transfer amount exceeds allowance');\n            } else {\n                assertEq(reason, 'Dai/insufficient-allowance');\n            }\n        }\n    }\n\n    function test_borrowerCannotLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));\n    }\n\n    function test_adminCannotLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        emit log_named_uint('request.borrowLimit', request.borrowLimit);\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));\n    }\n\n    function assert_InvalidActorCannotLiquidate(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);\n        borrower.borrow(_id, _borrowable);\n\n        vm.warp(block.timestamp + (request.duration / 2));\n\n        if (!isForked) {\n            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);\n        }\n\n        if (_actor == address(admin)) {\n            try admin.liquidate(_id, true) {\n                revert('admin liquidating should revert');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'LP:LIQ1');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n\n            try _user.liquidate(_id, true) {\n                revert('Invalid actor liquidating should revert');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'LP:LIQ1');\n            }\n        }\n    }\n\n    function test_onlyLendersCanLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit / 3;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);\n    }\n\n    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {\n        if (request.collateralRatio == 0) return;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);\n        borrower.borrow(_id, _borrowable);\n\n        vm.warp(block.timestamp + (request.duration / 2));\n\n        if (!isForked) {\n            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);\n        }\n\n        PCLUser _lender = PCLUser(lenders[1].lenderAddress);\n        uint256 _amountLent = lenders[1].amount;\n        _lender.liquidate(_id, true);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_lenderCannotLiquidateZeroPrincipal() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);\n    }\n\n    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        vm.warp(block.timestamp + (request.duration / 2));\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.liquidate(_id, true) {\n            revert('Lender liquidating should revert with zero principal');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L1');\n        }\n    }\n\n    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);\n    }\n\n    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, _amountToBorrow / 2);\n\n        vm.warp(block.timestamp + (request.duration / 2));\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.liquidate(_id, true) {\n            revert('Lender liquidating should revert with if collateral ratio is more than ideal');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    function test_borrowerCannotTerminate() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotTerminate(_id);\n    }\n\n    function assert_borrowerCannotTerminate(uint256 _id) public {\n        try borrower.terminate(_id) {\n            revert('Borrower terminating PCL should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'Ownable: caller is not the owner');\n        }\n    }\n\n    function test_lenderCannotTerminate() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotTerminate(_id);\n    }\n\n    function assert_lenderCannotTerminate(uint256 _id) public {\n        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));\n        try _lender.terminate(_id) {\n            revert('Lender terminating PCL should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'Ownable: caller is not the owner');\n        }\n    }\n\n    function test_onlyAdminCanTerminate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_onlyAdminCanTerminate(_id, _amountToBorrow);\n    }\n\n    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n\n        vm.warp(block.timestamp + (request.duration / 2));\n        vm.roll(block.number + (request.duration / (2 * 20)));\n\n        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));\n        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));\n        admin.terminate(_id);\n        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));\n        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);\n        } else {\n            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);\n        }\n        if (request.borrowAssetStrategy == compoundYieldAddress) {\n            assertGe(\n                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,\n                (request.borrowLimit / 2) - 90_000 * 10(ERC20(address(borrowAsset)).decimals())\n            );\n        } else {\n            assertEq(\n                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,\n                (request.borrowLimit / 2) - 90_000 * 10(ERC20(address(borrowAsset)).decimals())\n            );\n        }\n    }\n\n    function test_depositCollateral() public {\n        uint256 _amount = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_depositCollateral(_id, _amount);\n    }\n\n    function assert_depositCollateral(uint256 _id, uint256 _amount) public {\n        // lender.lend(_id, _amount);\n        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());\n        admin.transferToken(address(collateralAsset), address(borrower), _amount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);\n        borrower.depositCollateral(_id, _amount, false);\n        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));\n        assertEq(pcl.depositedCollateralInShares(_id), _shares);\n    }\n\n    function test_depositCollateral_insufficientBalance() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n\n        admin.transferToken(address(collateralAsset), address(borrower), 10);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);\n        try borrower.depositCollateral(_id, 100, false) {\n            revert('Insufficient Balance of collateral tokens');\n        } catch Error(string memory reason) {\n            if (!isForked) {\n                assertEq(reason, 'ERC20: transfer amount exceeds balance');\n            } else {\n                assertEq(reason, 'SafeERC20: low-level call failed');\n            }\n        }\n    }\n\n    function test_depositZeroCollateral() public {\n        uint256 _amount = 0;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_depositZeroCollateral(_id, _amount);\n    }\n\n    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {\n        // lender.lend(_id, _amount);\n        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10ERC20(address(collateralAsset)).decimals()));\n        borrower.setAllowance(\n            pooledCreditLineAddress,\n            address(collateralAsset),\n            100_000 * (10ERC20(address(collateralAsset)).decimals())\n        );\n        try borrower.depositCollateral(_id, _amount, false) {\n            revert('Depositing zero collateral should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:DC1');\n        }\n    }\n\n    function test_depositCollateralFromSavingsAccount() public {\n        request.collateralAssetStrategy = compoundYieldAddress;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));\n        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);\n        if (request.collateralRatio != 0) {\n            borrower.depositToSavingsAccount(\n                savingsAccountAddress,\n                _collateralRequired,\n                address(collateralAsset),\n                compoundYieldAddress,\n                address(borrower)\n            );\n        }\n        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));\n        emit log_named_uint('total tokens: ', _totalTokens);\n        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            address(borrower),\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);\n        emit log_named_uint('required collateral: ', _collateralRequired);\n        borrower.setAllowanceForSavingsAccount(\n            savingsAccountAddress,\n            _collateralRequired,\n            address(collateralAsset),\n            pooledCreditLineAddress\n        );\n        _helperDepositCollateral(borrower, _id, _collateralRequired, true);\n        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);\n        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);\n        // assertEq(_borrowAbleAmount, _amountToBorrow);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);\n        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.withdrawAllCollateral(_id, true);\n        }\n        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            address(borrower),\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);\n        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            pooledCreditLineAddress,\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);\n        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);\n    }\n\n    function test_adminCannotCancelRequest() public {\n        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));\n    }\n\n    function test_lenderCannotCancelRequest() public {\n        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);\n    }\n\n    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {\n        if (_actor == address(admin)) {\n            try admin.cancelRequest(_id) {\n                revert('Admin cannot cancel PCL');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n            try _user.cancelRequest(_id) {\n                revert('Invalid actor cannot cancel PCL');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        }\n    }\n\n    function test_borrowerCannotCancelRequest() public {\n        assert_borrowerCannotCancelRequest(requestId);\n    }\n\n    function assert_borrowerCannotCancelRequest(uint256 _id) public {\n        try borrower.cancelRequest(_id) {\n            revert('Canceling a PCL in active stage should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {\n        _seed = scaleToRange128(_seed, 1, 10);\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);\n        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        try borrower.repay(_id, 1) {\n            revert('Borrower should not be able to repay zero current debt');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:REP3');\n        }\n    }\n\n    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {\n        _seed = scaleToRange128(_seed, 1, 10);\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);\n        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        uint256 _borrowAssetDecimalScaling = 10(ERC20(address(borrowAsset)).decimals());\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);\n\n        try borrower.repay(_id, 1) {\n            revert('Borrower should not be able to repay if interest is zero');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:REP4');\n        }\n    }\n\n    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);\n        log_named_uint('lender lp balance: ', _balance);\n        try _lender.transferLPTokens(address(borrower), _id, _balance) {\n            revert('should not have been possible to send LP tokens to the borrower');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT2');\n        }\n    }\n\n    function test_borrowerCannotReceivePoolTokens() public {\n        assert_borrowerCannotReceivePoolTokens(requestId);\n        request.borrowerVerifier = mockAdminVerifier1;\n        borrower.registerSelf(mockAdminVerifier1);\n        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);\n        assert_borrowerCannotReceivePoolTokens(_id);\n    }\n\n    function assert_canTransferPoolTokensToVerifiedUser(\n        uint256 _id,\n        address _recevingAddress,\n        uint256 _amount\n    ) public {\n        // borrowing some tokens\n        {\n            uint256 _borrowAssetDecimalScaling = 10(ERC20(address(borrowAsset)).decimals());\n            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;\n            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n            _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);\n\n            // going ahead in time to generate interest\n            vm.warp(block.timestamp + 6 days);\n            // repaying the interest and some principal back\n            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);\n            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);\n        }\n\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender\n        _lender.withdrawInterest(_id);\n\n        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;\n        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;\n        // calculating the receivers interest in shares\n        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);\n        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            receiverInterestInTokens,\n            address(borrowAsset)\n        );\n\n        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);\n        _lender.transferLPTokens(_recevingAddress, _id, _amount);\n\n        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);\n        assertEq(_finalBalance - _prevBalance, _amount);\n\n        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;\n        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;\n        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;\n        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;\n        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);\n    }\n\n    function assert_cannotTransferEcxessPoolTokens(\n        uint256 _id,\n        address _recevingAddress,\n        uint256 _amount\n    ) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {\n            revert('balance less than the amount to transfer');\n        } catch Error(string memory reason) {\n            // assertEq(reason, 'ERC1155: insufficient balance for transfer');\n            assertEq(reason, 'SafeMath: subtraction overflow');\n        }\n    }\n\n    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);\n        log_named_uint('lender lp balance: ', _balance);\n        // testing when user is not verified\n        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {\n            revert('should not have been possible to send LP tokens to not verified user');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT3');\n        }\n    }\n\n    function test_lenderTransfersTokenToAnotherLender() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n        address _recevingAddress = lenders[1].lenderAddress;\n        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);\n        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);\n    }\n\n    function test_lenderTransferTokenToNewUser() public {\n        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));\n\n        // testing when user is verified\n        _newUser.registerSelf(mockAdminVerifier1);\n\n        LenderInfo memory _lenderInfo = lenders[0];\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n\n        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);\n    }\n\n    function test_areTokensTransferable() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        LenderInfo memory _lenderInfo = lenders[0];\n\n        address _recevingAddress = lenders[1].lenderAddress;\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {\n            revert('should not have been possible to send LP tokens to the borrower');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT5');\n        }\n    }\n\n    function test_canTransferPoolTokensWhenZeroInterest() public {\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);\n        assertGe(_startBalanceLenderFrom, 0);\n        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);\n\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);\n        assertGe(_startBalanceLenderTo, 0);\n        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);\n\n        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);\n        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));\n        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));\n    }\n\n    function test_cannotWithdrawZeroInterest() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n\n        // cannot withdraw zero interest\n        vm.expectRevert(bytes('LP:WI1'));\n        _lender.withdrawInterest(requestId);\n    }\n\n    function test_newPoolTokenHolderCanWithdrawInterest() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _newUser.registerSelf(mockAdminVerifier1);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n        _lender.transferLPTokens(address(_newUser), requestId, _balance);\n        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);\n        assertEq(_newUserBalance, _balance);\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        borrower.borrow(requestId, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // going ahead in time to generate interest\n        vm.warp(block.timestamp + 6 days);\n        // repaying the interest and some principal back\n        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        borrower.repay(requestId, 10_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // fetch borrowerInterestSharesWithdrawn for new user\n        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;\n        assertEq(_prevBISW, 0);\n        // get the interest for the new user\n        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));\n        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));\n        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser\n        _newUser.withdrawInterest(requestId);\n        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;\n        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;\n        // match the interest shares withdrawn with the interest calculated\n        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);\n    }\n\n    function test_stateAfterBorrow() public {\n        admin.updateProtocolFeeFraction(0);\n\n        uint256 _amountToBorrow = request.borrowLimit;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        emit log_named_uint('borrowable amount', _borrowableAmount);\n        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);\n\n        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));\n        borrower.borrow(requestId, _borrowableAmount);\n        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));\n\n        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);\n        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);\n    }\n\n    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {\n        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());\n        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        emit log_named_uint('_collateralRequired: ', _collateralRequired);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        // borrow some amount\n        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());\n        if (_curBorrowAmount == _amountToBorrow) {\n            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);\n        }\n        borrower.borrow(requestId, _curBorrowAmount);\n        // check borrow able amount\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        if (request.collateralRatio != 0) {\n            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);\n        } else {\n            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);\n        }\n        // now check withdrawableCollateral\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);\n        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);\n    }\n\n    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {\n        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);\n    }\n\n    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {\n        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10_decimals).div(_ratioOfPrices);\n        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));\n    }\n\n    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {\n        if (request.collateralRatio == 0) return;\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);\n        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10ERC20(address(borrowAsset)).decimals()));\n        emit log_named_uint('_maxCollateral: ', _maxCollateral);\n        emit log_named_uint('_minCollateral: ', _minCollateral);\n        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);\n        emit log_named_uint('_collateralAmount: ', _collateralAmount);\n        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);\n        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);\n        // calulating what should borrowed to achieve _collateralRatioToAchieve\n        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10_decimals).mul(pcl.SCALING_FACTOR()).div(\n            _collateralRatioToAchieve\n        );\n        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);\n        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);\n        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);\n\n        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);\n        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);\n        if (\n            request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14\n        ) {\n            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);\n            if (_amountToBorrow &gt; _maxBorrowable) {\n                _amountToBorrow = _maxBorrowable;\n            }\n        } else {\n            assertLe(_amountToBorrow, _maxBorrowable);\n        }\n\n        borrower.borrow(requestId, _amountToBorrow);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);\n\n        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);\n        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve\n        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);\n    }\n\n    function test_closeActivePCLOncePrincipalPaidAndEnded() public {\n        // borrowing some tokens\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        borrower.borrow(requestId, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // going ahead in time to generate interest\n        vm.warp(block.timestamp + 6 days);\n        // repay everything back\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        uint256 _balance = borrowAsset.balanceOf(address(borrower));\n        if (_currentDebt &gt; _balance) {\n            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));\n        }\n        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n        // go to end of pcl\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n        assertEq(0, borrowAsset.balanceOf(address(borrower)));\n    }\n\n    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);\n\n    function test_closeWhenNoCollateral() public {\n        vm.warp(block.timestamp + 6 days);\n        // close\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_closeWhenCollateral() public {\n        uint256 _collateralAmount = 1e2 * 10ERC20(address(collateralAsset)).decimals();\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);\n        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);\n        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));\n        vm.warp(block.timestamp + 6 days);\n        vm.roll(block.number + (6 * 86400) / 20);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));\n        vm.expectEmit(true, true, false, false);\n        emit CollateralSharesWithdrawn(requestId, _shares);\n        // close\n        borrower.close(requestId);\n        // this is equal only when no yield is used\n        // with compund this should be assertLe becuase deposited collateral would earn yield\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));\n        } else {\n            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));\n        }\n    }\n\n    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);\n    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);\n\n    function test_withdrawLiquidatedCollateral() public {\n        if (request.collateralRatio == 0) return;\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);\n        borrower.borrow(requestId, _borrowable.sub(10));\n        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            request.borrowLimit - _borrowable.sub(10),\n            address(borrowAsset)\n        );\n        // going ahead in time to make liquidation possible\n        vm.warp(block.timestamp + 50 days);\n        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);\n        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));\n\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _totalSupply = lp.totalSupply(requestId);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n\n        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            _principalBorowable,\n            address(borrowAsset)\n        );\n        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +\n            _lenderYieldShares;\n\n        vm.expectEmit(true, true, false, false);\n        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);\n        _lender.liquidate(requestId, true);\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));\n        } else {\n            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));\n        }\n    }\n\n    event PooledCreditLineTerminated(uint256 indexed id);\n\n    function test_terminateAfterLiquidation() public {\n        if (request.collateralRatio == 0) return;\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);\n        borrower.borrow(requestId, _borrowable);\n        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            request.borrowLimit - _borrowable,\n            address(borrowAsset)\n        );\n\n        // going ahead in time to make liquidation possible\n        vm.warp(block.timestamp + request.duration.mul(7).div(11));\n        vm.roll(block.number + request.duration.mul(7).div(11).div(20));\n        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);\n        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));\n\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _totalSupply = lp.totalSupply(requestId);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            _principalBorowable,\n            address(borrowAsset)\n        );\n        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +\n            _lenderYieldShares;\n        vm.expectEmit(true, true, false, false);\n\n        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);\n        _lender.liquidate(requestId, true);\n\n        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));\n\n        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));\n        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);\n        // for an active pcl borrowLimit == total amount lent\n        _totalSupply = lp.totalSupply(requestId);\n        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);\n        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);\n        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);\n\n        // now the admin terminates\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineTerminated(requestId);\n        admin.terminate(requestId);\n\n        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));\n\n        if (request.borrowAssetStrategy == compoundYieldAddress) {\n            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));\n        } else {\n            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));\n        }\n    }\n\n    function _helperDepositCollateral(\n        PCLUser _user,\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) private {\n        if (_amount != 0) {\n            _user.depositCollateral(_id, _amount, _fromSavingsAccount);\n        }\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:26:32 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStage is PCLParent {     using SafeMath for uint256;     using SafeMath for uint128; uint256 requestId;  // enum PooledCreditLineStatus { //     NOT_CREATED, //     REQUESTED, //     ACTIVE, //     CLOSED, //     EXPIRED, //     LIQUIDATED, //     CANCELLED // }  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE); }  function test_cannotStartActivePCL() public {     try borrower.start(requestId) {         revert('cannot start active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     // verified using the borrower verifier instead of lender verifier     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_nonLenderCannotWithdrawLiquidity() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);     try _pooledCreditLineLender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL1');     } }  function test_lenderCannotWithdrawLiquidity() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotLendToActivePCL() public {     LenderInfo memory info = lenders[0];     PCLUser lender = PCLUser(info.lenderAddress);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendToActivePCLNewLender() public {     // Creating a new lender for lending     PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     lender.registerSelf(mockAdminVerifier1);     admin.transferToken(request.borrowAsset, address(lender), 100_000);     lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin)); }  function test_onlyBorrowerCanBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;     PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker)); }  function assert_borrowByInvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _user = PCLUser(_actor);     if (_actor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try admin.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try _user.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotBorrowMoreThanPossible() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);      try borrower.borrow(_id, _amountBorrowable + 1) {         revert('Borrower should not be able to borrow more than possible');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB3');     } }  function test_borrowerCannotBorrowZeroAmount() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.borrow(_id, 0) {         revert('Borrower should not be able to borrow zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB1');     } }  function test_lenderDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress); }  function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress); }  function test_adminDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin)); }  function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin)); }  function assert_DepositAndCannotWithdrawCollateral_InvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _depositor,     address _withdrawer ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      // Depositing into PCL     if (_depositor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     } else {         PCLUser _user = PCLUser(_depositor);          admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     }      // withdrawing from PCL     if (_withdrawer == address(admin)) {         try admin.withdrawCollateral(_id, _collateralRequired, false) {             revert('Admin should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_withdrawer);          try _user.withdrawCollateral(_id, _collateralRequired, false) {             revert('Invalid actor should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     if (request.collateralRatio != 0) {         borrower.withdrawCollateral(_id, _withdrawableCollateral, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_lenderDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);     _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(_lender, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try _lender.withdrawAllCollateral(_id, false) {         revert('lender should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_adminDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(admin, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try admin.withdrawAllCollateral(_id, false) {         revert('admin should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_borrowerCannotWithdrawZeroAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     try borrower.withdrawAllCollateral(_id, false) {         revert('borrower should not be able to withdraw zero all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  function test_borrowerCannotWithdrawZeroCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try borrower.withdrawCollateral(_id, 0, false) {         revert('Withdrawing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC2');     } }  function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);      try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {         revert('Withdrawing more collateral than withdrawable should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  function test_borrowerCanWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_cannotCloseIfDebtIsNonZero() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow); }  function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));     borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));     // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));      try borrower.close(_id) {         revert('Borrower should not be able to close with non-zero debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  function test_lenderCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin)); }  function assert_invalidActorCannotClose(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, request.minBorrowAmount);      if (_actor == address(admin)) {         try admin.close(_id) {             revert('Admin should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.close(_id) {             revert('Invalid actor should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanRepayAndClose() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanRepayAndClose(_id, _amountToBorrow); }  function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(_id, _currentDebt);      _currentDebt = pcl.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0);      borrower.close(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED); }  function test_repayWithInsufficientBalance() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));     try borrower.repay(_id, _currentDebt) {         revert('REVERT: Insufficient Balance');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds allowance');         } else {             assertEq(reason, 'Dai/insufficient-allowance');         }     } }  function test_borrowerCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower)); }  function test_adminCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;     emit log_named_uint('request.borrowLimit', request.borrowLimit);     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin)); }  function assert_InvalidActorCannotLiquidate(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      if (_actor == address(admin)) {         try admin.liquidate(_id, true) {             revert('admin liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.liquidate(_id, true) {             revert('Invalid actor liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } }  function test_onlyLendersCanLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit / 3;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyLendersCanLiquidate(_id, _amountToBorrow); }  function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {     if (request.collateralRatio == 0) return;     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      PCLUser _lender = PCLUser(lenders[1].lenderAddress);     uint256 _amountLent = lenders[1].amount;     _lender.liquidate(_id, true);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_lenderCannotLiquidateZeroPrincipal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with zero principal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, _amountToBorrow / 2);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with if collateral ratio is more than ideal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  function test_borrowerCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotTerminate(_id); }  function assert_borrowerCannotTerminate(uint256 _id) public {     try borrower.terminate(_id) {         revert('Borrower terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_lenderCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotTerminate(_id); }  function assert_lenderCannotTerminate(uint256 _id) public {     PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));     try _lender.terminate(_id) {         revert('Lender terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_onlyAdminCanTerminate() public {     uint256 _amountToBorrow = request.borrowLimit;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyAdminCanTerminate(_id, _amountToBorrow); }  function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));     vm.roll(block.number + (request.duration / (2 * 20)));      uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));     admin.terminate(_id);     uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     } else {         assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     }     if (request.borrowAssetStrategy == compoundYieldAddress) {         assertGe(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } else {         assertEq(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } }  function test_depositCollateral() public {     uint256 _amount = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositCollateral(_id, _amount); }  function assert_depositCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());     admin.transferToken(address(collateralAsset), address(borrower), _amount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);     borrower.depositCollateral(_id, _amount, false);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));     assertEq(pcl.depositedCollateralInShares(_id), _shares); }  function test_depositCollateral_insufficientBalance() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);      admin.transferToken(address(collateralAsset), address(borrower), 10);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);     try borrower.depositCollateral(_id, 100, false) {         revert('Insufficient Balance of collateral tokens');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds balance');         } else {             assertEq(reason, 'SafeERC20: low-level call failed');         }     } }  function test_depositZeroCollateral() public {     uint256 _amount = 0;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositZeroCollateral(_id, _amount); }  function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));     borrower.setAllowance(         pooledCreditLineAddress,         address(collateralAsset),         100_000 * (10**ERC20(address(collateralAsset)).decimals())     );     try borrower.depositCollateral(_id, _amount, false) {         revert('Depositing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC1');     } }  function test_depositCollateralFromSavingsAccount() public {     request.collateralAssetStrategy = compoundYieldAddress;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));     emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);     if (request.collateralRatio != 0) {         borrower.depositToSavingsAccount(             savingsAccountAddress,             _collateralRequired,             address(collateralAsset),             compoundYieldAddress,             address(borrower)         );     }     uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));     emit log_named_uint('total tokens: ', _totalTokens);     uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);     emit log_named_uint('required collateral: ', _collateralRequired);     borrower.setAllowanceForSavingsAccount(         savingsAccountAddress,         _collateralRequired,         address(collateralAsset),         pooledCreditLineAddress     );     _helperDepositCollateral(borrower, _id, _collateralRequired, true);     uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);     emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);     // assertEq(_borrowAbleAmount, _amountToBorrow);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, true);     }     uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);     uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         pooledCreditLineAddress,         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);     assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14); }  function test_adminCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, address(admin)); }  function test_lenderCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress); }  function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {     if (_actor == address(admin)) {         try admin.cancelRequest(_id) {             revert('Admin cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);         try _user.cancelRequest(_id) {             revert('Invalid actor cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotCancelRequest() public {     assert_borrowerCannotCancelRequest(requestId); }  function assert_borrowerCannotCancelRequest(uint256 _id) public {     try borrower.cancelRequest(_id) {         revert('Canceling a PCL in active stage should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow); }  function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay zero current debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP3');     } }  function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow); }  function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay if interest is zero');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP4');     } }  function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     try _lender.transferLPTokens(address(borrower), _id, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_borrowerCannotReceivePoolTokens() public {     assert_borrowerCannotReceivePoolTokens(requestId);     request.borrowerVerifier = mockAdminVerifier1;     borrower.registerSelf(mockAdminVerifier1);     (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);     assert_borrowerCannotReceivePoolTokens(_id); }  function assert_canTransferPoolTokensToVerifiedUser(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     // borrowing some tokens     {         uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());         uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;         uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);         admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);         borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);         _helperDepositCollateral(borrower, _id, _collateralRequired, false);         borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);          // going ahead in time to generate interest         vm.warp(block.timestamp + 6 days);         // repaying the interest and some principal back         borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);         borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);     }      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender     _lender.withdrawInterest(_id);      uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     // calculating the receivers interest in shares     uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);     uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         receiverInterestInTokens,         address(borrowAsset)     );      uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);     _lender.transferLPTokens(_recevingAddress, _id, _amount);      uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);     assertEq(_finalBalance - _prevBalance, _amount);      uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;     curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;     assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14); }  function assert_cannotTransferEcxessPoolTokens(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _id, _amount) {         revert('balance less than the amount to transfer');     } catch Error(string memory reason) {         // assertEq(reason, 'ERC1155: insufficient balance for transfer');         assertEq(reason, 'SafeMath: subtraction overflow');     } }  function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     // testing when user is not verified     try _lender.transferLPTokens(_newUserAddress, _id, _balance) {         revert('should not have been possible to send LP tokens to not verified user');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT3');     } }  function test_lenderTransfersTokenToAnotherLender() public {     LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     address _recevingAddress = lenders[1].lenderAddress;     assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);     assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance); }  function test_lenderTransferTokenToNewUser() public {     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));      // testing when user is verified     _newUser.registerSelf(mockAdminVerifier1);      LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);      assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3); }  function test_areTokensTransferable() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     LenderInfo memory _lenderInfo = lenders[0];      address _recevingAddress = lenders[1].lenderAddress;     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  function test_canTransferPoolTokensWhenZeroInterest() public {     PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);     assertGe(_startBalanceLenderFrom, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);      PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);     uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);     assertGe(_startBalanceLenderTo, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);      _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);     assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));     assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo)); }  function test_cannotWithdrawZeroInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);      // cannot withdraw zero interest     vm.expectRevert(bytes('LP:WI1'));     _lender.withdrawInterest(requestId); }  function test_newPoolTokenHolderCanWithdrawInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _newUser.registerSelf(mockAdminVerifier1);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     _lender.transferLPTokens(address(_newUser), requestId, _balance);     uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);     assertEq(_newUserBalance, _balance);     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repaying the interest and some principal back     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // fetch borrowerInterestSharesWithdrawn for new user     uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     assertEq(_prevBISW, 0);     // get the interest for the new user     uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));     uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser     _newUser.withdrawInterest(requestId);     uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;     // match the interest shares withdrawn with the interest calculated     assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14); }  function test_stateAfterBorrow() public {     admin.updateProtocolFeeFraction(0);      uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('borrowable amount', _borrowableAmount);     assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);      uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));     borrower.borrow(requestId, _borrowableAmount);     uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));      assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);     assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14); }  function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());     _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     emit log_named_uint('_collateralRequired: ', _collateralRequired);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     // borrow some amount     uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());     if (_curBorrowAmount == _amountToBorrow) {         _curBorrowAmount = _curBorrowAmount.mul(90).div(100);     }     borrower.borrow(requestId, _curBorrowAmount);     // check borrow able amount     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     if (request.collateralRatio != 0) {         assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);     } else {         assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);     }     // now check withdrawableCollateral     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);     assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14); }  function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction); }  function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {     _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);     assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount)); }  function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {     if (request.collateralRatio == 0) return;     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);     uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));     emit log_named_uint('_maxCollateral: ', _maxCollateral);     emit log_named_uint('_minCollateral: ', _minCollateral);     _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);     emit log_named_uint('_collateralAmount: ', _collateralAmount);     _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);     emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);     // calulating what should borrowed to achieve _collateralRatioToAchieve     uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(         _collateralRatioToAchieve     );     emit log_named_uint('_amountToBorrow: ', _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);      uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('_maxBorrowable: ', _maxBorrowable);     if (         request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14     ) {         assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);         if (_amountToBorrow &gt; _maxBorrowable) {             _amountToBorrow = _maxBorrowable;         }     } else {         assertLe(_amountToBorrow, _maxBorrowable);     }      borrower.borrow(requestId, _amountToBorrow);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);      uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);     // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve     assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14); }  function test_closeActivePCLOncePrincipalPaidAndEnded() public {     // borrowing some tokens     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repay everything back     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _balance = borrowAsset.balanceOf(address(borrower));     if (_currentDebt &gt; _balance) {         admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));     }     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);     // go to end of pcl     vm.warp(block.timestamp + request.collectionPeriod + request.duration);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);     assertEq(0, borrowAsset.balanceOf(address(borrower))); }  event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);  function test_closeWhenNoCollateral() public {     vm.warp(block.timestamp + 6 days);     // close     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_closeWhenCollateral() public {     uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();     admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     vm.warp(block.timestamp + 6 days);     vm.roll(block.number + (6 * 86400) / 20);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));     vm.expectEmit(true, true, false, false);     emit CollateralSharesWithdrawn(requestId, _shares);     // close     borrower.close(requestId);     // this is equal only when no yield is used     // with compund this should be assertLe becuase deposited collateral would earn yield     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } else {         assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } }  event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare); event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);  function test_withdrawLiquidatedCollateral() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable.sub(10));     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable.sub(10),         address(borrowAsset)     );     // going ahead in time to make liquidation possible     vm.warp(block.timestamp + 50 days);     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);      uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;      vm.expectEmit(true, true, false, false);     emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } else {         assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } }  event PooledCreditLineTerminated(uint256 indexed id);  function test_terminateAfterLiquidation() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable);     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable,         address(borrowAsset)     );      // going ahead in time to make liquidation possible     vm.warp(block.timestamp + request.duration.mul(7).div(11));     vm.roll(block.number + request.duration.mul(7).div(11).div(20));     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;     vm.expectEmit(true, true, false, false);      emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);      uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));      uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));     emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);     // for an active pcl borrowLimit == total amount lent     _totalSupply = lp.totalSupply(requestId);     // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);     // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);     // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);      // now the admin terminates     vm.expectEmit(true, true, false, true);     emit PooledCreditLineTerminated(requestId);     admin.terminate(requestId);      assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));      if (request.borrowAssetStrategy == compoundYieldAddress) {         // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } else {         // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } }  function _helperDepositCollateral(     PCLUser _user,     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) private {     if (_amount != 0) {         _user.depositCollateral(_id, _amount, _fromSavingsAccount);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:26:32 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:26:35 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:26:35 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 34867
completion_tokens: 1
total_tokens: 34868
cost: $-1.000000


[2024-27-08 09:26:35 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
.]

###

[2024-27-08 09:26:35 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:26:35 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-27-08 09:26:35 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStage is PCLParent {     using SafeMath for uint256;     using SafeMath for uint128; uint256 requestId;  // enum PooledCreditLineStatus { //     NOT_CREATED, //     REQUESTED, //     ACTIVE, //     CLOSED, //     EXPIRED, //     LIQUIDATED, //     CANCELLED // }  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE); }  function test_cannotStartActivePCL() public {     try borrower.start(requestId) {         revert('cannot start active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     // verified using the borrower verifier instead of lender verifier     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_nonLenderCannotWithdrawLiquidity() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);     try _pooledCreditLineLender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL1');     } }  function test_lenderCannotWithdrawLiquidity() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotLendToActivePCL() public {     LenderInfo memory info = lenders[0];     PCLUser lender = PCLUser(info.lenderAddress);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendToActivePCLNewLender() public {     // Creating a new lender for lending     PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     lender.registerSelf(mockAdminVerifier1);     admin.transferToken(request.borrowAsset, address(lender), 100_000);     lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin)); }  function test_onlyBorrowerCanBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;     PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker)); }  function assert_borrowByInvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _user = PCLUser(_actor);     if (_actor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try admin.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try _user.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotBorrowMoreThanPossible() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);      try borrower.borrow(_id, _amountBorrowable + 1) {         revert('Borrower should not be able to borrow more than possible');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB3');     } }  function test_borrowerCannotBorrowZeroAmount() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.borrow(_id, 0) {         revert('Borrower should not be able to borrow zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB1');     } }  function test_lenderDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress); }  function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress); }  function test_adminDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin)); }  function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin)); }  function assert_DepositAndCannotWithdrawCollateral_InvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _depositor,     address _withdrawer ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      // Depositing into PCL     if (_depositor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     } else {         PCLUser _user = PCLUser(_depositor);          admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     }      // withdrawing from PCL     if (_withdrawer == address(admin)) {         try admin.withdrawCollateral(_id, _collateralRequired, false) {             revert('Admin should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_withdrawer);          try _user.withdrawCollateral(_id, _collateralRequired, false) {             revert('Invalid actor should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     if (request.collateralRatio != 0) {         borrower.withdrawCollateral(_id, _withdrawableCollateral, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_lenderDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);     _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(_lender, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try _lender.withdrawAllCollateral(_id, false) {         revert('lender should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_adminDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(admin, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try admin.withdrawAllCollateral(_id, false) {         revert('admin should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_borrowerCannotWithdrawZeroAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     try borrower.withdrawAllCollateral(_id, false) {         revert('borrower should not be able to withdraw zero all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  function test_borrowerCannotWithdrawZeroCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try borrower.withdrawCollateral(_id, 0, false) {         revert('Withdrawing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC2');     } }  function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);      try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {         revert('Withdrawing more collateral than withdrawable should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  function test_borrowerCanWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_cannotCloseIfDebtIsNonZero() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow); }  function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));     borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));     // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));      try borrower.close(_id) {         revert('Borrower should not be able to close with non-zero debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  function test_lenderCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin)); }  function assert_invalidActorCannotClose(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, request.minBorrowAmount);      if (_actor == address(admin)) {         try admin.close(_id) {             revert('Admin should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.close(_id) {             revert('Invalid actor should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanRepayAndClose() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanRepayAndClose(_id, _amountToBorrow); }  function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(_id, _currentDebt);      _currentDebt = pcl.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0);      borrower.close(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED); }  function test_repayWithInsufficientBalance() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));     try borrower.repay(_id, _currentDebt) {         revert('REVERT: Insufficient Balance');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds allowance');         } else {             assertEq(reason, 'Dai/insufficient-allowance');         }     } }  function test_borrowerCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower)); }  function test_adminCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;     emit log_named_uint('request.borrowLimit', request.borrowLimit);     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin)); }  function assert_InvalidActorCannotLiquidate(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      if (_actor == address(admin)) {         try admin.liquidate(_id, true) {             revert('admin liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.liquidate(_id, true) {             revert('Invalid actor liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } }  function test_onlyLendersCanLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit / 3;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyLendersCanLiquidate(_id, _amountToBorrow); }  function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {     if (request.collateralRatio == 0) return;     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      PCLUser _lender = PCLUser(lenders[1].lenderAddress);     uint256 _amountLent = lenders[1].amount;     _lender.liquidate(_id, true);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_lenderCannotLiquidateZeroPrincipal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with zero principal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, _amountToBorrow / 2);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with if collateral ratio is more than ideal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  function test_borrowerCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotTerminate(_id); }  function assert_borrowerCannotTerminate(uint256 _id) public {     try borrower.terminate(_id) {         revert('Borrower terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_lenderCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotTerminate(_id); }  function assert_lenderCannotTerminate(uint256 _id) public {     PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));     try _lender.terminate(_id) {         revert('Lender terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_onlyAdminCanTerminate() public {     uint256 _amountToBorrow = request.borrowLimit;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyAdminCanTerminate(_id, _amountToBorrow); }  function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));     vm.roll(block.number + (request.duration / (2 * 20)));      uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));     admin.terminate(_id);     uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     } else {         assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     }     if (request.borrowAssetStrategy == compoundYieldAddress) {         assertGe(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } else {         assertEq(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } }  function test_depositCollateral() public {     uint256 _amount = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositCollateral(_id, _amount); }  function assert_depositCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());     admin.transferToken(address(collateralAsset), address(borrower), _amount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);     borrower.depositCollateral(_id, _amount, false);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));     assertEq(pcl.depositedCollateralInShares(_id), _shares); }  function test_depositCollateral_insufficientBalance() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);      admin.transferToken(address(collateralAsset), address(borrower), 10);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);     try borrower.depositCollateral(_id, 100, false) {         revert('Insufficient Balance of collateral tokens');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds balance');         } else {             assertEq(reason, 'SafeERC20: low-level call failed');         }     } }  function test_depositZeroCollateral() public {     uint256 _amount = 0;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositZeroCollateral(_id, _amount); }  function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));     borrower.setAllowance(         pooledCreditLineAddress,         address(collateralAsset),         100_000 * (10**ERC20(address(collateralAsset)).decimals())     );     try borrower.depositCollateral(_id, _amount, false) {         revert('Depositing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC1');     } }  function test_depositCollateralFromSavingsAccount() public {     request.collateralAssetStrategy = compoundYieldAddress;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));     emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);     if (request.collateralRatio != 0) {         borrower.depositToSavingsAccount(             savingsAccountAddress,             _collateralRequired,             address(collateralAsset),             compoundYieldAddress,             address(borrower)         );     }     uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));     emit log_named_uint('total tokens: ', _totalTokens);     uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);     emit log_named_uint('required collateral: ', _collateralRequired);     borrower.setAllowanceForSavingsAccount(         savingsAccountAddress,         _collateralRequired,         address(collateralAsset),         pooledCreditLineAddress     );     _helperDepositCollateral(borrower, _id, _collateralRequired, true);     uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);     emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);     // assertEq(_borrowAbleAmount, _amountToBorrow);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, true);     }     uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);     uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         pooledCreditLineAddress,         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);     assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14); }  function test_adminCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, address(admin)); }  function test_lenderCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress); }  function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {     if (_actor == address(admin)) {         try admin.cancelRequest(_id) {             revert('Admin cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);         try _user.cancelRequest(_id) {             revert('Invalid actor cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotCancelRequest() public {     assert_borrowerCannotCancelRequest(requestId); }  function assert_borrowerCannotCancelRequest(uint256 _id) public {     try borrower.cancelRequest(_id) {         revert('Canceling a PCL in active stage should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow); }  function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay zero current debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP3');     } }  function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow); }  function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay if interest is zero');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP4');     } }  function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     try _lender.transferLPTokens(address(borrower), _id, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_borrowerCannotReceivePoolTokens() public {     assert_borrowerCannotReceivePoolTokens(requestId);     request.borrowerVerifier = mockAdminVerifier1;     borrower.registerSelf(mockAdminVerifier1);     (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);     assert_borrowerCannotReceivePoolTokens(_id); }  function assert_canTransferPoolTokensToVerifiedUser(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     // borrowing some tokens     {         uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());         uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;         uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);         admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);         borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);         _helperDepositCollateral(borrower, _id, _collateralRequired, false);         borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);          // going ahead in time to generate interest         vm.warp(block.timestamp + 6 days);         // repaying the interest and some principal back         borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);         borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);     }      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender     _lender.withdrawInterest(_id);      uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     // calculating the receivers interest in shares     uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);     uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         receiverInterestInTokens,         address(borrowAsset)     );      uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);     _lender.transferLPTokens(_recevingAddress, _id, _amount);      uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);     assertEq(_finalBalance - _prevBalance, _amount);      uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;     curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;     assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14); }  function assert_cannotTransferEcxessPoolTokens(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _id, _amount) {         revert('balance less than the amount to transfer');     } catch Error(string memory reason) {         // assertEq(reason, 'ERC1155: insufficient balance for transfer');         assertEq(reason, 'SafeMath: subtraction overflow');     } }  function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     // testing when user is not verified     try _lender.transferLPTokens(_newUserAddress, _id, _balance) {         revert('should not have been possible to send LP tokens to not verified user');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT3');     } }  function test_lenderTransfersTokenToAnotherLender() public {     LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     address _recevingAddress = lenders[1].lenderAddress;     assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);     assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance); }  function test_lenderTransferTokenToNewUser() public {     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));      // testing when user is verified     _newUser.registerSelf(mockAdminVerifier1);      LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);      assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3); }  function test_areTokensTransferable() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     LenderInfo memory _lenderInfo = lenders[0];      address _recevingAddress = lenders[1].lenderAddress;     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  function test_canTransferPoolTokensWhenZeroInterest() public {     PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);     assertGe(_startBalanceLenderFrom, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);      PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);     uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);     assertGe(_startBalanceLenderTo, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);      _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);     assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));     assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo)); }  function test_cannotWithdrawZeroInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);      // cannot withdraw zero interest     vm.expectRevert(bytes('LP:WI1'));     _lender.withdrawInterest(requestId); }  function test_newPoolTokenHolderCanWithdrawInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _newUser.registerSelf(mockAdminVerifier1);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     _lender.transferLPTokens(address(_newUser), requestId, _balance);     uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);     assertEq(_newUserBalance, _balance);     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repaying the interest and some principal back     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // fetch borrowerInterestSharesWithdrawn for new user     uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     assertEq(_prevBISW, 0);     // get the interest for the new user     uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));     uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser     _newUser.withdrawInterest(requestId);     uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;     // match the interest shares withdrawn with the interest calculated     assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14); }  function test_stateAfterBorrow() public {     admin.updateProtocolFeeFraction(0);      uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('borrowable amount', _borrowableAmount);     assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);      uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));     borrower.borrow(requestId, _borrowableAmount);     uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));      assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);     assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14); }  function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());     _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     emit log_named_uint('_collateralRequired: ', _collateralRequired);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     // borrow some amount     uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());     if (_curBorrowAmount == _amountToBorrow) {         _curBorrowAmount = _curBorrowAmount.mul(90).div(100);     }     borrower.borrow(requestId, _curBorrowAmount);     // check borrow able amount     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     if (request.collateralRatio != 0) {         assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);     } else {         assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);     }     // now check withdrawableCollateral     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);     assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14); }  function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction); }  function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {     _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);     assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount)); }  function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {     if (request.collateralRatio == 0) return;     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);     uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));     emit log_named_uint('_maxCollateral: ', _maxCollateral);     emit log_named_uint('_minCollateral: ', _minCollateral);     _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);     emit log_named_uint('_collateralAmount: ', _collateralAmount);     _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);     emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);     // calulating what should borrowed to achieve _collateralRatioToAchieve     uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(         _collateralRatioToAchieve     );     emit log_named_uint('_amountToBorrow: ', _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);      uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('_maxBorrowable: ', _maxBorrowable);     if (         request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14     ) {         assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);         if (_amountToBorrow &gt; _maxBorrowable) {             _amountToBorrow = _maxBorrowable;         }     } else {         assertLe(_amountToBorrow, _maxBorrowable);     }      borrower.borrow(requestId, _amountToBorrow);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);      uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);     // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve     assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14); }  function test_closeActivePCLOncePrincipalPaidAndEnded() public {     // borrowing some tokens     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repay everything back     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _balance = borrowAsset.balanceOf(address(borrower));     if (_currentDebt &gt; _balance) {         admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));     }     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);     // go to end of pcl     vm.warp(block.timestamp + request.collectionPeriod + request.duration);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);     assertEq(0, borrowAsset.balanceOf(address(borrower))); }  event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);  function test_closeWhenNoCollateral() public {     vm.warp(block.timestamp + 6 days);     // close     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_closeWhenCollateral() public {     uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();     admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     vm.warp(block.timestamp + 6 days);     vm.roll(block.number + (6 * 86400) / 20);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));     vm.expectEmit(true, true, false, false);     emit CollateralSharesWithdrawn(requestId, _shares);     // close     borrower.close(requestId);     // this is equal only when no yield is used     // with compund this should be assertLe becuase deposited collateral would earn yield     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } else {         assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } }  event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare); event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);  function test_withdrawLiquidatedCollateral() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable.sub(10));     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable.sub(10),         address(borrowAsset)     );     // going ahead in time to make liquidation possible     vm.warp(block.timestamp + 50 days);     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);      uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;      vm.expectEmit(true, true, false, false);     emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } else {         assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } }  event PooledCreditLineTerminated(uint256 indexed id);  function test_terminateAfterLiquidation() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable);     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable,         address(borrowAsset)     );      // going ahead in time to make liquidation possible     vm.warp(block.timestamp + request.duration.mul(7).div(11));     vm.roll(block.number + request.duration.mul(7).div(11).div(20));     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;     vm.expectEmit(true, true, false, false);      emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);      uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));      uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));     emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);     // for an active pcl borrowLimit == total amount lent     _totalSupply = lp.totalSupply(requestId);     // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);     // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);     // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);      // now the admin terminates     vm.expectEmit(true, true, false, true);     emit PooledCreditLineTerminated(requestId);     admin.terminate(requestId);      assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));      if (request.borrowAssetStrategy == compoundYieldAddress) {         // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } else {         // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } }  function _helperDepositCollateral(     PCLUser _user,     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) private {     if (_amount != 0) {         _user.depositCollateral(_id, _amount, _fromSavingsAccount);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:26:35 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStage is PCLParent {     using SafeMath for uint256;     using SafeMath for uint128; uint256 requestId;  // enum PooledCreditLineStatus { //     NOT_CREATED, //     REQUESTED, //     ACTIVE, //     CLOSED, //     EXPIRED, //     LIQUIDATED, //     CANCELLED // }  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE); }  function test_cannotStartActivePCL() public {     try borrower.start(requestId) {         revert('cannot start active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     // verified using the borrower verifier instead of lender verifier     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_nonLenderCannotWithdrawLiquidity() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);     try _pooledCreditLineLender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL1');     } }  function test_lenderCannotWithdrawLiquidity() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotLendToActivePCL() public {     LenderInfo memory info = lenders[0];     PCLUser lender = PCLUser(info.lenderAddress);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendToActivePCLNewLender() public {     // Creating a new lender for lending     PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     lender.registerSelf(mockAdminVerifier1);     admin.transferToken(request.borrowAsset, address(lender), 100_000);     lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin)); }  function test_onlyBorrowerCanBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;     PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker)); }  function assert_borrowByInvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _user = PCLUser(_actor);     if (_actor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try admin.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try _user.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotBorrowMoreThanPossible() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);      try borrower.borrow(_id, _amountBorrowable + 1) {         revert('Borrower should not be able to borrow more than possible');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB3');     } }  function test_borrowerCannotBorrowZeroAmount() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.borrow(_id, 0) {         revert('Borrower should not be able to borrow zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB1');     } }  function test_lenderDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress); }  function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress); }  function test_adminDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin)); }  function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin)); }  function assert_DepositAndCannotWithdrawCollateral_InvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _depositor,     address _withdrawer ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      // Depositing into PCL     if (_depositor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     } else {         PCLUser _user = PCLUser(_depositor);          admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     }      // withdrawing from PCL     if (_withdrawer == address(admin)) {         try admin.withdrawCollateral(_id, _collateralRequired, false) {             revert('Admin should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_withdrawer);          try _user.withdrawCollateral(_id, _collateralRequired, false) {             revert('Invalid actor should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     if (request.collateralRatio != 0) {         borrower.withdrawCollateral(_id, _withdrawableCollateral, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_lenderDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);     _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(_lender, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try _lender.withdrawAllCollateral(_id, false) {         revert('lender should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_adminDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(admin, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try admin.withdrawAllCollateral(_id, false) {         revert('admin should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_borrowerCannotWithdrawZeroAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     try borrower.withdrawAllCollateral(_id, false) {         revert('borrower should not be able to withdraw zero all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  function test_borrowerCannotWithdrawZeroCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try borrower.withdrawCollateral(_id, 0, false) {         revert('Withdrawing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC2');     } }  function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);      try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {         revert('Withdrawing more collateral than withdrawable should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  function test_borrowerCanWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_cannotCloseIfDebtIsNonZero() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow); }  function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));     borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));     // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));      try borrower.close(_id) {         revert('Borrower should not be able to close with non-zero debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  function test_lenderCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin)); }  function assert_invalidActorCannotClose(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, request.minBorrowAmount);      if (_actor == address(admin)) {         try admin.close(_id) {             revert('Admin should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.close(_id) {             revert('Invalid actor should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanRepayAndClose() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanRepayAndClose(_id, _amountToBorrow); }  function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(_id, _currentDebt);      _currentDebt = pcl.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0);      borrower.close(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED); }  function test_repayWithInsufficientBalance() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));     try borrower.repay(_id, _currentDebt) {         revert('REVERT: Insufficient Balance');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds allowance');         } else {             assertEq(reason, 'Dai/insufficient-allowance');         }     } }  function test_borrowerCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower)); }  function test_adminCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;     emit log_named_uint('request.borrowLimit', request.borrowLimit);     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin)); }  function assert_InvalidActorCannotLiquidate(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      if (_actor == address(admin)) {         try admin.liquidate(_id, true) {             revert('admin liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.liquidate(_id, true) {             revert('Invalid actor liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } }  function test_onlyLendersCanLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit / 3;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyLendersCanLiquidate(_id, _amountToBorrow); }  function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {     if (request.collateralRatio == 0) return;     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      PCLUser _lender = PCLUser(lenders[1].lenderAddress);     uint256 _amountLent = lenders[1].amount;     _lender.liquidate(_id, true);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_lenderCannotLiquidateZeroPrincipal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with zero principal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, _amountToBorrow / 2);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with if collateral ratio is more than ideal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  function test_borrowerCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotTerminate(_id); }  function assert_borrowerCannotTerminate(uint256 _id) public {     try borrower.terminate(_id) {         revert('Borrower terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_lenderCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotTerminate(_id); }  function assert_lenderCannotTerminate(uint256 _id) public {     PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));     try _lender.terminate(_id) {         revert('Lender terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_onlyAdminCanTerminate() public {     uint256 _amountToBorrow = request.borrowLimit;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyAdminCanTerminate(_id, _amountToBorrow); }  function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));     vm.roll(block.number + (request.duration / (2 * 20)));      uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));     admin.terminate(_id);     uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     } else {         assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     }     if (request.borrowAssetStrategy == compoundYieldAddress) {         assertGe(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } else {         assertEq(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } }  function test_depositCollateral() public {     uint256 _amount = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositCollateral(_id, _amount); }  function assert_depositCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());     admin.transferToken(address(collateralAsset), address(borrower), _amount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);     borrower.depositCollateral(_id, _amount, false);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));     assertEq(pcl.depositedCollateralInShares(_id), _shares); }  function test_depositCollateral_insufficientBalance() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);      admin.transferToken(address(collateralAsset), address(borrower), 10);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);     try borrower.depositCollateral(_id, 100, false) {         revert('Insufficient Balance of collateral tokens');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds balance');         } else {             assertEq(reason, 'SafeERC20: low-level call failed');         }     } }  function test_depositZeroCollateral() public {     uint256 _amount = 0;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositZeroCollateral(_id, _amount); }  function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));     borrower.setAllowance(         pooledCreditLineAddress,         address(collateralAsset),         100_000 * (10**ERC20(address(collateralAsset)).decimals())     );     try borrower.depositCollateral(_id, _amount, false) {         revert('Depositing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC1');     } }  function test_depositCollateralFromSavingsAccount() public {     request.collateralAssetStrategy = compoundYieldAddress;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));     emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);     if (request.collateralRatio != 0) {         borrower.depositToSavingsAccount(             savingsAccountAddress,             _collateralRequired,             address(collateralAsset),             compoundYieldAddress,             address(borrower)         );     }     uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));     emit log_named_uint('total tokens: ', _totalTokens);     uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);     emit log_named_uint('required collateral: ', _collateralRequired);     borrower.setAllowanceForSavingsAccount(         savingsAccountAddress,         _collateralRequired,         address(collateralAsset),         pooledCreditLineAddress     );     _helperDepositCollateral(borrower, _id, _collateralRequired, true);     uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);     emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);     // assertEq(_borrowAbleAmount, _amountToBorrow);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, true);     }     uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);     uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         pooledCreditLineAddress,         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);     assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14); }  function test_adminCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, address(admin)); }  function test_lenderCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress); }  function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {     if (_actor == address(admin)) {         try admin.cancelRequest(_id) {             revert('Admin cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);         try _user.cancelRequest(_id) {             revert('Invalid actor cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotCancelRequest() public {     assert_borrowerCannotCancelRequest(requestId); }  function assert_borrowerCannotCancelRequest(uint256 _id) public {     try borrower.cancelRequest(_id) {         revert('Canceling a PCL in active stage should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow); }  function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay zero current debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP3');     } }  function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow); }  function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay if interest is zero');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP4');     } }  function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     try _lender.transferLPTokens(address(borrower), _id, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_borrowerCannotReceivePoolTokens() public {     assert_borrowerCannotReceivePoolTokens(requestId);     request.borrowerVerifier = mockAdminVerifier1;     borrower.registerSelf(mockAdminVerifier1);     (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);     assert_borrowerCannotReceivePoolTokens(_id); }  function assert_canTransferPoolTokensToVerifiedUser(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     // borrowing some tokens     {         uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());         uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;         uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);         admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);         borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);         _helperDepositCollateral(borrower, _id, _collateralRequired, false);         borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);          // going ahead in time to generate interest         vm.warp(block.timestamp + 6 days);         // repaying the interest and some principal back         borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);         borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);     }      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender     _lender.withdrawInterest(_id);      uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     // calculating the receivers interest in shares     uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);     uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         receiverInterestInTokens,         address(borrowAsset)     );      uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);     _lender.transferLPTokens(_recevingAddress, _id, _amount);      uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);     assertEq(_finalBalance - _prevBalance, _amount);      uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;     curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;     assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14); }  function assert_cannotTransferEcxessPoolTokens(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _id, _amount) {         revert('balance less than the amount to transfer');     } catch Error(string memory reason) {         // assertEq(reason, 'ERC1155: insufficient balance for transfer');         assertEq(reason, 'SafeMath: subtraction overflow');     } }  function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     // testing when user is not verified     try _lender.transferLPTokens(_newUserAddress, _id, _balance) {         revert('should not have been possible to send LP tokens to not verified user');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT3');     } }  function test_lenderTransfersTokenToAnotherLender() public {     LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     address _recevingAddress = lenders[1].lenderAddress;     assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);     assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance); }  function test_lenderTransferTokenToNewUser() public {     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));      // testing when user is verified     _newUser.registerSelf(mockAdminVerifier1);      LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);      assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3); }  function test_areTokensTransferable() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     LenderInfo memory _lenderInfo = lenders[0];      address _recevingAddress = lenders[1].lenderAddress;     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  function test_canTransferPoolTokensWhenZeroInterest() public {     PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);     assertGe(_startBalanceLenderFrom, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);      PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);     uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);     assertGe(_startBalanceLenderTo, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);      _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);     assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));     assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo)); }  function test_cannotWithdrawZeroInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);      // cannot withdraw zero interest     vm.expectRevert(bytes('LP:WI1'));     _lender.withdrawInterest(requestId); }  function test_newPoolTokenHolderCanWithdrawInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _newUser.registerSelf(mockAdminVerifier1);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     _lender.transferLPTokens(address(_newUser), requestId, _balance);     uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);     assertEq(_newUserBalance, _balance);     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repaying the interest and some principal back     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // fetch borrowerInterestSharesWithdrawn for new user     uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     assertEq(_prevBISW, 0);     // get the interest for the new user     uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));     uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser     _newUser.withdrawInterest(requestId);     uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;     // match the interest shares withdrawn with the interest calculated     assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14); }  function test_stateAfterBorrow() public {     admin.updateProtocolFeeFraction(0);      uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('borrowable amount', _borrowableAmount);     assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);      uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));     borrower.borrow(requestId, _borrowableAmount);     uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));      assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);     assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14); }  function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());     _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     emit log_named_uint('_collateralRequired: ', _collateralRequired);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     // borrow some amount     uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());     if (_curBorrowAmount == _amountToBorrow) {         _curBorrowAmount = _curBorrowAmount.mul(90).div(100);     }     borrower.borrow(requestId, _curBorrowAmount);     // check borrow able amount     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     if (request.collateralRatio != 0) {         assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);     } else {         assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);     }     // now check withdrawableCollateral     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);     assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14); }  function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction); }  function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {     _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);     assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount)); }  function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {     if (request.collateralRatio == 0) return;     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);     uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));     emit log_named_uint('_maxCollateral: ', _maxCollateral);     emit log_named_uint('_minCollateral: ', _minCollateral);     _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);     emit log_named_uint('_collateralAmount: ', _collateralAmount);     _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);     emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);     // calulating what should borrowed to achieve _collateralRatioToAchieve     uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(         _collateralRatioToAchieve     );     emit log_named_uint('_amountToBorrow: ', _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);      uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('_maxBorrowable: ', _maxBorrowable);     if (         request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14     ) {         assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);         if (_amountToBorrow &gt; _maxBorrowable) {             _amountToBorrow = _maxBorrowable;         }     } else {         assertLe(_amountToBorrow, _maxBorrowable);     }      borrower.borrow(requestId, _amountToBorrow);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);      uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);     // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve     assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14); }  function test_closeActivePCLOncePrincipalPaidAndEnded() public {     // borrowing some tokens     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repay everything back     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _balance = borrowAsset.balanceOf(address(borrower));     if (_currentDebt &gt; _balance) {         admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));     }     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);     // go to end of pcl     vm.warp(block.timestamp + request.collectionPeriod + request.duration);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);     assertEq(0, borrowAsset.balanceOf(address(borrower))); }  event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);  function test_closeWhenNoCollateral() public {     vm.warp(block.timestamp + 6 days);     // close     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_closeWhenCollateral() public {     uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();     admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     vm.warp(block.timestamp + 6 days);     vm.roll(block.number + (6 * 86400) / 20);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));     vm.expectEmit(true, true, false, false);     emit CollateralSharesWithdrawn(requestId, _shares);     // close     borrower.close(requestId);     // this is equal only when no yield is used     // with compund this should be assertLe becuase deposited collateral would earn yield     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } else {         assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } }  event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare); event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);  function test_withdrawLiquidatedCollateral() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable.sub(10));     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable.sub(10),         address(borrowAsset)     );     // going ahead in time to make liquidation possible     vm.warp(block.timestamp + 50 days);     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);      uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;      vm.expectEmit(true, true, false, false);     emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } else {         assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } }  event PooledCreditLineTerminated(uint256 indexed id);  function test_terminateAfterLiquidation() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable);     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable,         address(borrowAsset)     );      // going ahead in time to make liquidation possible     vm.warp(block.timestamp + request.duration.mul(7).div(11));     vm.roll(block.number + request.duration.mul(7).div(11).div(20));     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;     vm.expectEmit(true, true, false, false);      emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);      uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));      uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));     emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);     // for an active pcl borrowLimit == total amount lent     _totalSupply = lp.totalSupply(requestId);     // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);     // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);     // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);      // now the admin terminates     vm.expectEmit(true, true, false, true);     emit PooledCreditLineTerminated(requestId);     admin.terminate(requestId);      assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));      if (request.borrowAssetStrategy == compoundYieldAddress) {         // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } else {         // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } }  function _helperDepositCollateral(     PCLUser _user,     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) private {     if (_amount != 0) {         _user.depositCollateral(_id, _amount, _fromSavingsAccount);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:26:35 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:26:38 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:26:38 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 17493
completion_tokens: 1
total_tokens: 17494
cost: $-1.000000


[2024-27-08 09:26:38 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
.]

Based

[2024-27-08 09:26:38 INFO] **[Seminar Conclusion]**:

 Based

[2024-27-08 09:26:38 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-27-08 09:26:39 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStage is PCLParent {     using SafeMath for uint256;     using SafeMath for uint128; uint256 requestId;  // enum PooledCreditLineStatus { //     NOT_CREATED, //     REQUESTED, //     ACTIVE, //     CLOSED, //     EXPIRED, //     LIQUIDATED, //     CANCELLED // }  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE); }  function test_cannotStartActivePCL() public {     try borrower.start(requestId) {         revert('cannot start active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     // verified using the borrower verifier instead of lender verifier     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_nonLenderCannotWithdrawLiquidity() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);     try _pooledCreditLineLender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL1');     } }  function test_lenderCannotWithdrawLiquidity() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotLendToActivePCL() public {     LenderInfo memory info = lenders[0];     PCLUser lender = PCLUser(info.lenderAddress);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendToActivePCLNewLender() public {     // Creating a new lender for lending     PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     lender.registerSelf(mockAdminVerifier1);     admin.transferToken(request.borrowAsset, address(lender), 100_000);     lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin)); }  function test_onlyBorrowerCanBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;     PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker)); }  function assert_borrowByInvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _user = PCLUser(_actor);     if (_actor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try admin.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try _user.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotBorrowMoreThanPossible() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);      try borrower.borrow(_id, _amountBorrowable + 1) {         revert('Borrower should not be able to borrow more than possible');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB3');     } }  function test_borrowerCannotBorrowZeroAmount() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.borrow(_id, 0) {         revert('Borrower should not be able to borrow zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB1');     } }  function test_lenderDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress); }  function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress); }  function test_adminDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin)); }  function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin)); }  function assert_DepositAndCannotWithdrawCollateral_InvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _depositor,     address _withdrawer ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      // Depositing into PCL     if (_depositor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     } else {         PCLUser _user = PCLUser(_depositor);          admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     }      // withdrawing from PCL     if (_withdrawer == address(admin)) {         try admin.withdrawCollateral(_id, _collateralRequired, false) {             revert('Admin should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_withdrawer);          try _user.withdrawCollateral(_id, _collateralRequired, false) {             revert('Invalid actor should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     if (request.collateralRatio != 0) {         borrower.withdrawCollateral(_id, _withdrawableCollateral, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_lenderDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);     _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(_lender, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try _lender.withdrawAllCollateral(_id, false) {         revert('lender should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_adminDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(admin, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try admin.withdrawAllCollateral(_id, false) {         revert('admin should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_borrowerCannotWithdrawZeroAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     try borrower.withdrawAllCollateral(_id, false) {         revert('borrower should not be able to withdraw zero all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  function test_borrowerCannotWithdrawZeroCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try borrower.withdrawCollateral(_id, 0, false) {         revert('Withdrawing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC2');     } }  function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);      try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {         revert('Withdrawing more collateral than withdrawable should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  function test_borrowerCanWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_cannotCloseIfDebtIsNonZero() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow); }  function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));     borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));     // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));      try borrower.close(_id) {         revert('Borrower should not be able to close with non-zero debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  function test_lenderCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin)); }  function assert_invalidActorCannotClose(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, request.minBorrowAmount);      if (_actor == address(admin)) {         try admin.close(_id) {             revert('Admin should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.close(_id) {             revert('Invalid actor should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanRepayAndClose() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanRepayAndClose(_id, _amountToBorrow); }  function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(_id, _currentDebt);      _currentDebt = pcl.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0);      borrower.close(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED); }  function test_repayWithInsufficientBalance() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));     try borrower.repay(_id, _currentDebt) {         revert('REVERT: Insufficient Balance');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds allowance');         } else {             assertEq(reason, 'Dai/insufficient-allowance');         }     } }  function test_borrowerCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower)); }  function test_adminCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;     emit log_named_uint('request.borrowLimit', request.borrowLimit);     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin)); }  function assert_InvalidActorCannotLiquidate(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      if (_actor == address(admin)) {         try admin.liquidate(_id, true) {             revert('admin liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.liquidate(_id, true) {             revert('Invalid actor liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } }  function test_onlyLendersCanLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit / 3;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyLendersCanLiquidate(_id, _amountToBorrow); }  function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {     if (request.collateralRatio == 0) return;     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      PCLUser _lender = PCLUser(lenders[1].lenderAddress);     uint256 _amountLent = lenders[1].amount;     _lender.liquidate(_id, true);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_lenderCannotLiquidateZeroPrincipal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with zero principal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, _amountToBorrow / 2);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with if collateral ratio is more than ideal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  function test_borrowerCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotTerminate(_id); }  function assert_borrowerCannotTerminate(uint256 _id) public {     try borrower.terminate(_id) {         revert('Borrower terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_lenderCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotTerminate(_id); }  function assert_lenderCannotTerminate(uint256 _id) public {     PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));     try _lender.terminate(_id) {         revert('Lender terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_onlyAdminCanTerminate() public {     uint256 _amountToBorrow = request.borrowLimit;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyAdminCanTerminate(_id, _amountToBorrow); }  function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));     vm.roll(block.number + (request.duration / (2 * 20)));      uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));     admin.terminate(_id);     uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     } else {         assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     }     if (request.borrowAssetStrategy == compoundYieldAddress) {         assertGe(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } else {         assertEq(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } }  function test_depositCollateral() public {     uint256 _amount = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositCollateral(_id, _amount); }  function assert_depositCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());     admin.transferToken(address(collateralAsset), address(borrower), _amount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);     borrower.depositCollateral(_id, _amount, false);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));     assertEq(pcl.depositedCollateralInShares(_id), _shares); }  function test_depositCollateral_insufficientBalance() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);      admin.transferToken(address(collateralAsset), address(borrower), 10);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);     try borrower.depositCollateral(_id, 100, false) {         revert('Insufficient Balance of collateral tokens');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds balance');         } else {             assertEq(reason, 'SafeERC20: low-level call failed');         }     } }  function test_depositZeroCollateral() public {     uint256 _amount = 0;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositZeroCollateral(_id, _amount); }  function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));     borrower.setAllowance(         pooledCreditLineAddress,         address(collateralAsset),         100_000 * (10**ERC20(address(collateralAsset)).decimals())     );     try borrower.depositCollateral(_id, _amount, false) {         revert('Depositing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC1');     } }  function test_depositCollateralFromSavingsAccount() public {     request.collateralAssetStrategy = compoundYieldAddress;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));     emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);     if (request.collateralRatio != 0) {         borrower.depositToSavingsAccount(             savingsAccountAddress,             _collateralRequired,             address(collateralAsset),             compoundYieldAddress,             address(borrower)         );     }     uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));     emit log_named_uint('total tokens: ', _totalTokens);     uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);     emit log_named_uint('required collateral: ', _collateralRequired);     borrower.setAllowanceForSavingsAccount(         savingsAccountAddress,         _collateralRequired,         address(collateralAsset),         pooledCreditLineAddress     );     _helperDepositCollateral(borrower, _id, _collateralRequired, true);     uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);     emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);     // assertEq(_borrowAbleAmount, _amountToBorrow);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, true);     }     uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);     uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         pooledCreditLineAddress,         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);     assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14); }  function test_adminCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, address(admin)); }  function test_lenderCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress); }  function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {     if (_actor == address(admin)) {         try admin.cancelRequest(_id) {             revert('Admin cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);         try _user.cancelRequest(_id) {             revert('Invalid actor cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotCancelRequest() public {     assert_borrowerCannotCancelRequest(requestId); }  function assert_borrowerCannotCancelRequest(uint256 _id) public {     try borrower.cancelRequest(_id) {         revert('Canceling a PCL in active stage should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow); }  function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay zero current debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP3');     } }  function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow); }  function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay if interest is zero');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP4');     } }  function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     try _lender.transferLPTokens(address(borrower), _id, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_borrowerCannotReceivePoolTokens() public {     assert_borrowerCannotReceivePoolTokens(requestId);     request.borrowerVerifier = mockAdminVerifier1;     borrower.registerSelf(mockAdminVerifier1);     (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);     assert_borrowerCannotReceivePoolTokens(_id); }  function assert_canTransferPoolTokensToVerifiedUser(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     // borrowing some tokens     {         uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());         uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;         uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);         admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);         borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);         _helperDepositCollateral(borrower, _id, _collateralRequired, false);         borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);          // going ahead in time to generate interest         vm.warp(block.timestamp + 6 days);         // repaying the interest and some principal back         borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);         borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);     }      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender     _lender.withdrawInterest(_id);      uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     // calculating the receivers interest in shares     uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);     uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         receiverInterestInTokens,         address(borrowAsset)     );      uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);     _lender.transferLPTokens(_recevingAddress, _id, _amount);      uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);     assertEq(_finalBalance - _prevBalance, _amount);      uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;     curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;     assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14); }  function assert_cannotTransferEcxessPoolTokens(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _id, _amount) {         revert('balance less than the amount to transfer');     } catch Error(string memory reason) {         // assertEq(reason, 'ERC1155: insufficient balance for transfer');         assertEq(reason, 'SafeMath: subtraction overflow');     } }  function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     // testing when user is not verified     try _lender.transferLPTokens(_newUserAddress, _id, _balance) {         revert('should not have been possible to send LP tokens to not verified user');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT3');     } }  function test_lenderTransfersTokenToAnotherLender() public {     LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     address _recevingAddress = lenders[1].lenderAddress;     assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);     assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance); }  function test_lenderTransferTokenToNewUser() public {     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));      // testing when user is verified     _newUser.registerSelf(mockAdminVerifier1);      LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);      assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3); }  function test_areTokensTransferable() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     LenderInfo memory _lenderInfo = lenders[0];      address _recevingAddress = lenders[1].lenderAddress;     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  function test_canTransferPoolTokensWhenZeroInterest() public {     PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);     assertGe(_startBalanceLenderFrom, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);      PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);     uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);     assertGe(_startBalanceLenderTo, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);      _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);     assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));     assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo)); }  function test_cannotWithdrawZeroInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);      // cannot withdraw zero interest     vm.expectRevert(bytes('LP:WI1'));     _lender.withdrawInterest(requestId); }  function test_newPoolTokenHolderCanWithdrawInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _newUser.registerSelf(mockAdminVerifier1);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     _lender.transferLPTokens(address(_newUser), requestId, _balance);     uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);     assertEq(_newUserBalance, _balance);     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repaying the interest and some principal back     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // fetch borrowerInterestSharesWithdrawn for new user     uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     assertEq(_prevBISW, 0);     // get the interest for the new user     uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));     uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser     _newUser.withdrawInterest(requestId);     uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;     // match the interest shares withdrawn with the interest calculated     assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14); }  function test_stateAfterBorrow() public {     admin.updateProtocolFeeFraction(0);      uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('borrowable amount', _borrowableAmount);     assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);      uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));     borrower.borrow(requestId, _borrowableAmount);     uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));      assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);     assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14); }  function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());     _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     emit log_named_uint('_collateralRequired: ', _collateralRequired);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     // borrow some amount     uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());     if (_curBorrowAmount == _amountToBorrow) {         _curBorrowAmount = _curBorrowAmount.mul(90).div(100);     }     borrower.borrow(requestId, _curBorrowAmount);     // check borrow able amount     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     if (request.collateralRatio != 0) {         assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);     } else {         assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);     }     // now check withdrawableCollateral     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);     assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14); }  function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction); }  function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {     _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);     assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount)); }  function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {     if (request.collateralRatio == 0) return;     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);     uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));     emit log_named_uint('_maxCollateral: ', _maxCollateral);     emit log_named_uint('_minCollateral: ', _minCollateral);     _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);     emit log_named_uint('_collateralAmount: ', _collateralAmount);     _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);     emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);     // calulating what should borrowed to achieve _collateralRatioToAchieve     uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(         _collateralRatioToAchieve     );     emit log_named_uint('_amountToBorrow: ', _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);      uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('_maxBorrowable: ', _maxBorrowable);     if (         request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14     ) {         assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);         if (_amountToBorrow &gt; _maxBorrowable) {             _amountToBorrow = _maxBorrowable;         }     } else {         assertLe(_amountToBorrow, _maxBorrowable);     }      borrower.borrow(requestId, _amountToBorrow);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);      uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);     // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve     assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14); }  function test_closeActivePCLOncePrincipalPaidAndEnded() public {     // borrowing some tokens     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repay everything back     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _balance = borrowAsset.balanceOf(address(borrower));     if (_currentDebt &gt; _balance) {         admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));     }     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);     // go to end of pcl     vm.warp(block.timestamp + request.collectionPeriod + request.duration);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);     assertEq(0, borrowAsset.balanceOf(address(borrower))); }  event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);  function test_closeWhenNoCollateral() public {     vm.warp(block.timestamp + 6 days);     // close     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_closeWhenCollateral() public {     uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();     admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     vm.warp(block.timestamp + 6 days);     vm.roll(block.number + (6 * 86400) / 20);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));     vm.expectEmit(true, true, false, false);     emit CollateralSharesWithdrawn(requestId, _shares);     // close     borrower.close(requestId);     // this is equal only when no yield is used     // with compund this should be assertLe becuase deposited collateral would earn yield     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } else {         assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } }  event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare); event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);  function test_withdrawLiquidatedCollateral() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable.sub(10));     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable.sub(10),         address(borrowAsset)     );     // going ahead in time to make liquidation possible     vm.warp(block.timestamp + 50 days);     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);      uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;      vm.expectEmit(true, true, false, false);     emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } else {         assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } }  event PooledCreditLineTerminated(uint256 indexed id);  function test_terminateAfterLiquidation() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable);     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable,         address(borrowAsset)     );      // going ahead in time to make liquidation possible     vm.warp(block.timestamp + request.duration.mul(7).div(11));     vm.roll(block.number + request.duration.mul(7).div(11).div(20));     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;     vm.expectEmit(true, true, false, false);      emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);      uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));      uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));     emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);     // for an active pcl borrowLimit == total amount lent     _totalSupply = lp.totalSupply(requestId);     // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);     // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);     // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);      // now the admin terminates     vm.expectEmit(true, true, false, true);     emit PooledCreditLineTerminated(requestId);     admin.terminate(requestId);      assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));      if (request.borrowAssetStrategy == compoundYieldAddress) {         // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } else {         // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } }  function _helperDepositCollateral(     PCLUser _user,     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) private {     if (_amount != 0) {         _user.depositCollateral(_id, _amount, _fromSavingsAccount);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLActiveStage is PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n\n    uint256 requestId;\n\n    // enum PooledCreditLineStatus {\n    //     NOT_CREATED,\n    //     REQUESTED,\n    //     ACTIVE,\n    //     CLOSED,\n    //     EXPIRED,\n    //     LIQUIDATED,\n    //     CANCELLED\n    // }\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function test_cannotStartActivePCL() public {\n        try borrower.start(requestId) {\n            revert('cannot start active pcl');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:S1');\n        }\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert('External user cannot create');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert('External user cannot terminate');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert('Lender cannot lend zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L1');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        // verified using the borrower verifier instead of lender verifier\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Unverified lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L2');\n        }\n    }\n\n    function test_nonLenderCannotWithdrawLiquidity() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        try _pooledCreditLineLender.withdrawLiquidity(requestId) {\n            revert('Lender cannot withdraw liquidity');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL1');\n        }\n    }\n\n    function test_lenderCannotWithdrawLiquidity() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.withdrawLiquidity(requestId) {\n            revert('Lender cannot withdraw liquidity');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n    }\n\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert('Non lender cannot withdraw liquidated collateral tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:WLC1');\n        }\n    }\n\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert('Lender cannot withdraw liquidated collateral tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    function test_cannotTransferLPTokensToSameAddress() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert('Lender cannot transfer LP tokens to itself');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT1');\n        }\n    }\n\n    function test_cannotBurnPoolTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert('Lender cannot burn LP tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'ERC1155: transfer to the zero address');\n        }\n    }\n\n    function test_cannotLendToActivePCL() public {\n        LenderInfo memory info = lenders[0];\n        PCLUser lender = PCLUser(info.lenderAddress);\n        try lender.lend(requestId, 100_000) {\n            revert('cannot lend to active pcl');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    function test_cannotLendToActivePCLNewLender() public {\n        // Creating a new lender for lending\n        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        lender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(request.borrowAsset, address(lender), 100_000);\n        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);\n        try lender.lend(requestId, 100_000) {\n            revert('cannot lend to active pcl');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    function test_lenderCannotBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);\n    }\n\n    function test_adminCannotBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));\n    }\n\n    function test_onlyBorrowerCanBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));\n    }\n\n    function assert_borrowByInvalidActor(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        PCLUser _user = PCLUser(_actor);\n        if (_actor == address(admin)) {\n            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n            _helperDepositCollateral(admin, _id, _collateralRequired, false);\n\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n            try admin.borrow(_id, _amountToBorrow) {\n                revert('Invalid user should not be able to borrow');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        } else {\n            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);\n            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n            _helperDepositCollateral(_user, _id, _collateralRequired, false);\n\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n            try _user.borrow(_id, _amountToBorrow) {\n                revert('Invalid user should not be able to borrow');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        }\n    }\n\n    function test_borrowerCannotBorrowMoreThanPossible() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);\n\n        try borrower.borrow(_id, _amountBorrowable + 1) {\n            revert('Borrower should not be able to borrow more than possible');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:IB3');\n        }\n    }\n\n    function test_borrowerCannotBorrowZeroAmount() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        try borrower.borrow(_id, 0) {\n            revert('Borrower should not be able to borrow zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:IB1');\n        }\n    }\n\n    function test_lenderDepositsAndCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);\n    }\n\n    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);\n    }\n\n    function test_adminDepositsAndCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));\n    }\n\n    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));\n    }\n\n    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _depositor,\n        address _withdrawer\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        // Depositing into PCL\n        if (_depositor == address(admin)) {\n            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n            _helperDepositCollateral(admin, _id, _collateralRequired, false);\n\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n        } else {\n            PCLUser _user = PCLUser(_depositor);\n\n            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);\n            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n            _helperDepositCollateral(_user, _id, _collateralRequired, false);\n\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n        }\n\n        // withdrawing from PCL\n        if (_withdrawer == address(admin)) {\n            try admin.withdrawCollateral(_id, _collateralRequired, false) {\n                revert('Admin should not be able to withdraw collateral');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        } else {\n            PCLUser _user = PCLUser(_withdrawer);\n\n            try _user.withdrawCollateral(_id, _collateralRequired, false) {\n                revert('Invalid actor should not be able to withdraw collateral');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        }\n    }\n\n    function test_borrowerCanWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);\n        if (request.collateralRatio != 0) {\n            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);\n        }\n        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);\n    }\n\n    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);\n        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(_lender, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        try _lender.withdrawAllCollateral(_id, false) {\n            revert('lender should not be able to withdraw all collateral');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:OCLB1');\n        }\n    }\n\n    function test_adminDepositsAndCannotWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(admin, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        try admin.withdrawAllCollateral(_id, false) {\n            revert('admin should not be able to withdraw all collateral');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:OCLB1');\n        }\n    }\n\n    function test_borrowerCannotWithdrawZeroAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        try borrower.withdrawAllCollateral(_id, false) {\n            revert('borrower should not be able to withdraw zero all collateral');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WAC1');\n        }\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        try borrower.withdrawCollateral(_id, 0, false) {\n            revert('Withdrawing zero collateral should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC2');\n        }\n    }\n\n    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);\n\n        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {\n            revert('Withdrawing more collateral than withdrawable should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC1');\n        }\n    }\n\n    function test_borrowerCanWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        if (request.collateralRatio != 0) {\n            borrower.withdrawAllCollateral(_id, false);\n        }\n        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);\n    }\n\n    function test_cannotCloseIfDebtIsNonZero() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);\n    }\n\n    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));\n        borrower.borrow(_id, 90_000 * (10ERC20(address(borrowAsset)).decimals()));\n        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));\n\n        try borrower.close(_id) {\n            revert('Borrower should not be able to close with non-zero debt');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C2');\n        }\n    }\n\n    function test_lenderCannotClose() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);\n    }\n\n    function test_adminCannotClose() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));\n    }\n\n    function assert_invalidActorCannotClose(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        borrower.borrow(_id, request.minBorrowAmount);\n\n        if (_actor == address(admin)) {\n            try admin.close(_id) {\n                revert('Admin should not be able to close PCL');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n\n            try _user.close(_id) {\n                revert('Invalid actor should not be able to close PCL');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        }\n    }\n\n    function test_borrowerCanRepayAndClose() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n\n        vm.warp(block.timestamp + (request.duration / 2));\n\n        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(_id, _currentDebt);\n\n        _currentDebt = pcl.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0);\n\n        borrower.close(_id);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_repayWithInsufficientBalance() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n\n        vm.warp(block.timestamp + (request.duration / 2));\n\n        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));\n        try borrower.repay(_id, _currentDebt) {\n            revert('REVERT: Insufficient Balance');\n        } catch Error(string memory reason) {\n            if (!isForked) {\n                assertEq(reason, 'ERC20: transfer amount exceeds allowance');\n            } else {\n                assertEq(reason, 'Dai/insufficient-allowance');\n            }\n        }\n    }\n\n    function test_borrowerCannotLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));\n    }\n\n    function test_adminCannotLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        emit log_named_uint('request.borrowLimit', request.borrowLimit);\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));\n    }\n\n    function assert_InvalidActorCannotLiquidate(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);\n        borrower.borrow(_id, _borrowable);\n\n        vm.warp(block.timestamp + (request.duration / 2));\n\n        if (!isForked) {\n            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);\n        }\n\n        if (_actor == address(admin)) {\n            try admin.liquidate(_id, true) {\n                revert('admin liquidating should revert');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'LP:LIQ1');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n\n            try _user.liquidate(_id, true) {\n                revert('Invalid actor liquidating should revert');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'LP:LIQ1');\n            }\n        }\n    }\n\n    function test_onlyLendersCanLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit / 3;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);\n    }\n\n    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {\n        if (request.collateralRatio == 0) return;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);\n        borrower.borrow(_id, _borrowable);\n\n        vm.warp(block.timestamp + (request.duration / 2));\n\n        if (!isForked) {\n            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);\n        }\n\n        PCLUser _lender = PCLUser(lenders[1].lenderAddress);\n        uint256 _amountLent = lenders[1].amount;\n        _lender.liquidate(_id, true);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_lenderCannotLiquidateZeroPrincipal() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);\n    }\n\n    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        vm.warp(block.timestamp + (request.duration / 2));\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.liquidate(_id, true) {\n            revert('Lender liquidating should revert with zero principal');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L1');\n        }\n    }\n\n    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);\n    }\n\n    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, _amountToBorrow / 2);\n\n        vm.warp(block.timestamp + (request.duration / 2));\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.liquidate(_id, true) {\n            revert('Lender liquidating should revert with if collateral ratio is more than ideal');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    function test_borrowerCannotTerminate() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotTerminate(_id);\n    }\n\n    function assert_borrowerCannotTerminate(uint256 _id) public {\n        try borrower.terminate(_id) {\n            revert('Borrower terminating PCL should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'Ownable: caller is not the owner');\n        }\n    }\n\n    function test_lenderCannotTerminate() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotTerminate(_id);\n    }\n\n    function assert_lenderCannotTerminate(uint256 _id) public {\n        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));\n        try _lender.terminate(_id) {\n            revert('Lender terminating PCL should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'Ownable: caller is not the owner');\n        }\n    }\n\n    function test_onlyAdminCanTerminate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_onlyAdminCanTerminate(_id, _amountToBorrow);\n    }\n\n    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n\n        vm.warp(block.timestamp + (request.duration / 2));\n        vm.roll(block.number + (request.duration / (2 * 20)));\n\n        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));\n        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));\n        admin.terminate(_id);\n        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));\n        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);\n        } else {\n            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);\n        }\n        if (request.borrowAssetStrategy == compoundYieldAddress) {\n            assertGe(\n                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,\n                (request.borrowLimit / 2) - 90_000 * 10(ERC20(address(borrowAsset)).decimals())\n            );\n        } else {\n            assertEq(\n                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,\n                (request.borrowLimit / 2) - 90_000 * 10(ERC20(address(borrowAsset)).decimals())\n            );\n        }\n    }\n\n    function test_depositCollateral() public {\n        uint256 _amount = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_depositCollateral(_id, _amount);\n    }\n\n    function assert_depositCollateral(uint256 _id, uint256 _amount) public {\n        // lender.lend(_id, _amount);\n        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());\n        admin.transferToken(address(collateralAsset), address(borrower), _amount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);\n        borrower.depositCollateral(_id, _amount, false);\n        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));\n        assertEq(pcl.depositedCollateralInShares(_id), _shares);\n    }\n\n    function test_depositCollateral_insufficientBalance() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n\n        admin.transferToken(address(collateralAsset), address(borrower), 10);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);\n        try borrower.depositCollateral(_id, 100, false) {\n            revert('Insufficient Balance of collateral tokens');\n        } catch Error(string memory reason) {\n            if (!isForked) {\n                assertEq(reason, 'ERC20: transfer amount exceeds balance');\n            } else {\n                assertEq(reason, 'SafeERC20: low-level call failed');\n            }\n        }\n    }\n\n    function test_depositZeroCollateral() public {\n        uint256 _amount = 0;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_depositZeroCollateral(_id, _amount);\n    }\n\n    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {\n        // lender.lend(_id, _amount);\n        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10ERC20(address(collateralAsset)).decimals()));\n        borrower.setAllowance(\n            pooledCreditLineAddress,\n            address(collateralAsset),\n            100_000 * (10ERC20(address(collateralAsset)).decimals())\n        );\n        try borrower.depositCollateral(_id, _amount, false) {\n            revert('Depositing zero collateral should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:DC1');\n        }\n    }\n\n    function test_depositCollateralFromSavingsAccount() public {\n        request.collateralAssetStrategy = compoundYieldAddress;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));\n        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);\n        if (request.collateralRatio != 0) {\n            borrower.depositToSavingsAccount(\n                savingsAccountAddress,\n                _collateralRequired,\n                address(collateralAsset),\n                compoundYieldAddress,\n                address(borrower)\n            );\n        }\n        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));\n        emit log_named_uint('total tokens: ', _totalTokens);\n        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            address(borrower),\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);\n        emit log_named_uint('required collateral: ', _collateralRequired);\n        borrower.setAllowanceForSavingsAccount(\n            savingsAccountAddress,\n            _collateralRequired,\n            address(collateralAsset),\n            pooledCreditLineAddress\n        );\n        _helperDepositCollateral(borrower, _id, _collateralRequired, true);\n        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);\n        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);\n        // assertEq(_borrowAbleAmount, _amountToBorrow);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);\n        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.withdrawAllCollateral(_id, true);\n        }\n        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            address(borrower),\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);\n        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            pooledCreditLineAddress,\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);\n        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);\n    }\n\n    function test_adminCannotCancelRequest() public {\n        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));\n    }\n\n    function test_lenderCannotCancelRequest() public {\n        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);\n    }\n\n    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {\n        if (_actor == address(admin)) {\n            try admin.cancelRequest(_id) {\n                revert('Admin cannot cancel PCL');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n            try _user.cancelRequest(_id) {\n                revert('Invalid actor cannot cancel PCL');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        }\n    }\n\n    function test_borrowerCannotCancelRequest() public {\n        assert_borrowerCannotCancelRequest(requestId);\n    }\n\n    function assert_borrowerCannotCancelRequest(uint256 _id) public {\n        try borrower.cancelRequest(_id) {\n            revert('Canceling a PCL in active stage should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {\n        _seed = scaleToRange128(_seed, 1, 10);\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);\n        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        try borrower.repay(_id, 1) {\n            revert('Borrower should not be able to repay zero current debt');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:REP3');\n        }\n    }\n\n    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {\n        _seed = scaleToRange128(_seed, 1, 10);\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);\n        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        uint256 _borrowAssetDecimalScaling = 10(ERC20(address(borrowAsset)).decimals());\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);\n\n        try borrower.repay(_id, 1) {\n            revert('Borrower should not be able to repay if interest is zero');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:REP4');\n        }\n    }\n\n    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);\n        log_named_uint('lender lp balance: ', _balance);\n        try _lender.transferLPTokens(address(borrower), _id, _balance) {\n            revert('should not have been possible to send LP tokens to the borrower');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT2');\n        }\n    }\n\n    function test_borrowerCannotReceivePoolTokens() public {\n        assert_borrowerCannotReceivePoolTokens(requestId);\n        request.borrowerVerifier = mockAdminVerifier1;\n        borrower.registerSelf(mockAdminVerifier1);\n        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);\n        assert_borrowerCannotReceivePoolTokens(_id);\n    }\n\n    function assert_canTransferPoolTokensToVerifiedUser(\n        uint256 _id,\n        address _recevingAddress,\n        uint256 _amount\n    ) public {\n        // borrowing some tokens\n        {\n            uint256 _borrowAssetDecimalScaling = 10(ERC20(address(borrowAsset)).decimals());\n            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;\n            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n            _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);\n\n            // going ahead in time to generate interest\n            vm.warp(block.timestamp + 6 days);\n            // repaying the interest and some principal back\n            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);\n            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);\n        }\n\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender\n        _lender.withdrawInterest(_id);\n\n        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;\n        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;\n        // calculating the receivers interest in shares\n        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);\n        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            receiverInterestInTokens,\n            address(borrowAsset)\n        );\n\n        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);\n        _lender.transferLPTokens(_recevingAddress, _id, _amount);\n\n        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);\n        assertEq(_finalBalance - _prevBalance, _amount);\n\n        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;\n        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;\n        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;\n        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;\n        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);\n    }\n\n    function assert_cannotTransferEcxessPoolTokens(\n        uint256 _id,\n        address _recevingAddress,\n        uint256 _amount\n    ) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {\n            revert('balance less than the amount to transfer');\n        } catch Error(string memory reason) {\n            // assertEq(reason, 'ERC1155: insufficient balance for transfer');\n            assertEq(reason, 'SafeMath: subtraction overflow');\n        }\n    }\n\n    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);\n        log_named_uint('lender lp balance: ', _balance);\n        // testing when user is not verified\n        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {\n            revert('should not have been possible to send LP tokens to not verified user');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT3');\n        }\n    }\n\n    function test_lenderTransfersTokenToAnotherLender() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n        address _recevingAddress = lenders[1].lenderAddress;\n        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);\n        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);\n    }\n\n    function test_lenderTransferTokenToNewUser() public {\n        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));\n\n        // testing when user is verified\n        _newUser.registerSelf(mockAdminVerifier1);\n\n        LenderInfo memory _lenderInfo = lenders[0];\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n\n        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);\n    }\n\n    function test_areTokensTransferable() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        LenderInfo memory _lenderInfo = lenders[0];\n\n        address _recevingAddress = lenders[1].lenderAddress;\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {\n            revert('should not have been possible to send LP tokens to the borrower');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT5');\n        }\n    }\n\n    function test_canTransferPoolTokensWhenZeroInterest() public {\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);\n        assertGe(_startBalanceLenderFrom, 0);\n        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);\n\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);\n        assertGe(_startBalanceLenderTo, 0);\n        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);\n\n        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);\n        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));\n        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));\n    }\n\n    function test_cannotWithdrawZeroInterest() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n\n        // cannot withdraw zero interest\n        vm.expectRevert(bytes('LP:WI1'));\n        _lender.withdrawInterest(requestId);\n    }\n\n    function test_newPoolTokenHolderCanWithdrawInterest() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _newUser.registerSelf(mockAdminVerifier1);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n        _lender.transferLPTokens(address(_newUser), requestId, _balance);\n        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);\n        assertEq(_newUserBalance, _balance);\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        borrower.borrow(requestId, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // going ahead in time to generate interest\n        vm.warp(block.timestamp + 6 days);\n        // repaying the interest and some principal back\n        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        borrower.repay(requestId, 10_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // fetch borrowerInterestSharesWithdrawn for new user\n        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;\n        assertEq(_prevBISW, 0);\n        // get the interest for the new user\n        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));\n        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));\n        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser\n        _newUser.withdrawInterest(requestId);\n        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;\n        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;\n        // match the interest shares withdrawn with the interest calculated\n        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);\n    }\n\n    function test_stateAfterBorrow() public {\n        admin.updateProtocolFeeFraction(0);\n\n        uint256 _amountToBorrow = request.borrowLimit;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        emit log_named_uint('borrowable amount', _borrowableAmount);\n        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);\n\n        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));\n        borrower.borrow(requestId, _borrowableAmount);\n        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));\n\n        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);\n        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);\n    }\n\n    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {\n        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());\n        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        emit log_named_uint('_collateralRequired: ', _collateralRequired);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        // borrow some amount\n        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());\n        if (_curBorrowAmount == _amountToBorrow) {\n            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);\n        }\n        borrower.borrow(requestId, _curBorrowAmount);\n        // check borrow able amount\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        if (request.collateralRatio != 0) {\n            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);\n        } else {\n            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);\n        }\n        // now check withdrawableCollateral\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);\n        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);\n    }\n\n    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {\n        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);\n    }\n\n    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {\n        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10_decimals).div(_ratioOfPrices);\n        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));\n    }\n\n    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {\n        if (request.collateralRatio == 0) return;\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);\n        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10ERC20(address(borrowAsset)).decimals()));\n        emit log_named_uint('_maxCollateral: ', _maxCollateral);\n        emit log_named_uint('_minCollateral: ', _minCollateral);\n        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);\n        emit log_named_uint('_collateralAmount: ', _collateralAmount);\n        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);\n        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);\n        // calulating what should borrowed to achieve _collateralRatioToAchieve\n        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10_decimals).mul(pcl.SCALING_FACTOR()).div(\n            _collateralRatioToAchieve\n        );\n        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);\n        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);\n        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);\n\n        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);\n        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);\n        if (\n            request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14\n        ) {\n            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);\n            if (_amountToBorrow &gt; _maxBorrowable) {\n                _amountToBorrow = _maxBorrowable;\n            }\n        } else {\n            assertLe(_amountToBorrow, _maxBorrowable);\n        }\n\n        borrower.borrow(requestId, _amountToBorrow);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);\n\n        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);\n        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve\n        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);\n    }\n\n    function test_closeActivePCLOncePrincipalPaidAndEnded() public {\n        // borrowing some tokens\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        borrower.borrow(requestId, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // going ahead in time to generate interest\n        vm.warp(block.timestamp + 6 days);\n        // repay everything back\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        uint256 _balance = borrowAsset.balanceOf(address(borrower));\n        if (_currentDebt &gt; _balance) {\n            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));\n        }\n        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n        // go to end of pcl\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n        assertEq(0, borrowAsset.balanceOf(address(borrower)));\n    }\n\n    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);\n\n    function test_closeWhenNoCollateral() public {\n        vm.warp(block.timestamp + 6 days);\n        // close\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_closeWhenCollateral() public {\n        uint256 _collateralAmount = 1e2 * 10ERC20(address(collateralAsset)).decimals();\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);\n        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);\n        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));\n        vm.warp(block.timestamp + 6 days);\n        vm.roll(block.number + (6 * 86400) / 20);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));\n        vm.expectEmit(true, true, false, false);\n        emit CollateralSharesWithdrawn(requestId, _shares);\n        // close\n        borrower.close(requestId);\n        // this is equal only when no yield is used\n        // with compund this should be assertLe becuase deposited collateral would earn yield\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));\n        } else {\n            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));\n        }\n    }\n\n    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);\n    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);\n\n    function test_withdrawLiquidatedCollateral() public {\n        if (request.collateralRatio == 0) return;\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);\n        borrower.borrow(requestId, _borrowable.sub(10));\n        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            request.borrowLimit - _borrowable.sub(10),\n            address(borrowAsset)\n        );\n        // going ahead in time to make liquidation possible\n        vm.warp(block.timestamp + 50 days);\n        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);\n        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));\n\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _totalSupply = lp.totalSupply(requestId);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n\n        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            _principalBorowable,\n            address(borrowAsset)\n        );\n        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +\n            _lenderYieldShares;\n\n        vm.expectEmit(true, true, false, false);\n        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);\n        _lender.liquidate(requestId, true);\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));\n        } else {\n            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));\n        }\n    }\n\n    event PooledCreditLineTerminated(uint256 indexed id);\n\n    function test_terminateAfterLiquidation() public {\n        if (request.collateralRatio == 0) return;\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);\n        borrower.borrow(requestId, _borrowable);\n        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            request.borrowLimit - _borrowable,\n            address(borrowAsset)\n        );\n\n        // going ahead in time to make liquidation possible\n        vm.warp(block.timestamp + request.duration.mul(7).div(11));\n        vm.roll(block.number + request.duration.mul(7).div(11).div(20));\n        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);\n        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));\n\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _totalSupply = lp.totalSupply(requestId);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            _principalBorowable,\n            address(borrowAsset)\n        );\n        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +\n            _lenderYieldShares;\n        vm.expectEmit(true, true, false, false);\n\n        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);\n        _lender.liquidate(requestId, true);\n\n        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));\n\n        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));\n        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);\n        // for an active pcl borrowLimit == total amount lent\n        _totalSupply = lp.totalSupply(requestId);\n        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);\n        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);\n        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);\n\n        // now the admin terminates\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineTerminated(requestId);\n        admin.terminate(requestId);\n\n        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));\n\n        if (request.borrowAssetStrategy == compoundYieldAddress) {\n            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));\n        } else {\n            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));\n        }\n    }\n\n    function _helperDepositCollateral(\n        PCLUser _user,\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) private {\n        if (_amount != 0) {\n            _user.depositCollateral(_id, _amount, _fromSavingsAccount);\n        }\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:26:39 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStage is PCLParent {     using SafeMath for uint256;     using SafeMath for uint128; uint256 requestId;  // enum PooledCreditLineStatus { //     NOT_CREATED, //     REQUESTED, //     ACTIVE, //     CLOSED, //     EXPIRED, //     LIQUIDATED, //     CANCELLED // }  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE); }  function test_cannotStartActivePCL() public {     try borrower.start(requestId) {         revert('cannot start active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     // verified using the borrower verifier instead of lender verifier     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_nonLenderCannotWithdrawLiquidity() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);     try _pooledCreditLineLender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL1');     } }  function test_lenderCannotWithdrawLiquidity() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotLendToActivePCL() public {     LenderInfo memory info = lenders[0];     PCLUser lender = PCLUser(info.lenderAddress);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendToActivePCLNewLender() public {     // Creating a new lender for lending     PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     lender.registerSelf(mockAdminVerifier1);     admin.transferToken(request.borrowAsset, address(lender), 100_000);     lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin)); }  function test_onlyBorrowerCanBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;     PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker)); }  function assert_borrowByInvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _user = PCLUser(_actor);     if (_actor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try admin.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try _user.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotBorrowMoreThanPossible() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);      try borrower.borrow(_id, _amountBorrowable + 1) {         revert('Borrower should not be able to borrow more than possible');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB3');     } }  function test_borrowerCannotBorrowZeroAmount() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.borrow(_id, 0) {         revert('Borrower should not be able to borrow zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB1');     } }  function test_lenderDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress); }  function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress); }  function test_adminDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin)); }  function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin)); }  function assert_DepositAndCannotWithdrawCollateral_InvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _depositor,     address _withdrawer ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      // Depositing into PCL     if (_depositor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     } else {         PCLUser _user = PCLUser(_depositor);          admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     }      // withdrawing from PCL     if (_withdrawer == address(admin)) {         try admin.withdrawCollateral(_id, _collateralRequired, false) {             revert('Admin should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_withdrawer);          try _user.withdrawCollateral(_id, _collateralRequired, false) {             revert('Invalid actor should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     if (request.collateralRatio != 0) {         borrower.withdrawCollateral(_id, _withdrawableCollateral, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_lenderDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);     _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(_lender, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try _lender.withdrawAllCollateral(_id, false) {         revert('lender should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_adminDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(admin, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try admin.withdrawAllCollateral(_id, false) {         revert('admin should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_borrowerCannotWithdrawZeroAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     try borrower.withdrawAllCollateral(_id, false) {         revert('borrower should not be able to withdraw zero all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  function test_borrowerCannotWithdrawZeroCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try borrower.withdrawCollateral(_id, 0, false) {         revert('Withdrawing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC2');     } }  function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);      try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {         revert('Withdrawing more collateral than withdrawable should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  function test_borrowerCanWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_cannotCloseIfDebtIsNonZero() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow); }  function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));     borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));     // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));      try borrower.close(_id) {         revert('Borrower should not be able to close with non-zero debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  function test_lenderCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin)); }  function assert_invalidActorCannotClose(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, request.minBorrowAmount);      if (_actor == address(admin)) {         try admin.close(_id) {             revert('Admin should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.close(_id) {             revert('Invalid actor should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanRepayAndClose() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanRepayAndClose(_id, _amountToBorrow); }  function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(_id, _currentDebt);      _currentDebt = pcl.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0);      borrower.close(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED); }  function test_repayWithInsufficientBalance() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));     try borrower.repay(_id, _currentDebt) {         revert('REVERT: Insufficient Balance');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds allowance');         } else {             assertEq(reason, 'Dai/insufficient-allowance');         }     } }  function test_borrowerCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower)); }  function test_adminCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;     emit log_named_uint('request.borrowLimit', request.borrowLimit);     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin)); }  function assert_InvalidActorCannotLiquidate(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      if (_actor == address(admin)) {         try admin.liquidate(_id, true) {             revert('admin liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.liquidate(_id, true) {             revert('Invalid actor liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } }  function test_onlyLendersCanLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit / 3;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyLendersCanLiquidate(_id, _amountToBorrow); }  function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {     if (request.collateralRatio == 0) return;     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      PCLUser _lender = PCLUser(lenders[1].lenderAddress);     uint256 _amountLent = lenders[1].amount;     _lender.liquidate(_id, true);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_lenderCannotLiquidateZeroPrincipal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with zero principal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, _amountToBorrow / 2);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with if collateral ratio is more than ideal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  function test_borrowerCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotTerminate(_id); }  function assert_borrowerCannotTerminate(uint256 _id) public {     try borrower.terminate(_id) {         revert('Borrower terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_lenderCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotTerminate(_id); }  function assert_lenderCannotTerminate(uint256 _id) public {     PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));     try _lender.terminate(_id) {         revert('Lender terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_onlyAdminCanTerminate() public {     uint256 _amountToBorrow = request.borrowLimit;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyAdminCanTerminate(_id, _amountToBorrow); }  function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));     vm.roll(block.number + (request.duration / (2 * 20)));      uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));     admin.terminate(_id);     uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     } else {         assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     }     if (request.borrowAssetStrategy == compoundYieldAddress) {         assertGe(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } else {         assertEq(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } }  function test_depositCollateral() public {     uint256 _amount = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositCollateral(_id, _amount); }  function assert_depositCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());     admin.transferToken(address(collateralAsset), address(borrower), _amount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);     borrower.depositCollateral(_id, _amount, false);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));     assertEq(pcl.depositedCollateralInShares(_id), _shares); }  function test_depositCollateral_insufficientBalance() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);      admin.transferToken(address(collateralAsset), address(borrower), 10);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);     try borrower.depositCollateral(_id, 100, false) {         revert('Insufficient Balance of collateral tokens');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds balance');         } else {             assertEq(reason, 'SafeERC20: low-level call failed');         }     } }  function test_depositZeroCollateral() public {     uint256 _amount = 0;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositZeroCollateral(_id, _amount); }  function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));     borrower.setAllowance(         pooledCreditLineAddress,         address(collateralAsset),         100_000 * (10**ERC20(address(collateralAsset)).decimals())     );     try borrower.depositCollateral(_id, _amount, false) {         revert('Depositing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC1');     } }  function test_depositCollateralFromSavingsAccount() public {     request.collateralAssetStrategy = compoundYieldAddress;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));     emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);     if (request.collateralRatio != 0) {         borrower.depositToSavingsAccount(             savingsAccountAddress,             _collateralRequired,             address(collateralAsset),             compoundYieldAddress,             address(borrower)         );     }     uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));     emit log_named_uint('total tokens: ', _totalTokens);     uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);     emit log_named_uint('required collateral: ', _collateralRequired);     borrower.setAllowanceForSavingsAccount(         savingsAccountAddress,         _collateralRequired,         address(collateralAsset),         pooledCreditLineAddress     );     _helperDepositCollateral(borrower, _id, _collateralRequired, true);     uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);     emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);     // assertEq(_borrowAbleAmount, _amountToBorrow);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, true);     }     uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);     uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         pooledCreditLineAddress,         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);     assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14); }  function test_adminCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, address(admin)); }  function test_lenderCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress); }  function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {     if (_actor == address(admin)) {         try admin.cancelRequest(_id) {             revert('Admin cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);         try _user.cancelRequest(_id) {             revert('Invalid actor cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotCancelRequest() public {     assert_borrowerCannotCancelRequest(requestId); }  function assert_borrowerCannotCancelRequest(uint256 _id) public {     try borrower.cancelRequest(_id) {         revert('Canceling a PCL in active stage should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow); }  function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay zero current debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP3');     } }  function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow); }  function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay if interest is zero');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP4');     } }  function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     try _lender.transferLPTokens(address(borrower), _id, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_borrowerCannotReceivePoolTokens() public {     assert_borrowerCannotReceivePoolTokens(requestId);     request.borrowerVerifier = mockAdminVerifier1;     borrower.registerSelf(mockAdminVerifier1);     (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);     assert_borrowerCannotReceivePoolTokens(_id); }  function assert_canTransferPoolTokensToVerifiedUser(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     // borrowing some tokens     {         uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());         uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;         uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);         admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);         borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);         _helperDepositCollateral(borrower, _id, _collateralRequired, false);         borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);          // going ahead in time to generate interest         vm.warp(block.timestamp + 6 days);         // repaying the interest and some principal back         borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);         borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);     }      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender     _lender.withdrawInterest(_id);      uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     // calculating the receivers interest in shares     uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);     uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         receiverInterestInTokens,         address(borrowAsset)     );      uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);     _lender.transferLPTokens(_recevingAddress, _id, _amount);      uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);     assertEq(_finalBalance - _prevBalance, _amount);      uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;     curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;     assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14); }  function assert_cannotTransferEcxessPoolTokens(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _id, _amount) {         revert('balance less than the amount to transfer');     } catch Error(string memory reason) {         // assertEq(reason, 'ERC1155: insufficient balance for transfer');         assertEq(reason, 'SafeMath: subtraction overflow');     } }  function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     // testing when user is not verified     try _lender.transferLPTokens(_newUserAddress, _id, _balance) {         revert('should not have been possible to send LP tokens to not verified user');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT3');     } }  function test_lenderTransfersTokenToAnotherLender() public {     LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     address _recevingAddress = lenders[1].lenderAddress;     assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);     assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance); }  function test_lenderTransferTokenToNewUser() public {     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));      // testing when user is verified     _newUser.registerSelf(mockAdminVerifier1);      LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);      assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3); }  function test_areTokensTransferable() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     LenderInfo memory _lenderInfo = lenders[0];      address _recevingAddress = lenders[1].lenderAddress;     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  function test_canTransferPoolTokensWhenZeroInterest() public {     PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);     assertGe(_startBalanceLenderFrom, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);      PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);     uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);     assertGe(_startBalanceLenderTo, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);      _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);     assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));     assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo)); }  function test_cannotWithdrawZeroInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);      // cannot withdraw zero interest     vm.expectRevert(bytes('LP:WI1'));     _lender.withdrawInterest(requestId); }  function test_newPoolTokenHolderCanWithdrawInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _newUser.registerSelf(mockAdminVerifier1);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     _lender.transferLPTokens(address(_newUser), requestId, _balance);     uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);     assertEq(_newUserBalance, _balance);     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repaying the interest and some principal back     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // fetch borrowerInterestSharesWithdrawn for new user     uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     assertEq(_prevBISW, 0);     // get the interest for the new user     uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));     uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser     _newUser.withdrawInterest(requestId);     uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;     // match the interest shares withdrawn with the interest calculated     assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14); }  function test_stateAfterBorrow() public {     admin.updateProtocolFeeFraction(0);      uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('borrowable amount', _borrowableAmount);     assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);      uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));     borrower.borrow(requestId, _borrowableAmount);     uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));      assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);     assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14); }  function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());     _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     emit log_named_uint('_collateralRequired: ', _collateralRequired);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     // borrow some amount     uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());     if (_curBorrowAmount == _amountToBorrow) {         _curBorrowAmount = _curBorrowAmount.mul(90).div(100);     }     borrower.borrow(requestId, _curBorrowAmount);     // check borrow able amount     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     if (request.collateralRatio != 0) {         assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);     } else {         assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);     }     // now check withdrawableCollateral     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);     assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14); }  function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction); }  function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {     _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);     assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount)); }  function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {     if (request.collateralRatio == 0) return;     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);     uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));     emit log_named_uint('_maxCollateral: ', _maxCollateral);     emit log_named_uint('_minCollateral: ', _minCollateral);     _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);     emit log_named_uint('_collateralAmount: ', _collateralAmount);     _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);     emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);     // calulating what should borrowed to achieve _collateralRatioToAchieve     uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(         _collateralRatioToAchieve     );     emit log_named_uint('_amountToBorrow: ', _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);      uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('_maxBorrowable: ', _maxBorrowable);     if (         request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14     ) {         assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);         if (_amountToBorrow &gt; _maxBorrowable) {             _amountToBorrow = _maxBorrowable;         }     } else {         assertLe(_amountToBorrow, _maxBorrowable);     }      borrower.borrow(requestId, _amountToBorrow);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);      uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);     // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve     assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14); }  function test_closeActivePCLOncePrincipalPaidAndEnded() public {     // borrowing some tokens     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repay everything back     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _balance = borrowAsset.balanceOf(address(borrower));     if (_currentDebt &gt; _balance) {         admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));     }     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);     // go to end of pcl     vm.warp(block.timestamp + request.collectionPeriod + request.duration);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);     assertEq(0, borrowAsset.balanceOf(address(borrower))); }  event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);  function test_closeWhenNoCollateral() public {     vm.warp(block.timestamp + 6 days);     // close     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_closeWhenCollateral() public {     uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();     admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     vm.warp(block.timestamp + 6 days);     vm.roll(block.number + (6 * 86400) / 20);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));     vm.expectEmit(true, true, false, false);     emit CollateralSharesWithdrawn(requestId, _shares);     // close     borrower.close(requestId);     // this is equal only when no yield is used     // with compund this should be assertLe becuase deposited collateral would earn yield     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } else {         assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } }  event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare); event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);  function test_withdrawLiquidatedCollateral() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable.sub(10));     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable.sub(10),         address(borrowAsset)     );     // going ahead in time to make liquidation possible     vm.warp(block.timestamp + 50 days);     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);      uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;      vm.expectEmit(true, true, false, false);     emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } else {         assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } }  event PooledCreditLineTerminated(uint256 indexed id);  function test_terminateAfterLiquidation() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable);     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable,         address(borrowAsset)     );      // going ahead in time to make liquidation possible     vm.warp(block.timestamp + request.duration.mul(7).div(11));     vm.roll(block.number + request.duration.mul(7).div(11).div(20));     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;     vm.expectEmit(true, true, false, false);      emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);      uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));      uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));     emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);     // for an active pcl borrowLimit == total amount lent     _totalSupply = lp.totalSupply(requestId);     // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);     // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);     // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);      // now the admin terminates     vm.expectEmit(true, true, false, true);     emit PooledCreditLineTerminated(requestId);     admin.terminate(requestId);      assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));      if (request.borrowAssetStrategy == compoundYieldAddress) {         // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } else {         // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } }  function _helperDepositCollateral(     PCLUser _user,     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) private {     if (_amount != 0) {         _user.depositCollateral(_id, _amount, _fromSavingsAccount);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:26:39 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:26:43 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:26:43 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 34867
completion_tokens: 1
total_tokens: 34868
cost: $-1.000000


[2024-27-08 09:26:43 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
.]

###

[2024-27-08 09:26:43 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:26:43 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-27-08 09:26:43 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStage is PCLParent {     using SafeMath for uint256;     using SafeMath for uint128; uint256 requestId;  // enum PooledCreditLineStatus { //     NOT_CREATED, //     REQUESTED, //     ACTIVE, //     CLOSED, //     EXPIRED, //     LIQUIDATED, //     CANCELLED // }  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE); }  function test_cannotStartActivePCL() public {     try borrower.start(requestId) {         revert('cannot start active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     // verified using the borrower verifier instead of lender verifier     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_nonLenderCannotWithdrawLiquidity() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);     try _pooledCreditLineLender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL1');     } }  function test_lenderCannotWithdrawLiquidity() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotLendToActivePCL() public {     LenderInfo memory info = lenders[0];     PCLUser lender = PCLUser(info.lenderAddress);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendToActivePCLNewLender() public {     // Creating a new lender for lending     PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     lender.registerSelf(mockAdminVerifier1);     admin.transferToken(request.borrowAsset, address(lender), 100_000);     lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin)); }  function test_onlyBorrowerCanBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;     PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker)); }  function assert_borrowByInvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _user = PCLUser(_actor);     if (_actor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try admin.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try _user.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotBorrowMoreThanPossible() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);      try borrower.borrow(_id, _amountBorrowable + 1) {         revert('Borrower should not be able to borrow more than possible');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB3');     } }  function test_borrowerCannotBorrowZeroAmount() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.borrow(_id, 0) {         revert('Borrower should not be able to borrow zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB1');     } }  function test_lenderDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress); }  function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress); }  function test_adminDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin)); }  function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin)); }  function assert_DepositAndCannotWithdrawCollateral_InvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _depositor,     address _withdrawer ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      // Depositing into PCL     if (_depositor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     } else {         PCLUser _user = PCLUser(_depositor);          admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     }      // withdrawing from PCL     if (_withdrawer == address(admin)) {         try admin.withdrawCollateral(_id, _collateralRequired, false) {             revert('Admin should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_withdrawer);          try _user.withdrawCollateral(_id, _collateralRequired, false) {             revert('Invalid actor should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     if (request.collateralRatio != 0) {         borrower.withdrawCollateral(_id, _withdrawableCollateral, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_lenderDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);     _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(_lender, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try _lender.withdrawAllCollateral(_id, false) {         revert('lender should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_adminDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(admin, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try admin.withdrawAllCollateral(_id, false) {         revert('admin should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_borrowerCannotWithdrawZeroAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     try borrower.withdrawAllCollateral(_id, false) {         revert('borrower should not be able to withdraw zero all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  function test_borrowerCannotWithdrawZeroCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try borrower.withdrawCollateral(_id, 0, false) {         revert('Withdrawing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC2');     } }  function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);      try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {         revert('Withdrawing more collateral than withdrawable should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  function test_borrowerCanWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_cannotCloseIfDebtIsNonZero() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow); }  function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));     borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));     // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));      try borrower.close(_id) {         revert('Borrower should not be able to close with non-zero debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  function test_lenderCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin)); }  function assert_invalidActorCannotClose(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, request.minBorrowAmount);      if (_actor == address(admin)) {         try admin.close(_id) {             revert('Admin should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.close(_id) {             revert('Invalid actor should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanRepayAndClose() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanRepayAndClose(_id, _amountToBorrow); }  function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(_id, _currentDebt);      _currentDebt = pcl.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0);      borrower.close(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED); }  function test_repayWithInsufficientBalance() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));     try borrower.repay(_id, _currentDebt) {         revert('REVERT: Insufficient Balance');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds allowance');         } else {             assertEq(reason, 'Dai/insufficient-allowance');         }     } }  function test_borrowerCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower)); }  function test_adminCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;     emit log_named_uint('request.borrowLimit', request.borrowLimit);     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin)); }  function assert_InvalidActorCannotLiquidate(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      if (_actor == address(admin)) {         try admin.liquidate(_id, true) {             revert('admin liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.liquidate(_id, true) {             revert('Invalid actor liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } }  function test_onlyLendersCanLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit / 3;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyLendersCanLiquidate(_id, _amountToBorrow); }  function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {     if (request.collateralRatio == 0) return;     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      PCLUser _lender = PCLUser(lenders[1].lenderAddress);     uint256 _amountLent = lenders[1].amount;     _lender.liquidate(_id, true);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_lenderCannotLiquidateZeroPrincipal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with zero principal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, _amountToBorrow / 2);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with if collateral ratio is more than ideal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  function test_borrowerCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotTerminate(_id); }  function assert_borrowerCannotTerminate(uint256 _id) public {     try borrower.terminate(_id) {         revert('Borrower terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_lenderCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotTerminate(_id); }  function assert_lenderCannotTerminate(uint256 _id) public {     PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));     try _lender.terminate(_id) {         revert('Lender terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_onlyAdminCanTerminate() public {     uint256 _amountToBorrow = request.borrowLimit;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyAdminCanTerminate(_id, _amountToBorrow); }  function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));     vm.roll(block.number + (request.duration / (2 * 20)));      uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));     admin.terminate(_id);     uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     } else {         assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     }     if (request.borrowAssetStrategy == compoundYieldAddress) {         assertGe(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } else {         assertEq(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } }  function test_depositCollateral() public {     uint256 _amount = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositCollateral(_id, _amount); }  function assert_depositCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());     admin.transferToken(address(collateralAsset), address(borrower), _amount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);     borrower.depositCollateral(_id, _amount, false);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));     assertEq(pcl.depositedCollateralInShares(_id), _shares); }  function test_depositCollateral_insufficientBalance() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);      admin.transferToken(address(collateralAsset), address(borrower), 10);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);     try borrower.depositCollateral(_id, 100, false) {         revert('Insufficient Balance of collateral tokens');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds balance');         } else {             assertEq(reason, 'SafeERC20: low-level call failed');         }     } }  function test_depositZeroCollateral() public {     uint256 _amount = 0;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositZeroCollateral(_id, _amount); }  function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));     borrower.setAllowance(         pooledCreditLineAddress,         address(collateralAsset),         100_000 * (10**ERC20(address(collateralAsset)).decimals())     );     try borrower.depositCollateral(_id, _amount, false) {         revert('Depositing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC1');     } }  function test_depositCollateralFromSavingsAccount() public {     request.collateralAssetStrategy = compoundYieldAddress;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));     emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);     if (request.collateralRatio != 0) {         borrower.depositToSavingsAccount(             savingsAccountAddress,             _collateralRequired,             address(collateralAsset),             compoundYieldAddress,             address(borrower)         );     }     uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));     emit log_named_uint('total tokens: ', _totalTokens);     uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);     emit log_named_uint('required collateral: ', _collateralRequired);     borrower.setAllowanceForSavingsAccount(         savingsAccountAddress,         _collateralRequired,         address(collateralAsset),         pooledCreditLineAddress     );     _helperDepositCollateral(borrower, _id, _collateralRequired, true);     uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);     emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);     // assertEq(_borrowAbleAmount, _amountToBorrow);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, true);     }     uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);     uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         pooledCreditLineAddress,         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);     assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14); }  function test_adminCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, address(admin)); }  function test_lenderCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress); }  function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {     if (_actor == address(admin)) {         try admin.cancelRequest(_id) {             revert('Admin cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);         try _user.cancelRequest(_id) {             revert('Invalid actor cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotCancelRequest() public {     assert_borrowerCannotCancelRequest(requestId); }  function assert_borrowerCannotCancelRequest(uint256 _id) public {     try borrower.cancelRequest(_id) {         revert('Canceling a PCL in active stage should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow); }  function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay zero current debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP3');     } }  function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow); }  function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay if interest is zero');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP4');     } }  function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     try _lender.transferLPTokens(address(borrower), _id, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_borrowerCannotReceivePoolTokens() public {     assert_borrowerCannotReceivePoolTokens(requestId);     request.borrowerVerifier = mockAdminVerifier1;     borrower.registerSelf(mockAdminVerifier1);     (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);     assert_borrowerCannotReceivePoolTokens(_id); }  function assert_canTransferPoolTokensToVerifiedUser(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     // borrowing some tokens     {         uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());         uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;         uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);         admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);         borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);         _helperDepositCollateral(borrower, _id, _collateralRequired, false);         borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);          // going ahead in time to generate interest         vm.warp(block.timestamp + 6 days);         // repaying the interest and some principal back         borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);         borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);     }      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender     _lender.withdrawInterest(_id);      uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     // calculating the receivers interest in shares     uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);     uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         receiverInterestInTokens,         address(borrowAsset)     );      uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);     _lender.transferLPTokens(_recevingAddress, _id, _amount);      uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);     assertEq(_finalBalance - _prevBalance, _amount);      uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;     curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;     assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14); }  function assert_cannotTransferEcxessPoolTokens(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _id, _amount) {         revert('balance less than the amount to transfer');     } catch Error(string memory reason) {         // assertEq(reason, 'ERC1155: insufficient balance for transfer');         assertEq(reason, 'SafeMath: subtraction overflow');     } }  function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     // testing when user is not verified     try _lender.transferLPTokens(_newUserAddress, _id, _balance) {         revert('should not have been possible to send LP tokens to not verified user');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT3');     } }  function test_lenderTransfersTokenToAnotherLender() public {     LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     address _recevingAddress = lenders[1].lenderAddress;     assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);     assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance); }  function test_lenderTransferTokenToNewUser() public {     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));      // testing when user is verified     _newUser.registerSelf(mockAdminVerifier1);      LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);      assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3); }  function test_areTokensTransferable() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     LenderInfo memory _lenderInfo = lenders[0];      address _recevingAddress = lenders[1].lenderAddress;     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  function test_canTransferPoolTokensWhenZeroInterest() public {     PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);     assertGe(_startBalanceLenderFrom, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);      PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);     uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);     assertGe(_startBalanceLenderTo, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);      _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);     assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));     assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo)); }  function test_cannotWithdrawZeroInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);      // cannot withdraw zero interest     vm.expectRevert(bytes('LP:WI1'));     _lender.withdrawInterest(requestId); }  function test_newPoolTokenHolderCanWithdrawInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _newUser.registerSelf(mockAdminVerifier1);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     _lender.transferLPTokens(address(_newUser), requestId, _balance);     uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);     assertEq(_newUserBalance, _balance);     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repaying the interest and some principal back     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // fetch borrowerInterestSharesWithdrawn for new user     uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     assertEq(_prevBISW, 0);     // get the interest for the new user     uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));     uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser     _newUser.withdrawInterest(requestId);     uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;     // match the interest shares withdrawn with the interest calculated     assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14); }  function test_stateAfterBorrow() public {     admin.updateProtocolFeeFraction(0);      uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('borrowable amount', _borrowableAmount);     assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);      uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));     borrower.borrow(requestId, _borrowableAmount);     uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));      assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);     assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14); }  function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());     _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     emit log_named_uint('_collateralRequired: ', _collateralRequired);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     // borrow some amount     uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());     if (_curBorrowAmount == _amountToBorrow) {         _curBorrowAmount = _curBorrowAmount.mul(90).div(100);     }     borrower.borrow(requestId, _curBorrowAmount);     // check borrow able amount     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     if (request.collateralRatio != 0) {         assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);     } else {         assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);     }     // now check withdrawableCollateral     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);     assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14); }  function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction); }  function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {     _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);     assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount)); }  function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {     if (request.collateralRatio == 0) return;     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);     uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));     emit log_named_uint('_maxCollateral: ', _maxCollateral);     emit log_named_uint('_minCollateral: ', _minCollateral);     _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);     emit log_named_uint('_collateralAmount: ', _collateralAmount);     _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);     emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);     // calulating what should borrowed to achieve _collateralRatioToAchieve     uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(         _collateralRatioToAchieve     );     emit log_named_uint('_amountToBorrow: ', _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);      uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('_maxBorrowable: ', _maxBorrowable);     if (         request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14     ) {         assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);         if (_amountToBorrow &gt; _maxBorrowable) {             _amountToBorrow = _maxBorrowable;         }     } else {         assertLe(_amountToBorrow, _maxBorrowable);     }      borrower.borrow(requestId, _amountToBorrow);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);      uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);     // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve     assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14); }  function test_closeActivePCLOncePrincipalPaidAndEnded() public {     // borrowing some tokens     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repay everything back     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _balance = borrowAsset.balanceOf(address(borrower));     if (_currentDebt &gt; _balance) {         admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));     }     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);     // go to end of pcl     vm.warp(block.timestamp + request.collectionPeriod + request.duration);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);     assertEq(0, borrowAsset.balanceOf(address(borrower))); }  event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);  function test_closeWhenNoCollateral() public {     vm.warp(block.timestamp + 6 days);     // close     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_closeWhenCollateral() public {     uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();     admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     vm.warp(block.timestamp + 6 days);     vm.roll(block.number + (6 * 86400) / 20);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));     vm.expectEmit(true, true, false, false);     emit CollateralSharesWithdrawn(requestId, _shares);     // close     borrower.close(requestId);     // this is equal only when no yield is used     // with compund this should be assertLe becuase deposited collateral would earn yield     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } else {         assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } }  event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare); event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);  function test_withdrawLiquidatedCollateral() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable.sub(10));     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable.sub(10),         address(borrowAsset)     );     // going ahead in time to make liquidation possible     vm.warp(block.timestamp + 50 days);     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);      uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;      vm.expectEmit(true, true, false, false);     emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } else {         assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } }  event PooledCreditLineTerminated(uint256 indexed id);  function test_terminateAfterLiquidation() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable);     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable,         address(borrowAsset)     );      // going ahead in time to make liquidation possible     vm.warp(block.timestamp + request.duration.mul(7).div(11));     vm.roll(block.number + request.duration.mul(7).div(11).div(20));     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;     vm.expectEmit(true, true, false, false);      emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);      uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));      uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));     emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);     // for an active pcl borrowLimit == total amount lent     _totalSupply = lp.totalSupply(requestId);     // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);     // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);     // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);      // now the admin terminates     vm.expectEmit(true, true, false, true);     emit PooledCreditLineTerminated(requestId);     admin.terminate(requestId);      assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));      if (request.borrowAssetStrategy == compoundYieldAddress) {         // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } else {         // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } }  function _helperDepositCollateral(     PCLUser _user,     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) private {     if (_amount != 0) {         _user.depositCollateral(_id, _amount, _fromSavingsAccount);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:26:43 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStage is PCLParent {     using SafeMath for uint256;     using SafeMath for uint128; uint256 requestId;  // enum PooledCreditLineStatus { //     NOT_CREATED, //     REQUESTED, //     ACTIVE, //     CLOSED, //     EXPIRED, //     LIQUIDATED, //     CANCELLED // }  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE); }  function test_cannotStartActivePCL() public {     try borrower.start(requestId) {         revert('cannot start active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     // verified using the borrower verifier instead of lender verifier     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_nonLenderCannotWithdrawLiquidity() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);     try _pooledCreditLineLender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL1');     } }  function test_lenderCannotWithdrawLiquidity() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotLendToActivePCL() public {     LenderInfo memory info = lenders[0];     PCLUser lender = PCLUser(info.lenderAddress);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendToActivePCLNewLender() public {     // Creating a new lender for lending     PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     lender.registerSelf(mockAdminVerifier1);     admin.transferToken(request.borrowAsset, address(lender), 100_000);     lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin)); }  function test_onlyBorrowerCanBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;     PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker)); }  function assert_borrowByInvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _user = PCLUser(_actor);     if (_actor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try admin.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try _user.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotBorrowMoreThanPossible() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);      try borrower.borrow(_id, _amountBorrowable + 1) {         revert('Borrower should not be able to borrow more than possible');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB3');     } }  function test_borrowerCannotBorrowZeroAmount() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.borrow(_id, 0) {         revert('Borrower should not be able to borrow zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB1');     } }  function test_lenderDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress); }  function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress); }  function test_adminDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin)); }  function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin)); }  function assert_DepositAndCannotWithdrawCollateral_InvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _depositor,     address _withdrawer ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      // Depositing into PCL     if (_depositor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     } else {         PCLUser _user = PCLUser(_depositor);          admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     }      // withdrawing from PCL     if (_withdrawer == address(admin)) {         try admin.withdrawCollateral(_id, _collateralRequired, false) {             revert('Admin should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_withdrawer);          try _user.withdrawCollateral(_id, _collateralRequired, false) {             revert('Invalid actor should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     if (request.collateralRatio != 0) {         borrower.withdrawCollateral(_id, _withdrawableCollateral, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_lenderDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);     _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(_lender, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try _lender.withdrawAllCollateral(_id, false) {         revert('lender should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_adminDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(admin, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try admin.withdrawAllCollateral(_id, false) {         revert('admin should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_borrowerCannotWithdrawZeroAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     try borrower.withdrawAllCollateral(_id, false) {         revert('borrower should not be able to withdraw zero all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  function test_borrowerCannotWithdrawZeroCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try borrower.withdrawCollateral(_id, 0, false) {         revert('Withdrawing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC2');     } }  function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);      try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {         revert('Withdrawing more collateral than withdrawable should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  function test_borrowerCanWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_cannotCloseIfDebtIsNonZero() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow); }  function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));     borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));     // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));      try borrower.close(_id) {         revert('Borrower should not be able to close with non-zero debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  function test_lenderCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin)); }  function assert_invalidActorCannotClose(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, request.minBorrowAmount);      if (_actor == address(admin)) {         try admin.close(_id) {             revert('Admin should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.close(_id) {             revert('Invalid actor should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanRepayAndClose() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanRepayAndClose(_id, _amountToBorrow); }  function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(_id, _currentDebt);      _currentDebt = pcl.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0);      borrower.close(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED); }  function test_repayWithInsufficientBalance() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));     try borrower.repay(_id, _currentDebt) {         revert('REVERT: Insufficient Balance');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds allowance');         } else {             assertEq(reason, 'Dai/insufficient-allowance');         }     } }  function test_borrowerCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower)); }  function test_adminCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;     emit log_named_uint('request.borrowLimit', request.borrowLimit);     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin)); }  function assert_InvalidActorCannotLiquidate(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      if (_actor == address(admin)) {         try admin.liquidate(_id, true) {             revert('admin liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.liquidate(_id, true) {             revert('Invalid actor liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } }  function test_onlyLendersCanLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit / 3;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyLendersCanLiquidate(_id, _amountToBorrow); }  function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {     if (request.collateralRatio == 0) return;     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      PCLUser _lender = PCLUser(lenders[1].lenderAddress);     uint256 _amountLent = lenders[1].amount;     _lender.liquidate(_id, true);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_lenderCannotLiquidateZeroPrincipal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with zero principal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, _amountToBorrow / 2);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with if collateral ratio is more than ideal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  function test_borrowerCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotTerminate(_id); }  function assert_borrowerCannotTerminate(uint256 _id) public {     try borrower.terminate(_id) {         revert('Borrower terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_lenderCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotTerminate(_id); }  function assert_lenderCannotTerminate(uint256 _id) public {     PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));     try _lender.terminate(_id) {         revert('Lender terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_onlyAdminCanTerminate() public {     uint256 _amountToBorrow = request.borrowLimit;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyAdminCanTerminate(_id, _amountToBorrow); }  function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));     vm.roll(block.number + (request.duration / (2 * 20)));      uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));     admin.terminate(_id);     uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     } else {         assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     }     if (request.borrowAssetStrategy == compoundYieldAddress) {         assertGe(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } else {         assertEq(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } }  function test_depositCollateral() public {     uint256 _amount = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositCollateral(_id, _amount); }  function assert_depositCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());     admin.transferToken(address(collateralAsset), address(borrower), _amount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);     borrower.depositCollateral(_id, _amount, false);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));     assertEq(pcl.depositedCollateralInShares(_id), _shares); }  function test_depositCollateral_insufficientBalance() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);      admin.transferToken(address(collateralAsset), address(borrower), 10);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);     try borrower.depositCollateral(_id, 100, false) {         revert('Insufficient Balance of collateral tokens');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds balance');         } else {             assertEq(reason, 'SafeERC20: low-level call failed');         }     } }  function test_depositZeroCollateral() public {     uint256 _amount = 0;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositZeroCollateral(_id, _amount); }  function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));     borrower.setAllowance(         pooledCreditLineAddress,         address(collateralAsset),         100_000 * (10**ERC20(address(collateralAsset)).decimals())     );     try borrower.depositCollateral(_id, _amount, false) {         revert('Depositing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC1');     } }  function test_depositCollateralFromSavingsAccount() public {     request.collateralAssetStrategy = compoundYieldAddress;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));     emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);     if (request.collateralRatio != 0) {         borrower.depositToSavingsAccount(             savingsAccountAddress,             _collateralRequired,             address(collateralAsset),             compoundYieldAddress,             address(borrower)         );     }     uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));     emit log_named_uint('total tokens: ', _totalTokens);     uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);     emit log_named_uint('required collateral: ', _collateralRequired);     borrower.setAllowanceForSavingsAccount(         savingsAccountAddress,         _collateralRequired,         address(collateralAsset),         pooledCreditLineAddress     );     _helperDepositCollateral(borrower, _id, _collateralRequired, true);     uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);     emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);     // assertEq(_borrowAbleAmount, _amountToBorrow);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, true);     }     uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);     uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         pooledCreditLineAddress,         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);     assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14); }  function test_adminCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, address(admin)); }  function test_lenderCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress); }  function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {     if (_actor == address(admin)) {         try admin.cancelRequest(_id) {             revert('Admin cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);         try _user.cancelRequest(_id) {             revert('Invalid actor cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotCancelRequest() public {     assert_borrowerCannotCancelRequest(requestId); }  function assert_borrowerCannotCancelRequest(uint256 _id) public {     try borrower.cancelRequest(_id) {         revert('Canceling a PCL in active stage should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow); }  function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay zero current debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP3');     } }  function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow); }  function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay if interest is zero');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP4');     } }  function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     try _lender.transferLPTokens(address(borrower), _id, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_borrowerCannotReceivePoolTokens() public {     assert_borrowerCannotReceivePoolTokens(requestId);     request.borrowerVerifier = mockAdminVerifier1;     borrower.registerSelf(mockAdminVerifier1);     (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);     assert_borrowerCannotReceivePoolTokens(_id); }  function assert_canTransferPoolTokensToVerifiedUser(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     // borrowing some tokens     {         uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());         uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;         uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);         admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);         borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);         _helperDepositCollateral(borrower, _id, _collateralRequired, false);         borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);          // going ahead in time to generate interest         vm.warp(block.timestamp + 6 days);         // repaying the interest and some principal back         borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);         borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);     }      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender     _lender.withdrawInterest(_id);      uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     // calculating the receivers interest in shares     uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);     uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         receiverInterestInTokens,         address(borrowAsset)     );      uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);     _lender.transferLPTokens(_recevingAddress, _id, _amount);      uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);     assertEq(_finalBalance - _prevBalance, _amount);      uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;     curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;     assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14); }  function assert_cannotTransferEcxessPoolTokens(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _id, _amount) {         revert('balance less than the amount to transfer');     } catch Error(string memory reason) {         // assertEq(reason, 'ERC1155: insufficient balance for transfer');         assertEq(reason, 'SafeMath: subtraction overflow');     } }  function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     // testing when user is not verified     try _lender.transferLPTokens(_newUserAddress, _id, _balance) {         revert('should not have been possible to send LP tokens to not verified user');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT3');     } }  function test_lenderTransfersTokenToAnotherLender() public {     LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     address _recevingAddress = lenders[1].lenderAddress;     assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);     assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance); }  function test_lenderTransferTokenToNewUser() public {     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));      // testing when user is verified     _newUser.registerSelf(mockAdminVerifier1);      LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);      assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3); }  function test_areTokensTransferable() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     LenderInfo memory _lenderInfo = lenders[0];      address _recevingAddress = lenders[1].lenderAddress;     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  function test_canTransferPoolTokensWhenZeroInterest() public {     PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);     assertGe(_startBalanceLenderFrom, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);      PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);     uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);     assertGe(_startBalanceLenderTo, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);      _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);     assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));     assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo)); }  function test_cannotWithdrawZeroInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);      // cannot withdraw zero interest     vm.expectRevert(bytes('LP:WI1'));     _lender.withdrawInterest(requestId); }  function test_newPoolTokenHolderCanWithdrawInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _newUser.registerSelf(mockAdminVerifier1);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     _lender.transferLPTokens(address(_newUser), requestId, _balance);     uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);     assertEq(_newUserBalance, _balance);     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repaying the interest and some principal back     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // fetch borrowerInterestSharesWithdrawn for new user     uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     assertEq(_prevBISW, 0);     // get the interest for the new user     uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));     uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser     _newUser.withdrawInterest(requestId);     uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;     // match the interest shares withdrawn with the interest calculated     assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14); }  function test_stateAfterBorrow() public {     admin.updateProtocolFeeFraction(0);      uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('borrowable amount', _borrowableAmount);     assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);      uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));     borrower.borrow(requestId, _borrowableAmount);     uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));      assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);     assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14); }  function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());     _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     emit log_named_uint('_collateralRequired: ', _collateralRequired);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     // borrow some amount     uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());     if (_curBorrowAmount == _amountToBorrow) {         _curBorrowAmount = _curBorrowAmount.mul(90).div(100);     }     borrower.borrow(requestId, _curBorrowAmount);     // check borrow able amount     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     if (request.collateralRatio != 0) {         assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);     } else {         assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);     }     // now check withdrawableCollateral     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);     assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14); }  function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction); }  function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {     _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);     assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount)); }  function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {     if (request.collateralRatio == 0) return;     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);     uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));     emit log_named_uint('_maxCollateral: ', _maxCollateral);     emit log_named_uint('_minCollateral: ', _minCollateral);     _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);     emit log_named_uint('_collateralAmount: ', _collateralAmount);     _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);     emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);     // calulating what should borrowed to achieve _collateralRatioToAchieve     uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(         _collateralRatioToAchieve     );     emit log_named_uint('_amountToBorrow: ', _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);      uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('_maxBorrowable: ', _maxBorrowable);     if (         request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14     ) {         assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);         if (_amountToBorrow &gt; _maxBorrowable) {             _amountToBorrow = _maxBorrowable;         }     } else {         assertLe(_amountToBorrow, _maxBorrowable);     }      borrower.borrow(requestId, _amountToBorrow);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);      uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);     // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve     assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14); }  function test_closeActivePCLOncePrincipalPaidAndEnded() public {     // borrowing some tokens     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repay everything back     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _balance = borrowAsset.balanceOf(address(borrower));     if (_currentDebt &gt; _balance) {         admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));     }     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);     // go to end of pcl     vm.warp(block.timestamp + request.collectionPeriod + request.duration);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);     assertEq(0, borrowAsset.balanceOf(address(borrower))); }  event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);  function test_closeWhenNoCollateral() public {     vm.warp(block.timestamp + 6 days);     // close     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_closeWhenCollateral() public {     uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();     admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     vm.warp(block.timestamp + 6 days);     vm.roll(block.number + (6 * 86400) / 20);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));     vm.expectEmit(true, true, false, false);     emit CollateralSharesWithdrawn(requestId, _shares);     // close     borrower.close(requestId);     // this is equal only when no yield is used     // with compund this should be assertLe becuase deposited collateral would earn yield     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } else {         assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } }  event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare); event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);  function test_withdrawLiquidatedCollateral() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable.sub(10));     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable.sub(10),         address(borrowAsset)     );     // going ahead in time to make liquidation possible     vm.warp(block.timestamp + 50 days);     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);      uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;      vm.expectEmit(true, true, false, false);     emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } else {         assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } }  event PooledCreditLineTerminated(uint256 indexed id);  function test_terminateAfterLiquidation() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable);     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable,         address(borrowAsset)     );      // going ahead in time to make liquidation possible     vm.warp(block.timestamp + request.duration.mul(7).div(11));     vm.roll(block.number + request.duration.mul(7).div(11).div(20));     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;     vm.expectEmit(true, true, false, false);      emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);      uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));      uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));     emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);     // for an active pcl borrowLimit == total amount lent     _totalSupply = lp.totalSupply(requestId);     // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);     // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);     // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);      // now the admin terminates     vm.expectEmit(true, true, false, true);     emit PooledCreditLineTerminated(requestId);     admin.terminate(requestId);      assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));      if (request.borrowAssetStrategy == compoundYieldAddress) {         // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } else {         // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } }  function _helperDepositCollateral(     PCLUser _user,     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) private {     if (_amount != 0) {         _user.depositCollateral(_id, _amount, _fromSavingsAccount);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:26:43 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:26:46 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:26:46 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 17493
completion_tokens: 1
total_tokens: 17494
cost: $-1.000000


[2024-27-08 09:26:46 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
.]

Based

[2024-27-08 09:26:46 INFO] **[Seminar Conclusion]**:

 Based

[2024-27-08 09:26:49 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStage is PCLParent {     using SafeMath for uint256;     using SafeMath for uint128; uint256 requestId;  // enum PooledCreditLineStatus { //     NOT_CREATED, //     REQUESTED, //     ACTIVE, //     CLOSED, //     EXPIRED, //     LIQUIDATED, //     CANCELLED // }  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE); }  function test_cannotStartActivePCL() public {     try borrower.start(requestId) {         revert('cannot start active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     // verified using the borrower verifier instead of lender verifier     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_nonLenderCannotWithdrawLiquidity() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);     try _pooledCreditLineLender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL1');     } }  function test_lenderCannotWithdrawLiquidity() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotLendToActivePCL() public {     LenderInfo memory info = lenders[0];     PCLUser lender = PCLUser(info.lenderAddress);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendToActivePCLNewLender() public {     // Creating a new lender for lending     PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     lender.registerSelf(mockAdminVerifier1);     admin.transferToken(request.borrowAsset, address(lender), 100_000);     lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin)); }  function test_onlyBorrowerCanBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;     PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker)); }  function assert_borrowByInvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _user = PCLUser(_actor);     if (_actor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try admin.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try _user.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotBorrowMoreThanPossible() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);      try borrower.borrow(_id, _amountBorrowable + 1) {         revert('Borrower should not be able to borrow more than possible');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB3');     } }  function test_borrowerCannotBorrowZeroAmount() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.borrow(_id, 0) {         revert('Borrower should not be able to borrow zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB1');     } }  function test_lenderDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress); }  function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress); }  function test_adminDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin)); }  function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin)); }  function assert_DepositAndCannotWithdrawCollateral_InvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _depositor,     address _withdrawer ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      // Depositing into PCL     if (_depositor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     } else {         PCLUser _user = PCLUser(_depositor);          admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     }      // withdrawing from PCL     if (_withdrawer == address(admin)) {         try admin.withdrawCollateral(_id, _collateralRequired, false) {             revert('Admin should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_withdrawer);          try _user.withdrawCollateral(_id, _collateralRequired, false) {             revert('Invalid actor should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     if (request.collateralRatio != 0) {         borrower.withdrawCollateral(_id, _withdrawableCollateral, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_lenderDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);     _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(_lender, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try _lender.withdrawAllCollateral(_id, false) {         revert('lender should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_adminDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(admin, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try admin.withdrawAllCollateral(_id, false) {         revert('admin should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_borrowerCannotWithdrawZeroAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     try borrower.withdrawAllCollateral(_id, false) {         revert('borrower should not be able to withdraw zero all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  function test_borrowerCannotWithdrawZeroCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try borrower.withdrawCollateral(_id, 0, false) {         revert('Withdrawing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC2');     } }  function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);      try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {         revert('Withdrawing more collateral than withdrawable should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  function test_borrowerCanWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_cannotCloseIfDebtIsNonZero() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow); }  function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));     borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));     // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));      try borrower.close(_id) {         revert('Borrower should not be able to close with non-zero debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  function test_lenderCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin)); }  function assert_invalidActorCannotClose(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, request.minBorrowAmount);      if (_actor == address(admin)) {         try admin.close(_id) {             revert('Admin should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.close(_id) {             revert('Invalid actor should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanRepayAndClose() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanRepayAndClose(_id, _amountToBorrow); }  function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(_id, _currentDebt);      _currentDebt = pcl.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0);      borrower.close(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED); }  function test_repayWithInsufficientBalance() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));     try borrower.repay(_id, _currentDebt) {         revert('REVERT: Insufficient Balance');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds allowance');         } else {             assertEq(reason, 'Dai/insufficient-allowance');         }     } }  function test_borrowerCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower)); }  function test_adminCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;     emit log_named_uint('request.borrowLimit', request.borrowLimit);     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin)); }  function assert_InvalidActorCannotLiquidate(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      if (_actor == address(admin)) {         try admin.liquidate(_id, true) {             revert('admin liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.liquidate(_id, true) {             revert('Invalid actor liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } }  function test_onlyLendersCanLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit / 3;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyLendersCanLiquidate(_id, _amountToBorrow); }  function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {     if (request.collateralRatio == 0) return;     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      PCLUser _lender = PCLUser(lenders[1].lenderAddress);     uint256 _amountLent = lenders[1].amount;     _lender.liquidate(_id, true);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_lenderCannotLiquidateZeroPrincipal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with zero principal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, _amountToBorrow / 2);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with if collateral ratio is more than ideal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  function test_borrowerCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotTerminate(_id); }  function assert_borrowerCannotTerminate(uint256 _id) public {     try borrower.terminate(_id) {         revert('Borrower terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_lenderCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotTerminate(_id); }  function assert_lenderCannotTerminate(uint256 _id) public {     PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));     try _lender.terminate(_id) {         revert('Lender terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_onlyAdminCanTerminate() public {     uint256 _amountToBorrow = request.borrowLimit;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyAdminCanTerminate(_id, _amountToBorrow); }  function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));     vm.roll(block.number + (request.duration / (2 * 20)));      uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));     admin.terminate(_id);     uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     } else {         assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     }     if (request.borrowAssetStrategy == compoundYieldAddress) {         assertGe(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } else {         assertEq(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } }  function test_depositCollateral() public {     uint256 _amount = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositCollateral(_id, _amount); }  function assert_depositCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());     admin.transferToken(address(collateralAsset), address(borrower), _amount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);     borrower.depositCollateral(_id, _amount, false);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));     assertEq(pcl.depositedCollateralInShares(_id), _shares); }  function test_depositCollateral_insufficientBalance() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);      admin.transferToken(address(collateralAsset), address(borrower), 10);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);     try borrower.depositCollateral(_id, 100, false) {         revert('Insufficient Balance of collateral tokens');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds balance');         } else {             assertEq(reason, 'SafeERC20: low-level call failed');         }     } }  function test_depositZeroCollateral() public {     uint256 _amount = 0;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositZeroCollateral(_id, _amount); }  function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));     borrower.setAllowance(         pooledCreditLineAddress,         address(collateralAsset),         100_000 * (10**ERC20(address(collateralAsset)).decimals())     );     try borrower.depositCollateral(_id, _amount, false) {         revert('Depositing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC1');     } }  function test_depositCollateralFromSavingsAccount() public {     request.collateralAssetStrategy = compoundYieldAddress;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));     emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);     if (request.collateralRatio != 0) {         borrower.depositToSavingsAccount(             savingsAccountAddress,             _collateralRequired,             address(collateralAsset),             compoundYieldAddress,             address(borrower)         );     }     uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));     emit log_named_uint('total tokens: ', _totalTokens);     uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);     emit log_named_uint('required collateral: ', _collateralRequired);     borrower.setAllowanceForSavingsAccount(         savingsAccountAddress,         _collateralRequired,         address(collateralAsset),         pooledCreditLineAddress     );     _helperDepositCollateral(borrower, _id, _collateralRequired, true);     uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);     emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);     // assertEq(_borrowAbleAmount, _amountToBorrow);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, true);     }     uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);     uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         pooledCreditLineAddress,         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);     assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14); }  function test_adminCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, address(admin)); }  function test_lenderCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress); }  function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {     if (_actor == address(admin)) {         try admin.cancelRequest(_id) {             revert('Admin cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);         try _user.cancelRequest(_id) {             revert('Invalid actor cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotCancelRequest() public {     assert_borrowerCannotCancelRequest(requestId); }  function assert_borrowerCannotCancelRequest(uint256 _id) public {     try borrower.cancelRequest(_id) {         revert('Canceling a PCL in active stage should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow); }  function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay zero current debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP3');     } }  function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow); }  function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay if interest is zero');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP4');     } }  function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     try _lender.transferLPTokens(address(borrower), _id, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_borrowerCannotReceivePoolTokens() public {     assert_borrowerCannotReceivePoolTokens(requestId);     request.borrowerVerifier = mockAdminVerifier1;     borrower.registerSelf(mockAdminVerifier1);     (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);     assert_borrowerCannotReceivePoolTokens(_id); }  function assert_canTransferPoolTokensToVerifiedUser(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     // borrowing some tokens     {         uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());         uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;         uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);         admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);         borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);         _helperDepositCollateral(borrower, _id, _collateralRequired, false);         borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);          // going ahead in time to generate interest         vm.warp(block.timestamp + 6 days);         // repaying the interest and some principal back         borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);         borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);     }      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender     _lender.withdrawInterest(_id);      uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     // calculating the receivers interest in shares     uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);     uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         receiverInterestInTokens,         address(borrowAsset)     );      uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);     _lender.transferLPTokens(_recevingAddress, _id, _amount);      uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);     assertEq(_finalBalance - _prevBalance, _amount);      uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;     curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;     assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14); }  function assert_cannotTransferEcxessPoolTokens(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _id, _amount) {         revert('balance less than the amount to transfer');     } catch Error(string memory reason) {         // assertEq(reason, 'ERC1155: insufficient balance for transfer');         assertEq(reason, 'SafeMath: subtraction overflow');     } }  function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     // testing when user is not verified     try _lender.transferLPTokens(_newUserAddress, _id, _balance) {         revert('should not have been possible to send LP tokens to not verified user');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT3');     } }  function test_lenderTransfersTokenToAnotherLender() public {     LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     address _recevingAddress = lenders[1].lenderAddress;     assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);     assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance); }  function test_lenderTransferTokenToNewUser() public {     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));      // testing when user is verified     _newUser.registerSelf(mockAdminVerifier1);      LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);      assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3); }  function test_areTokensTransferable() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     LenderInfo memory _lenderInfo = lenders[0];      address _recevingAddress = lenders[1].lenderAddress;     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  function test_canTransferPoolTokensWhenZeroInterest() public {     PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);     assertGe(_startBalanceLenderFrom, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);      PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);     uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);     assertGe(_startBalanceLenderTo, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);      _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);     assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));     assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo)); }  function test_cannotWithdrawZeroInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);      // cannot withdraw zero interest     vm.expectRevert(bytes('LP:WI1'));     _lender.withdrawInterest(requestId); }  function test_newPoolTokenHolderCanWithdrawInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _newUser.registerSelf(mockAdminVerifier1);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     _lender.transferLPTokens(address(_newUser), requestId, _balance);     uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);     assertEq(_newUserBalance, _balance);     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repaying the interest and some principal back     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // fetch borrowerInterestSharesWithdrawn for new user     uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     assertEq(_prevBISW, 0);     // get the interest for the new user     uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));     uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser     _newUser.withdrawInterest(requestId);     uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;     // match the interest shares withdrawn with the interest calculated     assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14); }  function test_stateAfterBorrow() public {     admin.updateProtocolFeeFraction(0);      uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('borrowable amount', _borrowableAmount);     assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);      uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));     borrower.borrow(requestId, _borrowableAmount);     uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));      assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);     assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14); }  function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());     _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     emit log_named_uint('_collateralRequired: ', _collateralRequired);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     // borrow some amount     uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());     if (_curBorrowAmount == _amountToBorrow) {         _curBorrowAmount = _curBorrowAmount.mul(90).div(100);     }     borrower.borrow(requestId, _curBorrowAmount);     // check borrow able amount     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     if (request.collateralRatio != 0) {         assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);     } else {         assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);     }     // now check withdrawableCollateral     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);     assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14); }  function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction); }  function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {     _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);     assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount)); }  function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {     if (request.collateralRatio == 0) return;     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);     uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));     emit log_named_uint('_maxCollateral: ', _maxCollateral);     emit log_named_uint('_minCollateral: ', _minCollateral);     _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);     emit log_named_uint('_collateralAmount: ', _collateralAmount);     _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);     emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);     // calulating what should borrowed to achieve _collateralRatioToAchieve     uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(         _collateralRatioToAchieve     );     emit log_named_uint('_amountToBorrow: ', _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);      uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('_maxBorrowable: ', _maxBorrowable);     if (         request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14     ) {         assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);         if (_amountToBorrow &gt; _maxBorrowable) {             _amountToBorrow = _maxBorrowable;         }     } else {         assertLe(_amountToBorrow, _maxBorrowable);     }      borrower.borrow(requestId, _amountToBorrow);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);      uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);     // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve     assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14); }  function test_closeActivePCLOncePrincipalPaidAndEnded() public {     // borrowing some tokens     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repay everything back     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _balance = borrowAsset.balanceOf(address(borrower));     if (_currentDebt &gt; _balance) {         admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));     }     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);     // go to end of pcl     vm.warp(block.timestamp + request.collectionPeriod + request.duration);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);     assertEq(0, borrowAsset.balanceOf(address(borrower))); }  event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);  function test_closeWhenNoCollateral() public {     vm.warp(block.timestamp + 6 days);     // close     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_closeWhenCollateral() public {     uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();     admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     vm.warp(block.timestamp + 6 days);     vm.roll(block.number + (6 * 86400) / 20);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));     vm.expectEmit(true, true, false, false);     emit CollateralSharesWithdrawn(requestId, _shares);     // close     borrower.close(requestId);     // this is equal only when no yield is used     // with compund this should be assertLe becuase deposited collateral would earn yield     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } else {         assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } }  event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare); event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);  function test_withdrawLiquidatedCollateral() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable.sub(10));     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable.sub(10),         address(borrowAsset)     );     // going ahead in time to make liquidation possible     vm.warp(block.timestamp + 50 days);     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);      uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;      vm.expectEmit(true, true, false, false);     emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } else {         assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } }  event PooledCreditLineTerminated(uint256 indexed id);  function test_terminateAfterLiquidation() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable);     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable,         address(borrowAsset)     );      // going ahead in time to make liquidation possible     vm.warp(block.timestamp + request.duration.mul(7).div(11));     vm.roll(block.number + request.duration.mul(7).div(11).div(20));     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;     vm.expectEmit(true, true, false, false);      emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);      uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));      uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));     emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);     // for an active pcl borrowLimit == total amount lent     _totalSupply = lp.totalSupply(requestId);     // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);     // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);     // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);      // now the admin terminates     vm.expectEmit(true, true, false, true);     emit PooledCreditLineTerminated(requestId);     admin.terminate(requestId);      assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));      if (request.borrowAssetStrategy == compoundYieldAddress) {         // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } else {         // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } }  function _helperDepositCollateral(     PCLUser _user,     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) private {     if (_amount != 0) {         _user.depositCollateral(_id, _amount, _fromSavingsAccount);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLActiveStage is PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n\n    uint256 requestId;\n\n    // enum PooledCreditLineStatus {\n    //     NOT_CREATED,\n    //     REQUESTED,\n    //     ACTIVE,\n    //     CLOSED,\n    //     EXPIRED,\n    //     LIQUIDATED,\n    //     CANCELLED\n    // }\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function test_cannotStartActivePCL() public {\n        try borrower.start(requestId) {\n            revert('cannot start active pcl');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:S1');\n        }\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert('External user cannot create');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert('External user cannot terminate');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert('Lender cannot lend zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L1');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        // verified using the borrower verifier instead of lender verifier\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Unverified lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L2');\n        }\n    }\n\n    function test_nonLenderCannotWithdrawLiquidity() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        try _pooledCreditLineLender.withdrawLiquidity(requestId) {\n            revert('Lender cannot withdraw liquidity');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL1');\n        }\n    }\n\n    function test_lenderCannotWithdrawLiquidity() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.withdrawLiquidity(requestId) {\n            revert('Lender cannot withdraw liquidity');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n    }\n\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert('Non lender cannot withdraw liquidated collateral tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:WLC1');\n        }\n    }\n\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert('Lender cannot withdraw liquidated collateral tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    function test_cannotTransferLPTokensToSameAddress() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert('Lender cannot transfer LP tokens to itself');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT1');\n        }\n    }\n\n    function test_cannotBurnPoolTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert('Lender cannot burn LP tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'ERC1155: transfer to the zero address');\n        }\n    }\n\n    function test_cannotLendToActivePCL() public {\n        LenderInfo memory info = lenders[0];\n        PCLUser lender = PCLUser(info.lenderAddress);\n        try lender.lend(requestId, 100_000) {\n            revert('cannot lend to active pcl');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    function test_cannotLendToActivePCLNewLender() public {\n        // Creating a new lender for lending\n        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        lender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(request.borrowAsset, address(lender), 100_000);\n        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);\n        try lender.lend(requestId, 100_000) {\n            revert('cannot lend to active pcl');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    function test_lenderCannotBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);\n    }\n\n    function test_adminCannotBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));\n    }\n\n    function test_onlyBorrowerCanBorrow() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));\n    }\n\n    function assert_borrowByInvalidActor(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        PCLUser _user = PCLUser(_actor);\n        if (_actor == address(admin)) {\n            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n            _helperDepositCollateral(admin, _id, _collateralRequired, false);\n\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n            try admin.borrow(_id, _amountToBorrow) {\n                revert('Invalid user should not be able to borrow');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        } else {\n            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);\n            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n            _helperDepositCollateral(_user, _id, _collateralRequired, false);\n\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n            try _user.borrow(_id, _amountToBorrow) {\n                revert('Invalid user should not be able to borrow');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        }\n    }\n\n    function test_borrowerCannotBorrowMoreThanPossible() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);\n\n        try borrower.borrow(_id, _amountBorrowable + 1) {\n            revert('Borrower should not be able to borrow more than possible');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:IB3');\n        }\n    }\n\n    function test_borrowerCannotBorrowZeroAmount() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        try borrower.borrow(_id, 0) {\n            revert('Borrower should not be able to borrow zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:IB1');\n        }\n    }\n\n    function test_lenderDepositsAndCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);\n    }\n\n    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);\n    }\n\n    function test_adminDepositsAndCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));\n    }\n\n    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));\n    }\n\n    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _depositor,\n        address _withdrawer\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        // Depositing into PCL\n        if (_depositor == address(admin)) {\n            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n            _helperDepositCollateral(admin, _id, _collateralRequired, false);\n\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n        } else {\n            PCLUser _user = PCLUser(_depositor);\n\n            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);\n            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n            _helperDepositCollateral(_user, _id, _collateralRequired, false);\n\n            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n                _collateralRequired,\n                address(collateralAsset)\n            );\n            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n            assertEq(_expectedCollateralShares, _actualCollateralShares);\n        }\n\n        // withdrawing from PCL\n        if (_withdrawer == address(admin)) {\n            try admin.withdrawCollateral(_id, _collateralRequired, false) {\n                revert('Admin should not be able to withdraw collateral');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        } else {\n            PCLUser _user = PCLUser(_withdrawer);\n\n            try _user.withdrawCollateral(_id, _collateralRequired, false) {\n                revert('Invalid actor should not be able to withdraw collateral');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        }\n    }\n\n    function test_borrowerCanWithdrawCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);\n        if (request.collateralRatio != 0) {\n            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);\n        }\n        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);\n    }\n\n    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);\n        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(_lender, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        try _lender.withdrawAllCollateral(_id, false) {\n            revert('lender should not be able to withdraw all collateral');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:OCLB1');\n        }\n    }\n\n    function test_adminDepositsAndCannotWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(admin, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        try admin.withdrawAllCollateral(_id, false) {\n            revert('admin should not be able to withdraw all collateral');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:OCLB1');\n        }\n    }\n\n    function test_borrowerCannotWithdrawZeroAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        try borrower.withdrawAllCollateral(_id, false) {\n            revert('borrower should not be able to withdraw zero all collateral');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WAC1');\n        }\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        try borrower.withdrawCollateral(_id, 0, false) {\n            revert('Withdrawing zero collateral should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC2');\n        }\n    }\n\n    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);\n\n        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {\n            revert('Withdrawing more collateral than withdrawable should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC1');\n        }\n    }\n\n    function test_borrowerCanWithdrawAllCollateral() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        if (request.collateralRatio != 0) {\n            borrower.withdrawAllCollateral(_id, false);\n        }\n        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));\n        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);\n    }\n\n    function test_cannotCloseIfDebtIsNonZero() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);\n    }\n\n    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));\n        borrower.borrow(_id, 90_000 * (10ERC20(address(borrowAsset)).decimals()));\n        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));\n\n        try borrower.close(_id) {\n            revert('Borrower should not be able to close with non-zero debt');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C2');\n        }\n    }\n\n    function test_lenderCannotClose() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);\n    }\n\n    function test_adminCannotClose() public {\n        uint256 _amountToBorrow = request.borrowLimit / 2;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));\n    }\n\n    function assert_invalidActorCannotClose(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        borrower.borrow(_id, request.minBorrowAmount);\n\n        if (_actor == address(admin)) {\n            try admin.close(_id) {\n                revert('Admin should not be able to close PCL');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n\n            try _user.close(_id) {\n                revert('Invalid actor should not be able to close PCL');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        }\n    }\n\n    function test_borrowerCanRepayAndClose() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n\n        vm.warp(block.timestamp + (request.duration / 2));\n\n        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(_id, _currentDebt);\n\n        _currentDebt = pcl.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0);\n\n        borrower.close(_id);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_repayWithInsufficientBalance() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n\n        vm.warp(block.timestamp + (request.duration / 2));\n\n        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));\n        try borrower.repay(_id, _currentDebt) {\n            revert('REVERT: Insufficient Balance');\n        } catch Error(string memory reason) {\n            if (!isForked) {\n                assertEq(reason, 'ERC20: transfer amount exceeds allowance');\n            } else {\n                assertEq(reason, 'Dai/insufficient-allowance');\n            }\n        }\n    }\n\n    function test_borrowerCannotLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));\n    }\n\n    function test_adminCannotLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        emit log_named_uint('request.borrowLimit', request.borrowLimit);\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));\n    }\n\n    function assert_InvalidActorCannotLiquidate(\n        uint256 _id,\n        uint256 _amountToBorrow,\n        address _actor\n    ) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);\n        borrower.borrow(_id, _borrowable);\n\n        vm.warp(block.timestamp + (request.duration / 2));\n\n        if (!isForked) {\n            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);\n        }\n\n        if (_actor == address(admin)) {\n            try admin.liquidate(_id, true) {\n                revert('admin liquidating should revert');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'LP:LIQ1');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n\n            try _user.liquidate(_id, true) {\n                revert('Invalid actor liquidating should revert');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'LP:LIQ1');\n            }\n        }\n    }\n\n    function test_onlyLendersCanLiquidate() public {\n        uint256 _amountToBorrow = request.borrowLimit / 3;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);\n    }\n\n    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {\n        if (request.collateralRatio == 0) return;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);\n        borrower.borrow(_id, _borrowable);\n\n        vm.warp(block.timestamp + (request.duration / 2));\n\n        if (!isForked) {\n            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);\n        }\n\n        PCLUser _lender = PCLUser(lenders[1].lenderAddress);\n        uint256 _amountLent = lenders[1].amount;\n        _lender.liquidate(_id, true);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_lenderCannotLiquidateZeroPrincipal() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);\n    }\n\n    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        vm.warp(block.timestamp + (request.duration / 2));\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.liquidate(_id, true) {\n            revert('Lender liquidating should revert with zero principal');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L1');\n        }\n    }\n\n    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);\n    }\n\n    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, _amountToBorrow / 2);\n\n        vm.warp(block.timestamp + (request.duration / 2));\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.liquidate(_id, true) {\n            revert('Lender liquidating should revert with if collateral ratio is more than ideal');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    function test_borrowerCannotTerminate() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_borrowerCannotTerminate(_id);\n    }\n\n    function assert_borrowerCannotTerminate(uint256 _id) public {\n        try borrower.terminate(_id) {\n            revert('Borrower terminating PCL should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'Ownable: caller is not the owner');\n        }\n    }\n\n    function test_lenderCannotTerminate() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_lenderCannotTerminate(_id);\n    }\n\n    function assert_lenderCannotTerminate(uint256 _id) public {\n        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));\n        try _lender.terminate(_id) {\n            revert('Lender terminating PCL should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'Ownable: caller is not the owner');\n        }\n    }\n\n    function test_onlyAdminCanTerminate() public {\n        uint256 _amountToBorrow = request.borrowLimit;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_onlyAdminCanTerminate(_id, _amountToBorrow);\n    }\n\n    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        borrower.borrow(_id, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n\n        vm.warp(block.timestamp + (request.duration / 2));\n        vm.roll(block.number + (request.duration / (2 * 20)));\n\n        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));\n        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));\n        admin.terminate(_id);\n        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));\n        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);\n        } else {\n            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);\n        }\n        if (request.borrowAssetStrategy == compoundYieldAddress) {\n            assertGe(\n                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,\n                (request.borrowLimit / 2) - 90_000 * 10(ERC20(address(borrowAsset)).decimals())\n            );\n        } else {\n            assertEq(\n                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,\n                (request.borrowLimit / 2) - 90_000 * 10(ERC20(address(borrowAsset)).decimals())\n            );\n        }\n    }\n\n    function test_depositCollateral() public {\n        uint256 _amount = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_depositCollateral(_id, _amount);\n    }\n\n    function assert_depositCollateral(uint256 _id, uint256 _amount) public {\n        // lender.lend(_id, _amount);\n        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());\n        admin.transferToken(address(collateralAsset), address(borrower), _amount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);\n        borrower.depositCollateral(_id, _amount, false);\n        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));\n        assertEq(pcl.depositedCollateralInShares(_id), _shares);\n    }\n\n    function test_depositCollateral_insufficientBalance() public {\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n\n        admin.transferToken(address(collateralAsset), address(borrower), 10);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);\n        try borrower.depositCollateral(_id, 100, false) {\n            revert('Insufficient Balance of collateral tokens');\n        } catch Error(string memory reason) {\n            if (!isForked) {\n                assertEq(reason, 'ERC20: transfer amount exceeds balance');\n            } else {\n                assertEq(reason, 'SafeERC20: low-level call failed');\n            }\n        }\n    }\n\n    function test_depositZeroCollateral() public {\n        uint256 _amount = 0;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);\n        assert_depositZeroCollateral(_id, _amount);\n    }\n\n    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {\n        // lender.lend(_id, _amount);\n        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10ERC20(address(collateralAsset)).decimals()));\n        borrower.setAllowance(\n            pooledCreditLineAddress,\n            address(collateralAsset),\n            100_000 * (10ERC20(address(collateralAsset)).decimals())\n        );\n        try borrower.depositCollateral(_id, _amount, false) {\n            revert('Depositing zero collateral should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:DC1');\n        }\n    }\n\n    function test_depositCollateralFromSavingsAccount() public {\n        request.collateralAssetStrategy = compoundYieldAddress;\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));\n        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);\n        if (request.collateralRatio != 0) {\n            borrower.depositToSavingsAccount(\n                savingsAccountAddress,\n                _collateralRequired,\n                address(collateralAsset),\n                compoundYieldAddress,\n                address(borrower)\n            );\n        }\n        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));\n        emit log_named_uint('total tokens: ', _totalTokens);\n        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            address(borrower),\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);\n        emit log_named_uint('required collateral: ', _collateralRequired);\n        borrower.setAllowanceForSavingsAccount(\n            savingsAccountAddress,\n            _collateralRequired,\n            address(collateralAsset),\n            pooledCreditLineAddress\n        );\n        _helperDepositCollateral(borrower, _id, _collateralRequired, true);\n        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);\n        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);\n        // assertEq(_borrowAbleAmount, _amountToBorrow);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);\n        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.withdrawAllCollateral(_id, true);\n        }\n        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            address(borrower),\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);\n        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(\n            pooledCreditLineAddress,\n            address(collateralAsset),\n            address(compoundYieldAddress)\n        );\n        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);\n        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);\n    }\n\n    function test_adminCannotCancelRequest() public {\n        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));\n    }\n\n    function test_lenderCannotCancelRequest() public {\n        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);\n    }\n\n    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {\n        if (_actor == address(admin)) {\n            try admin.cancelRequest(_id) {\n                revert('Admin cannot cancel PCL');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        } else {\n            PCLUser _user = PCLUser(_actor);\n            try _user.cancelRequest(_id) {\n                revert('Invalid actor cannot cancel PCL');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:OCLB1');\n            }\n        }\n    }\n\n    function test_borrowerCannotCancelRequest() public {\n        assert_borrowerCannotCancelRequest(requestId);\n    }\n\n    function assert_borrowerCannotCancelRequest(uint256 _id) public {\n        try borrower.cancelRequest(_id) {\n            revert('Canceling a PCL in active stage should fail');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {\n        _seed = scaleToRange128(_seed, 1, 10);\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);\n        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n\n        try borrower.repay(_id, 1) {\n            revert('Borrower should not be able to repay zero current debt');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:REP3');\n        }\n    }\n\n    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {\n        _seed = scaleToRange128(_seed, 1, 10);\n        uint256 _amountToBorrow = request.borrowLimit;\n\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);\n        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);\n    }\n\n    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {\n        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n        uint256 _borrowAssetDecimalScaling = 10(ERC20(address(borrowAsset)).decimals());\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);\n\n        try borrower.repay(_id, 1) {\n            revert('Borrower should not be able to repay if interest is zero');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:REP4');\n        }\n    }\n\n    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);\n        log_named_uint('lender lp balance: ', _balance);\n        try _lender.transferLPTokens(address(borrower), _id, _balance) {\n            revert('should not have been possible to send LP tokens to the borrower');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT2');\n        }\n    }\n\n    function test_borrowerCannotReceivePoolTokens() public {\n        assert_borrowerCannotReceivePoolTokens(requestId);\n        request.borrowerVerifier = mockAdminVerifier1;\n        borrower.registerSelf(mockAdminVerifier1);\n        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);\n        assert_borrowerCannotReceivePoolTokens(_id);\n    }\n\n    function assert_canTransferPoolTokensToVerifiedUser(\n        uint256 _id,\n        address _recevingAddress,\n        uint256 _amount\n    ) public {\n        // borrowing some tokens\n        {\n            uint256 _borrowAssetDecimalScaling = 10(ERC20(address(borrowAsset)).decimals());\n            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;\n            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n            _helperDepositCollateral(borrower, _id, _collateralRequired, false);\n            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);\n\n            // going ahead in time to generate interest\n            vm.warp(block.timestamp + 6 days);\n            // repaying the interest and some principal back\n            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);\n            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);\n        }\n\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender\n        _lender.withdrawInterest(_id);\n\n        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;\n        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;\n        // calculating the receivers interest in shares\n        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);\n        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            receiverInterestInTokens,\n            address(borrowAsset)\n        );\n\n        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);\n        _lender.transferLPTokens(_recevingAddress, _id, _amount);\n\n        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);\n        assertEq(_finalBalance - _prevBalance, _amount);\n\n        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;\n        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;\n        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;\n        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;\n        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);\n    }\n\n    function assert_cannotTransferEcxessPoolTokens(\n        uint256 _id,\n        address _recevingAddress,\n        uint256 _amount\n    ) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {\n            revert('balance less than the amount to transfer');\n        } catch Error(string memory reason) {\n            // assertEq(reason, 'ERC1155: insufficient balance for transfer');\n            assertEq(reason, 'SafeMath: subtraction overflow');\n        }\n    }\n\n    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);\n        log_named_uint('lender lp balance: ', _balance);\n        // testing when user is not verified\n        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {\n            revert('should not have been possible to send LP tokens to not verified user');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT3');\n        }\n    }\n\n    function test_lenderTransfersTokenToAnotherLender() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n        address _recevingAddress = lenders[1].lenderAddress;\n        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);\n        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);\n    }\n\n    function test_lenderTransferTokenToNewUser() public {\n        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));\n\n        // testing when user is verified\n        _newUser.registerSelf(mockAdminVerifier1);\n\n        LenderInfo memory _lenderInfo = lenders[0];\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n\n        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);\n    }\n\n    function test_areTokensTransferable() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        LenderInfo memory _lenderInfo = lenders[0];\n\n        address _recevingAddress = lenders[1].lenderAddress;\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {\n            revert('should not have been possible to send LP tokens to the borrower');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT5');\n        }\n    }\n\n    function test_canTransferPoolTokensWhenZeroInterest() public {\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);\n        assertGe(_startBalanceLenderFrom, 0);\n        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);\n\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);\n        assertGe(_startBalanceLenderTo, 0);\n        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);\n\n        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);\n        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));\n        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));\n    }\n\n    function test_cannotWithdrawZeroInterest() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n\n        // cannot withdraw zero interest\n        vm.expectRevert(bytes('LP:WI1'));\n        _lender.withdrawInterest(requestId);\n    }\n\n    function test_newPoolTokenHolderCanWithdrawInterest() public {\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _newUser.registerSelf(mockAdminVerifier1);\n        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);\n        _lender.transferLPTokens(address(_newUser), requestId, _balance);\n        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);\n        assertEq(_newUserBalance, _balance);\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        borrower.borrow(requestId, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // going ahead in time to generate interest\n        vm.warp(block.timestamp + 6 days);\n        // repaying the interest and some principal back\n        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        borrower.repay(requestId, 10_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // fetch borrowerInterestSharesWithdrawn for new user\n        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;\n        assertEq(_prevBISW, 0);\n        // get the interest for the new user\n        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));\n        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));\n        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser\n        _newUser.withdrawInterest(requestId);\n        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;\n        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;\n        // match the interest shares withdrawn with the interest calculated\n        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);\n    }\n\n    function test_stateAfterBorrow() public {\n        admin.updateProtocolFeeFraction(0);\n\n        uint256 _amountToBorrow = request.borrowLimit;\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n\n        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(\n            _collateralRequired,\n            address(collateralAsset)\n        );\n        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);\n        assertEq(_expectedCollateralShares, _actualCollateralShares);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        emit log_named_uint('borrowable amount', _borrowableAmount);\n        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);\n\n        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));\n        borrower.borrow(requestId, _borrowableAmount);\n        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));\n\n        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);\n        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);\n    }\n\n    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {\n        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());\n        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        emit log_named_uint('_collateralRequired: ', _collateralRequired);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        // borrow some amount\n        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());\n        if (_curBorrowAmount == _amountToBorrow) {\n            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);\n        }\n        borrower.borrow(requestId, _curBorrowAmount);\n        // check borrow able amount\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        if (request.collateralRatio != 0) {\n            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);\n        } else {\n            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);\n        }\n        // now check withdrawableCollateral\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);\n        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);\n    }\n\n    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {\n        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);\n    }\n\n    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {\n        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10_decimals).div(_ratioOfPrices);\n        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));\n    }\n\n    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {\n        if (request.collateralRatio == 0) return;\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);\n        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10ERC20(address(borrowAsset)).decimals()));\n        emit log_named_uint('_maxCollateral: ', _maxCollateral);\n        emit log_named_uint('_minCollateral: ', _minCollateral);\n        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);\n        emit log_named_uint('_collateralAmount: ', _collateralAmount);\n        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);\n        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);\n        // calulating what should borrowed to achieve _collateralRatioToAchieve\n        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10_decimals).mul(pcl.SCALING_FACTOR()).div(\n            _collateralRatioToAchieve\n        );\n        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);\n\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);\n        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);\n        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);\n\n        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);\n        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);\n        if (\n            request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14\n        ) {\n            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);\n            if (_amountToBorrow &gt; _maxBorrowable) {\n                _amountToBorrow = _maxBorrowable;\n            }\n        } else {\n            assertLe(_amountToBorrow, _maxBorrowable);\n        }\n\n        borrower.borrow(requestId, _amountToBorrow);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);\n\n        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);\n        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve\n        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);\n    }\n\n    function test_closeActivePCLOncePrincipalPaidAndEnded() public {\n        // borrowing some tokens\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        borrower.borrow(requestId, 90_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        // going ahead in time to generate interest\n        vm.warp(block.timestamp + 6 days);\n        // repay everything back\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        uint256 _balance = borrowAsset.balanceOf(address(borrower));\n        if (_currentDebt &gt; _balance) {\n            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));\n        }\n        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n        // go to end of pcl\n        vm.warp(block.timestamp + request.collectionPeriod + request.duration);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n        assertEq(0, borrowAsset.balanceOf(address(borrower)));\n    }\n\n    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);\n\n    function test_closeWhenNoCollateral() public {\n        vm.warp(block.timestamp + 6 days);\n        // close\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_closeWhenCollateral() public {\n        uint256 _collateralAmount = 1e2 * 10ERC20(address(collateralAsset)).decimals();\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);\n        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);\n        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));\n        vm.warp(block.timestamp + 6 days);\n        vm.roll(block.number + (6 * 86400) / 20);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));\n        vm.expectEmit(true, true, false, false);\n        emit CollateralSharesWithdrawn(requestId, _shares);\n        // close\n        borrower.close(requestId);\n        // this is equal only when no yield is used\n        // with compund this should be assertLe becuase deposited collateral would earn yield\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));\n        } else {\n            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));\n        }\n    }\n\n    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);\n    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);\n\n    function test_withdrawLiquidatedCollateral() public {\n        if (request.collateralRatio == 0) return;\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);\n        borrower.borrow(requestId, _borrowable.sub(10));\n        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            request.borrowLimit - _borrowable.sub(10),\n            address(borrowAsset)\n        );\n        // going ahead in time to make liquidation possible\n        vm.warp(block.timestamp + 50 days);\n        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);\n        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));\n\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _totalSupply = lp.totalSupply(requestId);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n\n        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            _principalBorowable,\n            address(borrowAsset)\n        );\n        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +\n            _lenderYieldShares;\n\n        vm.expectEmit(true, true, false, false);\n        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);\n        _lender.liquidate(requestId, true);\n        if (request.collateralAssetStrategy == compoundYieldAddress) {\n            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));\n        } else {\n            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));\n        }\n    }\n\n    event PooledCreditLineTerminated(uint256 indexed id);\n\n    function test_terminateAfterLiquidation() public {\n        if (request.collateralRatio == 0) return;\n        // borrowing some tokens\n        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);\n        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);\n        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);\n        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);\n        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);\n        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);\n        borrower.borrow(requestId, _borrowable);\n        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            request.borrowLimit - _borrowable,\n            address(borrowAsset)\n        );\n\n        // going ahead in time to make liquidation possible\n        vm.warp(block.timestamp + request.duration.mul(7).div(11));\n        vm.roll(block.number + request.duration.mul(7).div(11).div(20));\n        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);\n        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));\n\n        LenderInfo memory _lenderInfo = lenders[0];\n        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);\n        uint256 _totalSupply = lp.totalSupply(requestId);\n        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);\n        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(\n            _principalBorowable,\n            address(borrowAsset)\n        );\n        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);\n        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +\n            _lenderYieldShares;\n        vm.expectEmit(true, true, false, false);\n\n        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);\n        _lender.liquidate(requestId, true);\n\n        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));\n        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));\n\n        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));\n        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);\n        // for an active pcl borrowLimit == total amount lent\n        _totalSupply = lp.totalSupply(requestId);\n        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);\n        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);\n        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);\n\n        // now the admin terminates\n        vm.expectEmit(true, true, false, true);\n        emit PooledCreditLineTerminated(requestId);\n        admin.terminate(requestId);\n\n        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));\n\n        if (request.borrowAssetStrategy == compoundYieldAddress) {\n            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));\n        } else {\n            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));\n        }\n    }\n\n    function _helperDepositCollateral(\n        PCLUser _user,\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) private {\n        if (_amount != 0) {\n            _user.depositCollateral(_id, _amount, _fromSavingsAccount);\n        }\n    }\n}\n", 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-27-08 09:26:49 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStage is PCLParent {     using SafeMath for uint256;     using SafeMath for uint128; uint256 requestId;  // enum PooledCreditLineStatus { //     NOT_CREATED, //     REQUESTED, //     ACTIVE, //     CLOSED, //     EXPIRED, //     LIQUIDATED, //     CANCELLED // }  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE); }  function test_cannotStartActivePCL() public {     try borrower.start(requestId) {         revert('cannot start active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     // verified using the borrower verifier instead of lender verifier     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_nonLenderCannotWithdrawLiquidity() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);     try _pooledCreditLineLender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL1');     } }  function test_lenderCannotWithdrawLiquidity() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawLiquidity(requestId) {         revert('Lender cannot withdraw liquidity');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotLendToActivePCL() public {     LenderInfo memory info = lenders[0];     PCLUser lender = PCLUser(info.lenderAddress);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_cannotLendToActivePCLNewLender() public {     // Creating a new lender for lending     PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     lender.registerSelf(mockAdminVerifier1);     admin.transferToken(request.borrowAsset, address(lender), 100_000);     lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);     try lender.lend(requestId, 100_000) {         revert('cannot lend to active pcl');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin)); }  function test_onlyBorrowerCanBorrow() public {     uint256 _amountToBorrow = request.borrowLimit / 2;     PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker)); }  function assert_borrowByInvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _user = PCLUser(_actor);     if (_actor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try admin.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);          try _user.borrow(_id, _amountToBorrow) {             revert('Invalid user should not be able to borrow');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotBorrowMoreThanPossible() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);      try borrower.borrow(_id, _amountBorrowable + 1) {         revert('Borrower should not be able to borrow more than possible');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB3');     } }  function test_borrowerCannotBorrowZeroAmount() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow); }  function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.borrow(_id, 0) {         revert('Borrower should not be able to borrow zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:IB1');     } }  function test_lenderDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress); }  function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress); }  function test_adminDepositsAndCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin)); }  function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin)); }  function assert_DepositAndCannotWithdrawCollateral_InvalidActor(     uint256 _id,     uint256 _amountToBorrow,     address _depositor,     address _withdrawer ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      // Depositing into PCL     if (_depositor == address(admin)) {         admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(admin, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     } else {         PCLUser _user = PCLUser(_depositor);          admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);         _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);          _helperDepositCollateral(_user, _id, _collateralRequired, false);          uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(             _collateralRequired,             address(collateralAsset)         );         uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);         assertEq(_expectedCollateralShares, _actualCollateralShares);     }      // withdrawing from PCL     if (_withdrawer == address(admin)) {         try admin.withdrawCollateral(_id, _collateralRequired, false) {             revert('Admin should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_withdrawer);          try _user.withdrawCollateral(_id, _collateralRequired, false) {             revert('Invalid actor should not be able to withdraw collateral');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanWithdrawCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     if (request.collateralRatio != 0) {         borrower.withdrawCollateral(_id, _withdrawableCollateral, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_lenderDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);     _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(_lender, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try _lender.withdrawAllCollateral(_id, false) {         revert('lender should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_adminDepositsAndCannotWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(admin, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try admin.withdrawAllCollateral(_id, false) {         revert('admin should not be able to withdraw all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:OCLB1');     } }  function test_borrowerCannotWithdrawZeroAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     try borrower.withdrawAllCollateral(_id, false) {         revert('borrower should not be able to withdraw zero all collateral');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  function test_borrowerCannotWithdrawZeroCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      try borrower.withdrawCollateral(_id, 0, false) {         revert('Withdrawing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC2');     } }  function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow); }  function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);      try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {         revert('Withdrawing more collateral than withdrawable should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  function test_borrowerCanWithdrawAllCollateral() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow); }  function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);      _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, false);     }     uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));     assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14); }  function test_cannotCloseIfDebtIsNonZero() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow); }  function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));     borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));     // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));      try borrower.close(_id) {         revert('Borrower should not be able to close with non-zero debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  function test_lenderCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress); }  function test_adminCannotClose() public {     uint256 _amountToBorrow = request.borrowLimit / 2;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin)); }  function assert_invalidActorCannotClose(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, request.minBorrowAmount);      if (_actor == address(admin)) {         try admin.close(_id) {             revert('Admin should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.close(_id) {             revert('Invalid actor should not be able to close PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCanRepayAndClose() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCanRepayAndClose(_id, _amountToBorrow); }  function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(_id, _currentDebt);      _currentDebt = pcl.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0);      borrower.close(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED); }  function test_repayWithInsufficientBalance() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));      uint256 _currentDebt = pcl.calculateCurrentDebt(_id);     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));     try borrower.repay(_id, _currentDebt) {         revert('REVERT: Insufficient Balance');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds allowance');         } else {             assertEq(reason, 'Dai/insufficient-allowance');         }     } }  function test_borrowerCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower)); }  function test_adminCannotLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit;     emit log_named_uint('request.borrowLimit', request.borrowLimit);     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin)); }  function assert_InvalidActorCannotLiquidate(     uint256 _id,     uint256 _amountToBorrow,     address _actor ) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      if (_actor == address(admin)) {         try admin.liquidate(_id, true) {             revert('admin liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } else {         PCLUser _user = PCLUser(_actor);          try _user.liquidate(_id, true) {             revert('Invalid actor liquidating should revert');         } catch Error(string memory reason) {             assertEq(reason, 'LP:LIQ1');         }     } }  function test_onlyLendersCanLiquidate() public {     uint256 _amountToBorrow = request.borrowLimit / 3;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyLendersCanLiquidate(_id, _amountToBorrow); }  function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {     if (request.collateralRatio == 0) return;     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(_id);     borrower.borrow(_id, _borrowable);      vm.warp(block.timestamp + (request.duration / 2));      if (!isForked) {         MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);     }      PCLUser _lender = PCLUser(lenders[1].lenderAddress);     uint256 _amountLent = lenders[1].amount;     _lender.liquidate(_id, true);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_lenderCannotLiquidateZeroPrincipal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with zero principal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow); }  function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, _amountToBorrow / 2);      vm.warp(block.timestamp + (request.duration / 2));     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.liquidate(_id, true) {         revert('Lender liquidating should revert with if collateral ratio is more than ideal');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  function test_borrowerCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_borrowerCannotTerminate(_id); }  function assert_borrowerCannotTerminate(uint256 _id) public {     try borrower.terminate(_id) {         revert('Borrower terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_lenderCannotTerminate() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_lenderCannotTerminate(_id); }  function assert_lenderCannotTerminate(uint256 _id) public {     PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));     try _lender.terminate(_id) {         revert('Lender terminating PCL should fail');     } catch Error(string memory reason) {         assertEq(reason, 'Ownable: caller is not the owner');     } }  function test_onlyAdminCanTerminate() public {     uint256 _amountToBorrow = request.borrowLimit;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_onlyAdminCanTerminate(_id, _amountToBorrow); }  function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));      vm.warp(block.timestamp + (request.duration / 2));     vm.roll(block.number + (request.duration / (2 * 20)));      uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));     admin.terminate(_id);     uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));     uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     } else {         assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);     }     if (request.borrowAssetStrategy == compoundYieldAddress) {         assertGe(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } else {         assertEq(             _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,             (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())         );     } }  function test_depositCollateral() public {     uint256 _amount = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositCollateral(_id, _amount); }  function assert_depositCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());     admin.transferToken(address(collateralAsset), address(borrower), _amount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);     borrower.depositCollateral(_id, _amount, false);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));     assertEq(pcl.depositedCollateralInShares(_id), _shares); }  function test_depositCollateral_insufficientBalance() public {     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);      admin.transferToken(address(collateralAsset), address(borrower), 10);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);     try borrower.depositCollateral(_id, 100, false) {         revert('Insufficient Balance of collateral tokens');     } catch Error(string memory reason) {         if (!isForked) {             assertEq(reason, 'ERC20: transfer amount exceeds balance');         } else {             assertEq(reason, 'SafeERC20: low-level call failed');         }     } }  function test_depositZeroCollateral() public {     uint256 _amount = 0;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);     assert_depositZeroCollateral(_id, _amount); }  function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {     // lender.lend(_id, _amount);     admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));     borrower.setAllowance(         pooledCreditLineAddress,         address(collateralAsset),         100_000 * (10**ERC20(address(collateralAsset)).decimals())     );     try borrower.depositCollateral(_id, _amount, false) {         revert('Depositing zero collateral should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC1');     } }  function test_depositCollateralFromSavingsAccount() public {     request.collateralAssetStrategy = compoundYieldAddress;     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));     emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);     if (request.collateralRatio != 0) {         borrower.depositToSavingsAccount(             savingsAccountAddress,             _collateralRequired,             address(collateralAsset),             compoundYieldAddress,             address(borrower)         );     }     uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));     emit log_named_uint('total tokens: ', _totalTokens);     uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);     emit log_named_uint('required collateral: ', _collateralRequired);     borrower.setAllowanceForSavingsAccount(         savingsAccountAddress,         _collateralRequired,         address(collateralAsset),         pooledCreditLineAddress     );     _helperDepositCollateral(borrower, _id, _collateralRequired, true);     uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);     emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);     // assertEq(_borrowAbleAmount, _amountToBorrow);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);     if (request.collateralRatio != 0) {         borrower.withdrawAllCollateral(_id, true);     }     uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         address(borrower),         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);     uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(         pooledCreditLineAddress,         address(collateralAsset),         address(compoundYieldAddress)     );     emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);     assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14); }  function test_adminCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, address(admin)); }  function test_lenderCannotCancelRequest() public {     assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress); }  function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {     if (_actor == address(admin)) {         try admin.cancelRequest(_id) {             revert('Admin cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } else {         PCLUser _user = PCLUser(_actor);         try _user.cancelRequest(_id) {             revert('Invalid actor cannot cancel PCL');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:OCLB1');         }     } }  function test_borrowerCannotCancelRequest() public {     assert_borrowerCannotCancelRequest(requestId); }  function assert_borrowerCannotCancelRequest(uint256 _id) public {     try borrower.cancelRequest(_id) {         revert('Canceling a PCL in active stage should fail');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow); }  function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay zero current debt');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP3');     } }  function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {     _seed = scaleToRange128(_seed, 1, 10);     uint256 _amountToBorrow = request.borrowLimit;      (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);     assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow); }  function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {     uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);     uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());      admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, _id, _collateralRequired, false);     borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);      try borrower.repay(_id, 1) {         revert('Borrower should not be able to repay if interest is zero');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:REP4');     } }  function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     try _lender.transferLPTokens(address(borrower), _id, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_borrowerCannotReceivePoolTokens() public {     assert_borrowerCannotReceivePoolTokens(requestId);     request.borrowerVerifier = mockAdminVerifier1;     borrower.registerSelf(mockAdminVerifier1);     (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);     assert_borrowerCannotReceivePoolTokens(_id); }  function assert_canTransferPoolTokensToVerifiedUser(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     // borrowing some tokens     {         uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());         uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;         uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);         admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);         borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);         _helperDepositCollateral(borrower, _id, _collateralRequired, false);         borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);          // going ahead in time to generate interest         vm.warp(block.timestamp + 6 days);         // repaying the interest and some principal back         borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);         borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);     }      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender     _lender.withdrawInterest(_id);      uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     // calculating the receivers interest in shares     uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);     uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         receiverInterestInTokens,         address(borrowAsset)     );      uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);     _lender.transferLPTokens(_recevingAddress, _id, _amount);      uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);     assertEq(_finalBalance - _prevBalance, _amount);      uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;     curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;     uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;     curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;     assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14); }  function assert_cannotTransferEcxessPoolTokens(     uint256 _id,     address _recevingAddress,     uint256 _amount ) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _id, _amount) {         revert('balance less than the amount to transfer');     } catch Error(string memory reason) {         // assertEq(reason, 'ERC1155: insufficient balance for transfer');         assertEq(reason, 'SafeMath: subtraction overflow');     } }  function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);     log_named_uint('lender lp balance: ', _balance);     // testing when user is not verified     try _lender.transferLPTokens(_newUserAddress, _id, _balance) {         revert('should not have been possible to send LP tokens to not verified user');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT3');     } }  function test_lenderTransfersTokenToAnotherLender() public {     LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     address _recevingAddress = lenders[1].lenderAddress;     assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);     assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance); }  function test_lenderTransferTokenToNewUser() public {     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));      // testing when user is verified     _newUser.registerSelf(mockAdminVerifier1);      LenderInfo memory _lenderInfo = lenders[0];     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);      assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3); }  function test_areTokensTransferable() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     LenderInfo memory _lenderInfo = lenders[0];      address _recevingAddress = lenders[1].lenderAddress;     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {         revert('should not have been possible to send LP tokens to the borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  function test_canTransferPoolTokensWhenZeroInterest() public {     PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);     assertGe(_startBalanceLenderFrom, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);      PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);     uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);     assertGe(_startBalanceLenderTo, 0);     assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);      _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);     assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));     assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo)); }  function test_cannotWithdrawZeroInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);      // cannot withdraw zero interest     vm.expectRevert(bytes('LP:WI1'));     _lender.withdrawInterest(requestId); }  function test_newPoolTokenHolderCanWithdrawInterest() public {     LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _newUser.registerSelf(mockAdminVerifier1);     uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);     _lender.transferLPTokens(address(_newUser), requestId, _balance);     uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);     assertEq(_newUserBalance, _balance);     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repaying the interest and some principal back     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // fetch borrowerInterestSharesWithdrawn for new user     uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     assertEq(_prevBISW, 0);     // get the interest for the new user     uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));     uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));     // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser     _newUser.withdrawInterest(requestId);     uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;     uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;     // match the interest shares withdrawn with the interest calculated     assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14); }  function test_stateAfterBorrow() public {     admin.updateProtocolFeeFraction(0);      uint256 _amountToBorrow = request.borrowLimit;     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);      uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(         _collateralRequired,         address(collateralAsset)     );     uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);     assertEq(_expectedCollateralShares, _actualCollateralShares);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('borrowable amount', _borrowableAmount);     assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);      uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));     borrower.borrow(requestId, _borrowableAmount);     uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));      assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);     assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14); }  function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());     _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     emit log_named_uint('_collateralRequired: ', _collateralRequired);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     // borrow some amount     uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());     if (_curBorrowAmount == _amountToBorrow) {         _curBorrowAmount = _curBorrowAmount.mul(90).div(100);     }     borrower.borrow(requestId, _curBorrowAmount);     // check borrow able amount     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     if (request.collateralRatio != 0) {         assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);     } else {         assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);     }     // now check withdrawableCollateral     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);     assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14); }  function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {     assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction); }  function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {     _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);     assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount)); }  function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {     if (request.collateralRatio == 0) return;     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);     uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));     emit log_named_uint('_maxCollateral: ', _maxCollateral);     emit log_named_uint('_minCollateral: ', _minCollateral);     _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);     emit log_named_uint('_collateralAmount: ', _collateralAmount);     _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);     emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);     // calulating what should borrowed to achieve _collateralRatioToAchieve     uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(         _collateralRatioToAchieve     );     emit log_named_uint('_amountToBorrow: ', _amountToBorrow);      admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);      uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);     emit log_named_uint('_maxBorrowable: ', _maxBorrowable);     if (         request.collateralRatio != 0 &amp;&amp; ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio &lt;= 1e14     ) {         assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);         if (_amountToBorrow &gt; _maxBorrowable) {             _amountToBorrow = _maxBorrowable;         }     } else {         assertLe(_amountToBorrow, _maxBorrowable);     }      borrower.borrow(requestId, _amountToBorrow);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);      uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);     // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve     assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14); }  function test_closeActivePCLOncePrincipalPaidAndEnded() public {     // borrowing some tokens     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));     // going ahead in time to generate interest     vm.warp(block.timestamp + 6 days);     // repay everything back     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _balance = borrowAsset.balanceOf(address(borrower));     if (_currentDebt &gt; _balance) {         admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));     }     borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);     // go to end of pcl     vm.warp(block.timestamp + request.collectionPeriod + request.duration);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);     assertEq(0, borrowAsset.balanceOf(address(borrower))); }  event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);  function test_closeWhenNoCollateral() public {     vm.warp(block.timestamp + 6 days);     // close     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_closeWhenCollateral() public {     uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();     admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);     _helperDepositCollateral(borrower, requestId, _collateralAmount, false);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     vm.warp(block.timestamp + 6 days);     vm.roll(block.number + (6 * 86400) / 20);     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));     vm.expectEmit(true, true, false, false);     emit CollateralSharesWithdrawn(requestId, _shares);     // close     borrower.close(requestId);     // this is equal only when no yield is used     // with compund this should be assertLe becuase deposited collateral would earn yield     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } else {         assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));     } }  event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare); event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);  function test_withdrawLiquidatedCollateral() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable.sub(10));     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable.sub(10),         address(borrowAsset)     );     // going ahead in time to make liquidation possible     vm.warp(block.timestamp + 50 days);     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);      uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;      vm.expectEmit(true, true, false, false);     emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);     if (request.collateralAssetStrategy == compoundYieldAddress) {         assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } else {         assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));     } }  event PooledCreditLineTerminated(uint256 indexed id);  function test_terminateAfterLiquidation() public {     if (request.collateralRatio == 0) return;     // borrowing some tokens     uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);     uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);     admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);     borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);     _helperDepositCollateral(borrower, requestId, _collateralRequired, false);     uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);     borrower.borrow(requestId, _borrowable);     uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(         request.borrowLimit - _borrowable,         address(borrowAsset)     );      // going ahead in time to make liquidation possible     vm.warp(block.timestamp + request.duration.mul(7).div(11));     vm.roll(block.number + request.duration.mul(7).div(11).div(20));     assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);     uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));      LenderInfo memory _lenderInfo = lenders[0];     PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);     uint256 _totalSupply = lp.totalSupply(requestId);     uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);     uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);     uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);     uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(         _principalBorowable,         address(borrowAsset)     );     uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);     uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +         _lenderYieldShares;     vm.expectEmit(true, true, false, false);      emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);     _lender.liquidate(requestId, true);      uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));     uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));      uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));     emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);     // for an active pcl borrowLimit == total amount lent     _totalSupply = lp.totalSupply(requestId);     // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);     // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);     // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);      // now the admin terminates     vm.expectEmit(true, true, false, true);     emit PooledCreditLineTerminated(requestId);     admin.terminate(requestId);      assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));      if (request.borrowAssetStrategy == compoundYieldAddress) {         // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } else {         // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));     } }  function _helperDepositCollateral(     PCLUser _user,     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) private {     if (_amount != 0) {         _user.depositCollateral(_id, _amount, _fromSavingsAccount);     } }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:26:49 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

