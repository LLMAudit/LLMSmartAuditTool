[2024-27-08 09:26:51 INFO] **[Preprocessing]**

**ChatDev Starts** (20240827092651)

**Timestamp**: 20240827092651

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}


**project_name**: RealWorld_BA_101_PCLLiquidatedStage.t

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_101_PCLLiquidatedStage.t_RealWord_20240827092651.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-27-08 09:26:51 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId; address lender_0;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     lender_0 = lenders[0].lenderAddress;      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 10);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 200);      // Now we travel past the expiration date     vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      // Now the PCL should be in the LIQUIDATED state     PCLUser(lender_0).liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated'); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Liquidated PCL cannot be started function assert_start_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1'); }  function test_borrowerCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1'); }  function test_lenderCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in liquidated state',         'LP:S1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1'); }  function test_lenderCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in liquidated state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1'); }  function test_lenderCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a liquidated PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the Liquidated state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrowALiquidatedPCL() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB3'     ); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB1'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInLiquidatedState(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     admin.transferToken(address(borrowAsset), address(_user), 100);     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), 100);     }      try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_borrowerCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_lenderCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw collateral in Liquidated state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw zero collateral in Liquidated state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_Liquidated_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawLiquidity(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Liquidated PCL cannot be liquidated',         'PCL:L2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue(             (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                 (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                 true         );          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } }  function test_adminCanTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         borrower,         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_liquidated_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          //Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          vm.warp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 10);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.repay(_requestId, currentDebt / 200);      vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);      assert_pool_token_transfer_in_liquidated_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user == PCLUser(lenders[1].lenderAddress)) {         uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));         _user.withdrawTokensAfterLiquidation(_id);         uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));         assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);         if (request.collateralRatio != 0) {             assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);         }     } else {         try _user.withdrawTokensAfterLiquidation(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         admin,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         borrower,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_lenderCanWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentCR; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal; uint256 _currentDebt; uint256 collateralHeld;  function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);      log_named_uint('CD', _currentDebt);     log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);      if (request.collateralRatio != 0) {         (, , , , collateralHeld) = lp.pooledCLVariables(_id);          log_named_uint('Collateral Held', collateralHeld);          if (request.collateralAssetStrategy == compoundYieldAddress) {             assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)         } else {             // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');         }     } else {         log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral         assertGt(_equivalentCollateralTokens, 0);     }      // The currentCr is coming to be more than idealCR. Discuss.      // 0. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     if (request.collateralRatio != 0) {         // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away     } else {         assertTrue(true);     }      // 1. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without withdrawnLiquidation');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL2');     }      // 2. withdrawableCollateral     (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation     uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);     uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(         _remainingCollateralInShares,         address(collateralAsset)     );     uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);      assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been liquidated or not      // 6. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     log_named_uint('First Interest Repaid', _totalInterestRepaid);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt'); }  function test_helperFunctionsInLiquidatedState() public {     assert_helper_functionalities_in_liquidated_state(requestId); }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 requestId;\n    address lender_0;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        lender_0 = lenders[0].lenderAddress;\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 10);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, currentDebt / 200);\n\n        // Now we travel past the expiration date\n        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n\n        // Now the PCL should be in the LIQUIDATED state\n        PCLUser(lender_0).liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test0: Test SetUp\n    function test_SetUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // START function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // Test1: Liquidated PCL cannot be started\n    function assert_start_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertString,\n        string memory _errorString\n    ) public {\n        try _user.start(_id) {\n            revert(_revertString);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorString);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_adminCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');\n    }\n\n    function test_borrowerCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');\n    }\n\n    function test_lenderCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot start a PCL in liquidated state',\n            'LP:S1'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CANCEL function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_cancel_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_adminCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');\n    }\n\n    function test_lenderCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot Cancel a PCL in liquidated state',\n            'PCL:OCLB1'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CLOSE function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_close_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_adminCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');\n    }\n\n    function test_lenderCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot close a liquidated PCL',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Deposit collateral function calls\n    *******************/\n\n    function assert_collateralCannotBeDepositedInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        if (_depositor != borrower) {\n            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n        }\n\n        try _depositor.depositCollateral(_id, _amount, false) {\n            revert('Collateral cannot be deposited in the Liquidated state');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:DC2');\n        }\n    }\n\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);\n    }\n\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);\n    }\n\n    /*******************\n    Borrow function tests\n    *******************/\n\n    function assertBorrowFunctionalityInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Admin cannot borrow a PCL in Liquidated state',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotBorrowALiquidatedPCL() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot borrow a PCL in Liquidated state',\n            'PCL:IB3'\n        );\n    }\n\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot borrow a PCL in Liquidated state',\n            'PCL:IB1'\n        );\n    }\n\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Lender cannot borrow a PCL in Liquidated state',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Repay function tests\n    *******************/\n\n    function assertRepayFunctionalityInLiquidatedState(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        admin.transferToken(address(borrowAsset), address(_user), 100);\n        if (_user != borrower) {\n            _user.setAllowance(address(pcl), address(borrowAsset), 100);\n        }\n\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Admin cannot repay a Liquidated PCL',\n            'PCL:REP2'\n        );\n    }\n\n    function test_borrowerCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot repay a Liquidated PCL',\n            'PCL:REP2'\n        );\n    }\n\n    function test_lenderCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Lender cannot repay a Liquidated PCL',\n            'PCL:REP2'\n        );\n    }\n\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n\n    function assertWithdrawCollateralFunctionalityInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawAllCollateral(_id, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertGe(_balanceAfter, _balanceBefore);\n        } else {\n            try _user.withdrawAllCollateral(_id, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessageAll);\n            }\n        }\n\n        if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawCollateral(_id, _amount, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);\n        } else {\n            try _user.withdrawCollateral(_id, _amount, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n    }\n\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Admin cannot withdraw collateral in Liquidated state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot withdraw collateral in Liquidated state',\n            'PCL:WC1',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot withdraw zero collateral in Liquidated state',\n            'PCL:WC2',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Lender cannot withdraw collateral in Liquidated state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    WithdrawLiquidity function calls\n    ********************/\n\n    function assert_withdraw_liquidity_functionality_in_Liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.withdrawLiquidity(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Admin cannot withdraw liquidity a PCL in Liquidated state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot withdraw liquidity a PCL in Liquidated state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Lender cannot withdraw liquidity a PCL in Liquidated state',\n            'LP:IWL2'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // LIQUIDATE function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_liquidate_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_adminCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');\n    }\n\n    function test_borrowerCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');\n    }\n\n    function test_lenderCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Liquidated PCL cannot be liquidated',\n            'PCL:L2'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Terminate function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_terminate_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));\n\n        try _user.terminate(_id) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n\n            if (_user == admin) {\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);\n                assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);\n                if (request.collateralRatio != 0) {\n                    assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);\n                }\n            } else {\n                assertTrue(\n                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                        true\n                );\n                revert(_revertMessage);\n            }\n        } catch Error(string memory reason) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n\n            assertTrue(\n                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                    true\n            );\n\n            assertEq(reason, _errorMessage);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        }\n    }\n\n    function test_adminCanTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');\n    }\n\n    function test_borrowerCannotTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(\n            requestId,\n            borrower,\n            'Cannot terminate a PCL that is liquidated',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    function test_lenderCannotTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Cannot terminate a PCL that is liquidated',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Pool Token Transfer function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    uint256 lender0PoolTokenBalance;\n    uint256 lender1PoolTokenBalance;\n    uint256 lender2PoolTokenBalance;\n    uint256 lender3PoolTokenBalance;\n    uint256 _from1BalancePostBurn;\n    uint256 lender0PoolTokenBalanceFinal;\n    uint256 lender1PoolTokenBalanceFinal;\n    uint256 lender2PoolTokenBalanceFinal;\n    uint256 lender3PoolTokenBalanceFinal;\n    uint256 _defaultTimeStamp;\n\n    PCLUser _from1;\n    PCLUser _from2;\n    PCLUser _to1;\n    PCLUser _to2;\n\n    function assert_pool_token_transfer_in_liquidated_stage(\n        uint256 _id,\n        uint256 _fractionOfPTSupply,\n        bool _positiveCase,\n        address _From1,\n        address _From2,\n        address _To1,\n        address _To2,\n        string memory _errorString\n    ) public {\n        _from1 = PCLUser(_From1);\n        _from2 = PCLUser(_From2);\n        _to1 = PCLUser(_To1);\n        _to2 = PCLUser(_To2);\n\n        if (_positiveCase) {\n            // Ensuring that these lenders indeed had lent something\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);\n            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);\n\n            assertGt(lender0PoolTokenBalance, 0);\n            assertGt(lender1PoolTokenBalance, 0);\n            assertGt(lender2PoolTokenBalance, 0);\n            assertGt(lender3PoolTokenBalance, 0);\n\n            // Lender0 transfers pool tokens to lender1\n            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));\n\n            //Checking the transfer took place or not\n            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);\n\n            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));\n            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));\n\n            vm.warp(block.timestamp + request.defaultGracePeriod);\n\n            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);\n\n            // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');\n\n            // Lender2 transfers pool tokens to lender3\n            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);\n\n            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);\n\n            // Checking whether the transfer took place or not\n            assertTrue(lender2PoolTokenBalanceFinal == 0);\n            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {\n                if (_To1 == address(0)) {\n                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);\n                    assertEq(_from1BalancePostBurn, 0);\n                } else {\n                    revert('REVERT');\n                }\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorString);\n            }\n        }\n    }\n\n    function test_poolTokenTransferComplete_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartial_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            2,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartialByFour_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            4,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_cannotBurnPoolToken_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(0),\n            address(0),\n            'ERC1155: transfer to the zero address'\n        );\n    }\n\n    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[0].lenderAddress,\n            address(0),\n            'LP:IT1'\n        );\n    }\n\n    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            protocolFeeCollectorAddress,\n            address(0),\n            'LP:IT3'\n        );\n    }\n\n    function test_cannotTransferLPTokensToBorrower() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(borrower),\n            address(0),\n            'LP:IT2'\n        );\n    }\n\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_requestId, _requiredCollateral, false);\n        }\n\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount);\n\n        vm.warp(block.timestamp + request.duration / 10);\n        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.repay(_requestId, currentDebt / 200);\n\n        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n\n        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);\n\n        assert_pool_token_transfer_in_liquidated_stage(\n            _requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[1].lenderAddress,\n            address(0),\n            'LP:IT5'\n        );\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert('External user cannot create');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert('External user cannot terminate');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert('Lender cannot lend zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L1');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Unverified lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L2');\n        }\n    }\n\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Interest function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_withdraw_interest_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);\n            }\n\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');\n    }\n\n    function test_borrowerCannotWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');\n    }\n\n    function test_lendersCanWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Liquidation function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_withdraw_liquidation_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_user == PCLUser(lenders[1].lenderAddress)) {\n            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));\n            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));\n            _user.withdrawTokensAfterLiquidation(_id);\n            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));\n            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));\n            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);\n            if (request.collateralRatio != 0) {\n                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);\n            }\n        } else {\n            try _user.withdrawTokensAfterLiquidation(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n    }\n\n    function test_adminCannotWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(\n            requestId,\n            admin,\n            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',\n            'LP:WLC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(\n            requestId,\n            borrower,\n            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',\n            'LP:WLC1'\n        );\n    }\n\n    function test_lenderCanWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // View/calculation function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    uint256 _currentCR;\n    uint256 _totalInterestPending;\n    uint256 _totalInterestRepaid;\n    uint256 _principal;\n    uint256 _currentDebt;\n    uint256 collateralHeld;\n\n    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 0. collateralTokensToLiquidate\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);\n\n        log_named_uint('CD', _currentDebt);\n        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);\n\n        if (request.collateralRatio != 0) {\n            (, , , , collateralHeld) = lp.pooledCLVariables(_id);\n\n            log_named_uint('Collateral Held', collateralHeld);\n\n            if (request.collateralAssetStrategy == compoundYieldAddress) {\n                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)\n            } else {\n                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');\n            }\n        } else {\n            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral\n            assertGt(_equivalentCollateralTokens, 0);\n        }\n\n        // The currentCr is coming to be more than idealCR. Discuss.\n\n        // 0. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        if (request.collateralRatio != 0) {\n            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away\n        } else {\n            assertTrue(true);\n        }\n\n        // 1. calculatePrincipalWithdrawable\n        try _lender.withdrawLiquidity(_id) {\n            revert('Cannot be called without withdrawnLiquidation');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL2');\n        }\n\n        // 2. withdrawableCollateral\n        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation\n        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);\n        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(\n            _remainingCollateralInShares,\n            address(collateralAsset)\n        );\n        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n\n        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');\n\n        // 3.calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');\n\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now\n\n        // 5. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment\n        // doesn't matter whether the PCL has been liquidated or not\n\n        // 6. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);\n        _totalInterestPending = _borrower.calculateInterestAccrued(_id);\n        log_named_uint('First Interest Repaid', _totalInterestRepaid);\n        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;\n        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');\n    }\n\n    function test_helperFunctionsInLiquidatedState() public {\n        assert_helper_functionalities_in_liquidated_state(requestId);\n    }\n}\n"} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:26:51 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId; address lender_0;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     lender_0 = lenders[0].lenderAddress;      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 10);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 200);      // Now we travel past the expiration date     vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      // Now the PCL should be in the LIQUIDATED state     PCLUser(lender_0).liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated'); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Liquidated PCL cannot be started function assert_start_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1'); }  function test_borrowerCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1'); }  function test_lenderCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in liquidated state',         'LP:S1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1'); }  function test_lenderCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in liquidated state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1'); }  function test_lenderCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a liquidated PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the Liquidated state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrowALiquidatedPCL() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB3'     ); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB1'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInLiquidatedState(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     admin.transferToken(address(borrowAsset), address(_user), 100);     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), 100);     }      try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_borrowerCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_lenderCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw collateral in Liquidated state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw zero collateral in Liquidated state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_Liquidated_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawLiquidity(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Liquidated PCL cannot be liquidated',         'PCL:L2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue(             (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                 (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                 true         );          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } }  function test_adminCanTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         borrower,         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_liquidated_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          //Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          vm.warp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 10);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.repay(_requestId, currentDebt / 200);      vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);      assert_pool_token_transfer_in_liquidated_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user == PCLUser(lenders[1].lenderAddress)) {         uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));         _user.withdrawTokensAfterLiquidation(_id);         uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));         assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);         if (request.collateralRatio != 0) {             assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);         }     } else {         try _user.withdrawTokensAfterLiquidation(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         admin,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         borrower,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_lenderCanWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentCR; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal; uint256 _currentDebt; uint256 collateralHeld;  function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);      log_named_uint('CD', _currentDebt);     log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);      if (request.collateralRatio != 0) {         (, , , , collateralHeld) = lp.pooledCLVariables(_id);          log_named_uint('Collateral Held', collateralHeld);          if (request.collateralAssetStrategy == compoundYieldAddress) {             assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)         } else {             // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');         }     } else {         log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral         assertGt(_equivalentCollateralTokens, 0);     }      // The currentCr is coming to be more than idealCR. Discuss.      // 0. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     if (request.collateralRatio != 0) {         // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away     } else {         assertTrue(true);     }      // 1. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without withdrawnLiquidation');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL2');     }      // 2. withdrawableCollateral     (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation     uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);     uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(         _remainingCollateralInShares,         address(collateralAsset)     );     uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);      assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been liquidated or not      // 6. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     log_named_uint('First Interest Repaid', _totalInterestRepaid);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt'); }  function test_helperFunctionsInLiquidatedState() public {     assert_helper_functionalities_in_liquidated_state(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:26:51 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-27-08 09:26:54 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:26:54 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19070
completion_tokens: 1
total_tokens: 19071
cost: $-1.000000


[2024-27-08 09:26:54 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
.]

Let's

[2024-27-08 09:26:55 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId; address lender_0;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     lender_0 = lenders[0].lenderAddress;      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 10);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 200);      // Now we travel past the expiration date     vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      // Now the PCL should be in the LIQUIDATED state     PCLUser(lender_0).liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated'); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Liquidated PCL cannot be started function assert_start_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1'); }  function test_borrowerCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1'); }  function test_lenderCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in liquidated state',         'LP:S1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1'); }  function test_lenderCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in liquidated state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1'); }  function test_lenderCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a liquidated PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the Liquidated state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrowALiquidatedPCL() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB3'     ); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB1'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInLiquidatedState(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     admin.transferToken(address(borrowAsset), address(_user), 100);     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), 100);     }      try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_borrowerCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_lenderCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw collateral in Liquidated state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw zero collateral in Liquidated state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_Liquidated_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawLiquidity(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Liquidated PCL cannot be liquidated',         'PCL:L2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue(             (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                 (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                 true         );          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } }  function test_adminCanTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         borrower,         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_liquidated_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          //Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          vm.warp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 10);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.repay(_requestId, currentDebt / 200);      vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);      assert_pool_token_transfer_in_liquidated_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user == PCLUser(lenders[1].lenderAddress)) {         uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));         _user.withdrawTokensAfterLiquidation(_id);         uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));         assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);         if (request.collateralRatio != 0) {             assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);         }     } else {         try _user.withdrawTokensAfterLiquidation(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         admin,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         borrower,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_lenderCanWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentCR; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal; uint256 _currentDebt; uint256 collateralHeld;  function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);      log_named_uint('CD', _currentDebt);     log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);      if (request.collateralRatio != 0) {         (, , , , collateralHeld) = lp.pooledCLVariables(_id);          log_named_uint('Collateral Held', collateralHeld);          if (request.collateralAssetStrategy == compoundYieldAddress) {             assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)         } else {             // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');         }     } else {         log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral         assertGt(_equivalentCollateralTokens, 0);     }      // The currentCr is coming to be more than idealCR. Discuss.      // 0. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     if (request.collateralRatio != 0) {         // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away     } else {         assertTrue(true);     }      // 1. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without withdrawnLiquidation');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL2');     }      // 2. withdrawableCollateral     (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation     uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);     uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(         _remainingCollateralInShares,         address(collateralAsset)     );     uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);      assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been liquidated or not      // 6. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     log_named_uint('First Interest Repaid', _totalInterestRepaid);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt'); }  function test_helperFunctionsInLiquidatedState() public {     assert_helper_functionalities_in_liquidated_state(requestId); }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\nimport \'@openzeppelin/contracts/token/ERC20/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'../../../SublimeProxy.sol\';\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../PooledCreditLine/LenderPool.sol\';\nimport \'../../../PriceOracle.sol\';\nimport \'../../../SavingsAccount/SavingsAccount.sol\';\nimport \'../../../yield/StrategyRegistry.sol\';\nimport \'../../../yield/NoYield.sol\';\nimport \'../../../yield/CompoundYield.sol\';\nimport \'../../../mocks/MockWETH.sol\';\nimport \'../../../mocks/MockCToken.sol\';\nimport \'../../../mocks/MockVerification2.sol\';\nimport \'../../../mocks/MockV3Aggregator.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../../../interfaces/IPooledCreditLineDeclarations.sol\';\nimport \'../../../interfaces/ISavingsAccount.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\ncontract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n    uint256 requestId;\n    address lender_0;\n    function setUp() public virtual override {\n        super.setUp();\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        lender_0 = lenders[0].lenderAddress;\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, \'!Active\');\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 10);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, currentDebt / 200);\n        // Now we travel past the expiration date\n        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, \'!Expired\');\n        // Now the PCL should be in the LIQUIDATED state\n        PCLUser(lender_0).liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n    // Test0: Test SetUp\n    function test_SetUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, \'!Liquidated\');\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // START function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Test1: Liquidated PCL cannot be started\n    function assert_start_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertString,\n        string memory _errorString\n    ) public {\n        try _user.start(_id) {\n            revert(_revertString);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorString);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n    function test_adminCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(requestId, admin, \'Admin cannot start a PCL in liquidated state\', \'LP:S1\');\n    }\n    function test_borrowerCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(requestId, borrower, \'Borrower cannot start a PCL in liquidated state\', \'LP:S1\');\n    }\n    function test_lenderCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot start a PCL in liquidated state\',\n            \'LP:S1\'\n        );\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CANCEL function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_cancel_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n    function test_adminCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(requestId, admin, \'Admin cannot Cancel a PCL in liquidated state\', \'PCL:OCLB1\');\n    }\n    function test_borrowerCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(requestId, borrower, \'Borrower cannot Cancel a PCL in liquidated state\', \'PCL:CR1\');\n    }\n    function test_lenderCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot Cancel a PCL in liquidated state\',\n            \'PCL:OCLB1\'\n        );\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CLOSE function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_close_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n    function test_adminCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(requestId, admin, \'Admin cannot close a liquidated PCL\', \'PCL:OCLB1\');\n    }\n    function test_borrowerCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(requestId, borrower, \'Borrower cannot close a liquidated PCL\', \'PCL:C1\');\n    }\n    function test_lenderCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot close a liquidated PCL\',\n            \'PCL:OCLB1\'\n        );\n    }\n    /*******************\n    Deposit collateral function calls\n    *******************/\n    function assert_collateralCannotBeDepositedInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        if (_depositor != borrower) {\n            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n        }\n        try _depositor.depositCollateral(_id, _amount, false) {\n            revert(\'Collateral cannot be deposited in the Liquidated state\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:DC2\');\n        }\n    }\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);\n    }\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);\n    }\n    /*******************\n    Borrow function tests\n    *******************/\n    function assertBorrowFunctionalityInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Admin cannot borrow a PCL in Liquidated state\',\n            \'PCL:OCLB1\'\n        );\n    }\n    function test_borrowerCannotBorrowALiquidatedPCL() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Borrower cannot borrow a PCL in Liquidated state\',\n            \'PCL:IB3\'\n        );\n    }\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Borrower cannot borrow a PCL in Liquidated state\',\n            \'PCL:IB1\'\n        );\n    }\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Lender cannot borrow a PCL in Liquidated state\',\n            \'PCL:OCLB1\'\n        );\n    }\n    /*******************\n    Repay function tests\n    *******************/\n    function assertRepayFunctionalityInLiquidatedState(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        admin.transferToken(address(borrowAsset), address(_user), 100);\n        if (_user != borrower) {\n            _user.setAllowance(address(pcl), address(borrowAsset), 100);\n        }\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n    function test_adminCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Admin cannot repay a Liquidated PCL\',\n            \'PCL:REP2\'\n        );\n    }\n    function test_borrowerCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Borrower cannot repay a Liquidated PCL\',\n            \'PCL:REP2\'\n        );\n    }\n    function test_lenderCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Lender cannot repay a Liquidated PCL\',\n            \'PCL:REP2\'\n        );\n    }\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n    function assertWithdrawCollateralFunctionalityInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawAllCollateral(_id, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertGe(_balanceAfter, _balanceBefore);\n        } else {\n            try _user.withdrawAllCollateral(_id, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessageAll);\n            }\n        }\n        if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawCollateral(_id, _amount, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);\n        } else {\n            try _user.withdrawCollateral(_id, _amount, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n    }\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Admin cannot withdraw collateral in Liquidated state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Borrower cannot withdraw collateral in Liquidated state\',\n            \'PCL:WC1\',\n            \'PCL:WAC1\'\n        );\n    }\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Borrower cannot withdraw zero collateral in Liquidated state\',\n            \'PCL:WC2\',\n            \'PCL:WAC1\'\n        );\n    }\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Lender cannot withdraw collateral in Liquidated state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n    /*******************\n    WithdrawLiquidity function calls\n    *******************/\n    function assert_withdraw_liquidity_functionality_in_Liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.withdrawLiquidity(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Admin cannot withdraw liquidity a PCL in Liquidated state\',\n            \'LP:IWL1\'\n        );\n    }\n    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Borrower cannot withdraw liquidity a PCL in Liquidated state\',\n            \'LP:IWL1\'\n        );\n    }\n    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Lender cannot withdraw liquidity a PCL in Liquidated state\',\n            \'LP:IWL2\'\n        );\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // LIQUIDATE function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_liquidate_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n    function test_adminCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(requestId, admin, \'Admin cannot liquidate an liquidated PCL\', \'LP:LIQ1\');\n    }\n    function test_borrowerCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, \'Borrower cannot liquidate an liquidated PCL\', \'LP:LIQ1\');\n    }\n    function test_lenderCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Liquidated PCL cannot be liquidated\',\n            \'PCL:L2\'\n        );\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Terminate function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_terminate_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));\n        try _user.terminate(_id) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n            if (_user == admin) {\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);\n                assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);\n                if (request.collateralRatio != 0) {\n                    assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);\n                }\n            } else {\n                assertTrue(\n                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                        true\n                );\n                revert(_revertMessage);\n            }\n        } catch Error(string memory reason) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n            assertTrue(\n                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                    true\n            );\n            assertEq(reason, _errorMessage);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        }\n    }\n    function test_adminCanTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(requestId, admin, \'\', \'\');\n    }\n    function test_borrowerCannotTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(\n            requestId,\n            borrower,\n            \'Cannot terminate a PCL that is liquidated\',\n            \'Ownable: caller is not the owner\'\n        );\n    }\n    function test_lenderCannotTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Cannot terminate a PCL that is liquidated\',\n            \'Ownable: caller is not the owner\'\n        );\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Pool Token Transfer function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    uint256 lender0PoolTokenBalance;\n    uint256 lender1PoolTokenBalance;\n    uint256 lender2PoolTokenBalance;\n    uint256 lender3PoolTokenBalance;\n    uint256 _from1BalancePostBurn;\n    uint256 lender0PoolTokenBalanceFinal;\n    uint256 lender1PoolTokenBalanceFinal;\n    uint256 lender2PoolTokenBalanceFinal;\n    uint256 lender3PoolTokenBalanceFinal;\n    uint256 _defaultTimeStamp;\n    PCLUser _from1;\n    PCLUser _from2;\n    PCLUser _to1;\n    PCLUser _to2;\n    function assert_pool_token_transfer_in_liquidated_stage(\n        uint256 _id,\n        uint256 _fractionOfPTSupply,\n        bool _positiveCase,\n        address _From1,\n        address _From2,\n        address _To1,\n        address _To2,\n        string memory _errorString\n    ) public {\n        _from1 = PCLUser(_From1);\n        _from2 = PCLUser(_From2);\n        _to1 = PCLUser(_To1);\n        _to2 = PCLUser(_To2);\n        if (_positiveCase) {\n            // Ensuring that these lenders indeed had lent something\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);\n            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);\n            assertGt(lender0PoolTokenBalance, 0);\n            assertGt(lender1PoolTokenBalance, 0);\n            assertGt(lender2PoolTokenBalance, 0);\n            assertGt(lender3PoolTokenBalance, 0);\n            // Lender0 transfers pool tokens to lender1\n            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));\n            //Checking the transfer took place or not\n            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);\n            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));\n            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));\n            vm.warp(block.timestamp + request.defaultGracePeriod);\n            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);\n            // assertTrue(block.timestamp &gt;= _defaultTimeStamp, \'!Still not past default time\');\n            // Lender2 transfers pool tokens to lender3\n            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);\n            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);\n            // Checking whether the transfer took place or not\n            assertTrue(lender2PoolTokenBalanceFinal == 0);\n            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {\n                if (_To1 == address(0)) {\n                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);\n                    assertEq(_from1BalancePostBurn, 0);\n                } else {\n                    revert(\'REVERT\');\n                }\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorString);\n            }\n        }\n    }\n    function test_poolTokenTransferComplete_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            \'\'\n        );\n    }\n    function test_poolTokenTransferPartial_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            2,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            \'\'\n        );\n    }\n    function test_poolTokenTransferPartialByFour_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            4,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            \'\'\n        );\n    }\n    function test_cannotBurnPoolToken_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(0),\n            address(0),\n            \'ERC1155: transfer to the zero address\'\n        );\n    }\n    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[0].lenderAddress,\n            address(0),\n            \'LP:IT1\'\n        );\n    }\n    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            protocolFeeCollectorAddress,\n            address(0),\n            \'LP:IT3\'\n        );\n    }\n    function test_cannotTransferLPTokensToBorrower() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(borrower),\n            address(0),\n            \'LP:IT2\'\n        );\n    }\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, \'!Active\');\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_requestId, _requiredCollateral, false);\n        }\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount);\n        vm.warp(block.timestamp + request.duration / 10);\n        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.repay(_requestId, currentDebt / 200);\n        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, \'!Expired\');\n        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);\n        assert_pool_token_transfer_in_liquidated_stage(\n            _requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[1].lenderAddress,\n            address(0),\n            \'LP:IT5\'\n        );\n    }\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert(\'External user cannot create\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert(\'External user cannot terminate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert(\'Lender cannot lend zero amount\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L1\');\n        }\n    }\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Unverified lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L2\');\n        }\n    }\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L3\');\n        }\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Interest function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_withdraw_interest_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);\n            }\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n    function test_adminCannotWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, admin, \'LP:WI1\');\n    }\n    function test_borrowerCannotWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, borrower, \'LP:WI1\');\n    }\n    function test_lendersCanWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), \'\');\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Liquidation function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_withdraw_liquidation_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_user == PCLUser(lenders[1].lenderAddress)) {\n            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));\n            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));\n            _user.withdrawTokensAfterLiquidation(_id);\n            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));\n            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));\n            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);\n            if (request.collateralRatio != 0) {\n                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);\n            }\n        } else {\n            try _user.withdrawTokensAfterLiquidation(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n    }\n    function test_adminCannotWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(\n            requestId,\n            admin,\n            \'Admin cannot withdraw liquidation/liquidity from an liquidated PCL\',\n            \'LP:WLC1\'\n        );\n    }\n    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(\n            requestId,\n            borrower,\n            \'Admin cannot withdraw liquidation/liquidity from an liquidated PCL\',\n            \'LP:WLC1\'\n        );\n    }\n    function test_lenderCanWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), \'\', \'\');\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // View/calculation function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    uint256 _currentCR;\n    uint256 _totalInterestPending;\n    uint256 _totalInterestRepaid;\n    uint256 _principal;\n    uint256 _currentDebt;\n    uint256 collateralHeld;\n    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        // 0. collateralTokensToLiquidate\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);\n        log_named_uint(\'CD\', _currentDebt);\n        log_named_uint(\'Equivalent Collateral Tokens\', _equivalentCollateralTokens);\n        if (request.collateralRatio != 0) {\n            (, , , , collateralHeld) = lp.pooledCLVariables(_id);\n            log_named_uint(\'Collateral Held\', collateralHeld);\n            if (request.collateralAssetStrategy == compoundYieldAddress) {\n                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)\n            } else {\n                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, \'Collateral Tokens to liquidate\');\n            }\n        } else {\n            log_named_uint(\'CD\', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral\n            assertGt(_equivalentCollateralTokens, 0);\n        }\n        // The currentCr is coming to be more than idealCR. Discuss.\n        // 0. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        if (request.collateralRatio != 0) {\n            // assertEq(request.collateralRatio, _currentCR, \'Current Collateral Ratio\'); // Since a lot of collateral was taken away\n        } else {\n            assertTrue(true);\n        }\n        // 1. calculatePrincipalWithdrawable\n        try _lender.withdrawLiquidity(_id) {\n            revert(\'Cannot be called without withdrawnLiquidation\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWL2\');\n        }\n        // 2. withdrawableCollateral\n        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation\n        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);\n        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(\n            _remainingCollateralInShares,\n            address(collateralAsset)\n        );\n        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, \'Withdrawable Collateral\');\n        // 3.calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, withdrawableCollateral, \'Total Collateral Tokens\');\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0, \'Borrowable Amount\'); // Since PCL is liquidated now\n        // 5. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0, \'Interest Accrued\'); // Should be non-zero, since it calculates interest accrued since last repayment\n        // doesn\'t matter whether the PCL has been liquidated or not\n        // 6. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);\n        _totalInterestPending = _borrower.calculateInterestAccrued(_id);\n        log_named_uint(\'First Interest Repaid\', _totalInterestRepaid);\n        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;\n        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, \'Current Debt\');\n    }\n    function test_helperFunctionsInLiquidatedState() public {\n        assert_helper_functionalities_in_liquidated_state(requestId);\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\nimport \'@openzeppelin/contracts/token/ERC20/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'../../../SublimeProxy.sol\';\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../PooledCreditLine/LenderPool.sol\';\nimport \'../../../PriceOracle.sol\';\nimport \'../../../SavingsAccount/SavingsAccount.sol\';\nimport \'../../../yield/StrategyRegistry.sol\';\nimport \'../../../yield/NoYield.sol\';\nimport \'../../../yield/CompoundYield.sol\';\nimport \'../../../mocks/MockWETH.sol\';\nimport \'../../../mocks/MockCToken.sol\';\nimport \'../../../mocks/MockVerification2.sol\';\nimport \'../../../mocks/MockV3Aggregator.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../../../interfaces/IPooledCreditLineDeclarations.sol\';\nimport \'../../../interfaces/ISavingsAccount.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\ncontract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n    uint256 requestId;\n    address lender_0;\n    function setUp() public virtual override {\n        super.setUp();\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        lender_0 = lenders[0].lenderAddress;\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, \'!Active\');\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 10);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, currentDebt / 200);\n        // Now we travel past the expiration date\n        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, \'!Expired\');\n        // Now the PCL should be in the LIQUIDATED state\n        PCLUser(lender_0).liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n    // Test0: Test SetUp\n    function test_SetUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, \'!Liquidated\');\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // START function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Test1: Liquidated PCL cannot be started\n    function assert_start_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertString,\n        string memory _errorString\n    ) public {\n        try _user.start(_id) {\n            revert(_revertString);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorString);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n    function test_adminCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(requestId, admin, \'Admin cannot start a PCL in liquidated state\', \'LP:S1\');\n    }\n    function test_borrowerCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(requestId, borrower, \'Borrower cannot start a PCL in liquidated state\', \'LP:S1\');\n    }\n    function test_lenderCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot start a PCL in liquidated state\',\n            \'LP:S1\'\n        );\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CANCEL function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_cancel_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n    function test_adminCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(requestId, admin, \'Admin cannot Cancel a PCL in liquidated state\', \'PCL:OCLB1\');\n    }\n    function test_borrowerCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(requestId, borrower, \'Borrower cannot Cancel a PCL in liquidated state\', \'PCL:CR1\');\n    }\n    function test_lenderCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot Cancel a PCL in liquidated state\',\n            \'PCL:OCLB1\'\n        );\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CLOSE function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_close_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n    function test_adminCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(requestId, admin, \'Admin cannot close a liquidated PCL\', \'PCL:OCLB1\');\n    }\n    function test_borrowerCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(requestId, borrower, \'Borrower cannot close a liquidated PCL\', \'PCL:C1\');\n    }\n    function test_lenderCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot close a liquidated PCL\',\n            \'PCL:OCLB1\'\n        );\n    }\n    /********************\n    Deposit collateral function calls\n    *******************/\n    function assert_collateralCannotBeDepositedInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        if (_depositor != borrower) {\n            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n        }\n        try _depositor.depositCollateral(_id, _amount, false) {\n            revert(\'Collateral cannot be deposited in the Liquidated state\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:DC2\');\n        }\n    }\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);\n    }\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);\n    }\n    /*******************\n    Borrow function tests\n    *******************/\n    function assertBorrowFunctionalityInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Admin cannot borrow a PCL in Liquidated state\',\n            \'PCL:OCLB1\'\n        );\n    }\n    function test_borrowerCannotBorrowALiquidatedPCL() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Borrower cannot borrow a PCL in Liquidated state\',\n            \'PCL:IB3\'\n        );\n    }\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Borrower cannot borrow a PCL in Liquidated state\',\n            \'PCL:IB1\'\n        );\n    }\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Lender cannot borrow a PCL in Liquidated state\',\n            \'PCL:OCLB1\'\n        );\n    }\n    /********************\n    Repay function tests\n    ********************/\n    function assertRepayFunctionalityInLiquidatedState(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        admin.transferToken(address(borrowAsset), address(_user), 100);\n        if (_user != borrower) {\n            _user.setAllowance(address(pcl), address(borrowAsset), 100);\n        }\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n    function test_adminCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Admin cannot repay a Liquidated PCL\',\n            \'PCL:REP2\'\n        );\n    }\n    function test_borrowerCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Borrower cannot repay a Liquidated PCL\',\n            \'PCL:REP2\'\n        );\n    }\n    function test_lenderCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Lender cannot repay a Liquidated PCL\',\n            \'PCL:REP2\'\n        );\n    }\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n    function assertWithdrawCollateralFunctionalityInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawAllCollateral(_id, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertGe(_balanceAfter, _balanceBefore);\n        } else {\n            try _user.withdrawAllCollateral(_id, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessageAll);\n            }\n        }\n        if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawCollateral(_id, _amount, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);\n        } else {\n            try _user.withdrawCollateral(_id, _amount, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n    }\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Admin cannot withdraw collateral in Liquidated state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Borrower cannot withdraw collateral in Liquidated state\',\n            \'PCL:WC1\',\n            \'PCL:WAC1\'\n        );\n    }\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Borrower cannot withdraw zero collateral in Liquidated state\',\n            \'PCL:WC2\',\n            \'PCL:WAC1\'\n        );\n    }\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Lender cannot withdraw collateral in Liquidated state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n    /*******************\n    WithdrawLiquidity function calls\n    ********************/\n    function assert_withdraw_liquidity_functionality_in_Liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.withdrawLiquidity(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Admin cannot withdraw liquidity a PCL in Liquidated state\',\n            \'LP:IWL1\'\n        );\n    }\n    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Borrower cannot withdraw liquidity a PCL in Liquidated state\',\n            \'LP:IWL1\'\n        );\n    }\n    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            \'Lender cannot withdraw liquidity a PCL in Liquidated state\',\n            \'LP:IWL2\'\n        );\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // LIQUIDATE function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_liquidate_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n    function test_adminCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(requestId, admin, \'Admin cannot liquidate an liquidated PCL\', \'LP:LIQ1\');\n    }\n    function test_borrowerCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, \'Borrower cannot liquidate an liquidated PCL\', \'LP:LIQ1\');\n    }\n    function test_lenderCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Liquidated PCL cannot be liquidated\',\n            \'PCL:L2\'\n        );\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Terminate function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_terminate_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));\n        try _user.terminate(_id) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n            if (_user == admin) {\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);\n                assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);\n                if (request.collateralRatio != 0) {\n                    assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);\n                }\n            } else {\n                assertTrue(\n                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                        true\n                );\n                revert(_revertMessage);\n            }\n        } catch Error(string memory reason) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n            assertTrue(\n                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                    true\n            );\n            assertEq(reason, _errorMessage);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        }\n    }\n    function test_adminCanTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(requestId, admin, \'\', \'\');\n    }\n    function test_borrowerCannotTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(\n            requestId,\n            borrower,\n            \'Cannot terminate a PCL that is liquidated\',\n            \'Ownable: caller is not the owner\'\n        );\n    }\n    function test_lenderCannotTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Cannot terminate a PCL that is liquidated\',\n            \'Ownable: caller is not the owner\'\n        );\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Pool Token Transfer function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    uint256 lender0PoolTokenBalance;\n    uint256 lender1PoolTokenBalance;\n    uint256 lender2PoolTokenBalance;\n    uint256 lender3PoolTokenBalance;\n    uint256 _from1BalancePostBurn;\n    uint256 lender0PoolTokenBalanceFinal;\n    uint256 lender1PoolTokenBalanceFinal;\n    uint256 lender2PoolTokenBalanceFinal;\n    uint256 lender3PoolTokenBalanceFinal;\n    uint256 _defaultTimeStamp;\n    PCLUser _from1;\n    PCLUser _from2;\n    PCLUser _to1;\n    PCLUser _to2;\n    function assert_pool_token_transfer_in_liquidated_stage(\n        uint256 _id,\n        uint256 _fractionOfPTSupply,\n        bool _positiveCase,\n        address _From1,\n        address _From2,\n        address _To1,\n        address _To2,\n        string memory _errorString\n    ) public {\n        _from1 = PCLUser(_From1);\n        _from2 = PCLUser(_From2);\n        _to1 = PCLUser(_To1);\n        _to2 = PCLUser(_To2);\n        if (_positiveCase) {\n            // Ensuring that these lenders indeed had lent something\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);\n            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);\n            assertGt(lender0PoolTokenBalance, 0);\n            assertGt(lender1PoolTokenBalance, 0);\n            assertGt(lender2PoolTokenBalance, 0);\n            assertGt(lender3PoolTokenBalance, 0);\n            // Lender0 transfers pool tokens to lender1\n            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));\n            //Checking the transfer took place or not\n            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);\n            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));\n            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));\n            vm.warp(block.timestamp + request.defaultGracePeriod);\n            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);\n            // assertTrue(block.timestamp &gt;= _defaultTimeStamp, \'!Still not past default time\');\n            // Lender2 transfers pool tokens to lender3\n            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);\n            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);\n            // Checking whether the transfer took place or not\n            assertTrue(lender2PoolTokenBalanceFinal == 0);\n            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {\n                if (_To1 == address(0)) {\n                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);\n                    assertEq(_from1BalancePostBurn, 0);\n                } else {\n                    revert(\'REVERT\');\n                }\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorString);\n            }\n        }\n    }\n    function test_poolTokenTransferComplete_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            \'\'\n        );\n    }\n    function test_poolTokenTransferPartial_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            2,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            \'\'\n        );\n    }\n    function test_poolTokenTransferPartialByFour_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            4,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            \'\'\n        );\n    }\n    function test_cannotBurnPoolToken_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(0),\n            address(0),\n            \'ERC1155: transfer to the zero address\'\n        );\n    }\n    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[0].lenderAddress,\n            address(0),\n            \'LP:IT1\'\n        );\n    }\n    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            protocolFeeCollectorAddress,\n            address(0),\n            \'LP:IT3\'\n        );\n    }\n    function test_cannotTransferLPTokensToBorrower() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(borrower),\n            address(0),\n            \'LP:IT2\'\n        );\n    }\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, \'!Active\');\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_requestId, _requiredCollateral, false);\n        }\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount);\n        vm.warp(block.timestamp + request.duration / 10);\n        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.repay(_requestId, currentDebt / 200);\n        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, \'!Expired\');\n        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);\n        assert_pool_token_transfer_in_liquidated_stage(\n            _requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[1].lenderAddress,\n            address(0),\n            \'LP:IT5\'\n        );\n    }\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert(\'External user cannot create\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert(\'External user cannot terminate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert(\'Lender cannot lend zero amount\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L1\');\n        }\n    }\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Unverified lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L2\');\n        }\n    }\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L3\');\n        }\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Interest function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_withdraw_interest_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);\n            }\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n    function test_adminCannotWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, admin, \'LP:WI1\');\n    }\n    function test_borrowerCannotWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, borrower, \'LP:WI1\');\n    }\n    function test_lendersCanWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), \'\');\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Liquidation function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function assert_withdraw_liquidation_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_user == PCLUser(lenders[1].lenderAddress)) {\n            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));\n            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));\n            _user.withdrawTokensAfterLiquidation(_id);\n            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));\n            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));\n            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);\n            if (request.collateralRatio != 0) {\n                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);\n            }\n        } else {\n            try _user.withdrawTokensAfterLiquidation(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n    }\n    function test_adminCannotWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(\n            requestId,\n            admin,\n            \'Admin cannot withdraw liquidation/liquidity from an liquidated PCL\',\n            \'LP:WLC1\'\n        );\n    }\n    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(\n            requestId,\n            borrower,\n            \'Admin cannot withdraw liquidation/liquidity from an liquidated PCL\',\n            \'LP:WLC1\'\n        );\n    }\n    function test_lenderCanWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), \'\', \'\');\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // View/calculation function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    uint256 _currentCR;\n    uint256 _totalInterestPending;\n    uint256 _totalInterestRepaid;\n    uint256 _principal;\n    uint256 _currentDebt;\n    uint256 collateralHeld;\n    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        // 0. collateralTokensToLiquidate\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);\n        log_named_uint(\'CD\', _currentDebt);\n        log_named_uint(\'Equivalent Collateral Tokens\', _equivalentCollateralTokens);\n        if (request.collateralRatio != 0) {\n            (, , , , collateralHeld) = lp.pooledCLVariables(_id);\n            log_named_uint(\'Collateral Held\', collateralHeld);\n            if (request.collateralAssetStrategy == compoundYieldAddress) {\n                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)\n            } else {\n                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, \'Collateral Tokens to liquidate\');\n            }\n        } else {\n            log_named_uint(\'CD\', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral\n            assertGt(_equivalentCollateralTokens, 0);\n        }\n        // The currentCr is coming to be more than idealCR. Discuss.\n        // 0. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        if (request.collateralRatio != 0) {\n            // assertEq(request.collateralRatio, _currentCR, \'Current Collateral Ratio\'); // Since a lot of collateral was taken away\n        } else {\n            assertTrue(true);\n        }\n        // 1. calculatePrincipalWithdrawable\n        try _lender.withdrawLiquidity(_id) {\n            revert(\'Cannot be called without withdrawnLiquidation\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWL2\');\n        }\n        // 2. withdrawableCollateral\n        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation\n        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);\n        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(\n            _remainingCollateralInShares,\n            address(collateralAsset)\n        );\n        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, \'Withdrawable Collateral\');\n        // 3.calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, withdrawableCollateral, \'Total Collateral Tokens\');\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0, \'Borrowable Amount\'); // Since PCL is liquidated now\n        // 5. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0, \'Interest Accrued\'); // Should be non-zero, since it calculates interest accrued since last repayment\n        // doesn\'t matter whether the PCL has been liquidated or not\n        // 6. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);\n        _totalInterestPending = _borrower.calculateInterestAccrued(_id);\n        log_named_uint(\'First Interest Repaid\', _totalInterestRepaid);\n        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;\n        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, \'Current Debt\');\n    }\n    function test_helperFunctionsInLiquidatedState() public {\n        assert_helper_functionalities_in_liquidated_state(requestId);\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:26:55 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId; address lender_0;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     lender_0 = lenders[0].lenderAddress;      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 10);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 200);      // Now we travel past the expiration date     vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      // Now the PCL should be in the LIQUIDATED state     PCLUser(lender_0).liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated'); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Liquidated PCL cannot be started function assert_start_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1'); }  function test_borrowerCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1'); }  function test_lenderCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in liquidated state',         'LP:S1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1'); }  function test_lenderCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in liquidated state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1'); }  function test_lenderCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a liquidated PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the Liquidated state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrowALiquidatedPCL() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB3'     ); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB1'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInLiquidatedState(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     admin.transferToken(address(borrowAsset), address(_user), 100);     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), 100);     }      try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_borrowerCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_lenderCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw collateral in Liquidated state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw zero collateral in Liquidated state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_Liquidated_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawLiquidity(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Liquidated PCL cannot be liquidated',         'PCL:L2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue(             (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                 (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                 true         );          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } }  function test_adminCanTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         borrower,         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_liquidated_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          //Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          vm.warp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 10);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.repay(_requestId, currentDebt / 200);      vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);      assert_pool_token_transfer_in_liquidated_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user == PCLUser(lenders[1].lenderAddress)) {         uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));         _user.withdrawTokensAfterLiquidation(_id);         uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));         assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);         if (request.collateralRatio != 0) {             assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);         }     } else {         try _user.withdrawTokensAfterLiquidation(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         admin,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         borrower,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_lenderCanWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentCR; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal; uint256 _currentDebt; uint256 collateralHeld;  function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);      log_named_uint('CD', _currentDebt);     log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);      if (request.collateralRatio != 0) {         (, , , , collateralHeld) = lp.pooledCLVariables(_id);          log_named_uint('Collateral Held', collateralHeld);          if (request.collateralAssetStrategy == compoundYieldAddress) {             assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)         } else {             // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');         }     } else {         log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral         assertGt(_equivalentCollateralTokens, 0);     }      // The currentCr is coming to be more than idealCR. Discuss.      // 0. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     if (request.collateralRatio != 0) {         // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away     } else {         assertTrue(true);     }      // 1. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without withdrawnLiquidation');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL2');     }      // 2. withdrawableCollateral     (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation     uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);     uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(         _remainingCollateralInShares,         address(collateralAsset)     );     uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);      assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been liquidated or not      // 6. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     log_named_uint('First Interest Repaid', _totalInterestRepaid);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt'); }  function test_helperFunctionsInLiquidatedState() public {     assert_helper_functionalities_in_liquidated_state(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:26:55 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';
contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;
    uint256 requestId;
    address lender_0;
    function setUp() public virtual override {
        super.setUp();
        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);
        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;
        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);
        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);
        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);
        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }
    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }
    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }
    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }
    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }
    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }
    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }
    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }
    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }
    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }
    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }
    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/
    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }
        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }
    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }
    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }
    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }
    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/
    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }
    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }
    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }
    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }
    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }
    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/
    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }
    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }
    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }
    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }
    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/
    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }
        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }
    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }
    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }
    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }
    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }
    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/
    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }
    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }
    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }
    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }
    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }
    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }
    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));
        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));
            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));
            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );
            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }
    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }
    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }
    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;
    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);
        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);
            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);
            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));
            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);
            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));
            vm.warp(block.timestamp + request.defaultGracePeriod);
            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);
            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');
            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);
            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);
            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }
    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }
    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }
    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }
    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }
    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }
    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }
    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }
    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);
        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }
    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }
    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }
    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }
    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }
    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);
        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));
        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);
            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }
            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }
    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }
    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }
    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }
    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }
    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }
    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;
    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);
        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);
            log_named_uint('Collateral Held', collateralHeld);
            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }
        // The currentCr is coming to be more than idealCR. Discuss.
        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }
        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }
        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');
        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');
        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now
        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not
        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }
    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';
contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;
    uint256 requestId;
    address lender_0;
    function setUp() public virtual override {
        super.setUp();
        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);
        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;
        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);
        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);
        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);
        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }
    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }
    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }
    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }
    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }
    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }
    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }
    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }
    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }
    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }
    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }
    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/
    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }
        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }
    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }
    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }
    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }
    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/
    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }
    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }
    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }
    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }
    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }
    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/
    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }
    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }
    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }
    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }
    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/
    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }
        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }
    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }
    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }
    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }
    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }
    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/
    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }
    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }
    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }
    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }
    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }
    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }
    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));
        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));
            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));
            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );
            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }
    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }
    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }
    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;
    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);
        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);
            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);
            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));
            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);
            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));
            vm.warp(block.timestamp + request.defaultGracePeriod);
            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);
            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');
            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);
            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);
            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }
    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }
    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }
    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }
    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }
    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }
    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }
    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }
    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);
        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }
    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }
    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }
    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }
    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }
    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);
        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));
        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);
            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }
            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }
    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }
    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }
    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }
    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }
    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }
    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;
    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);
        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);
            log_named_uint('Collateral Held', collateralHeld);
            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }
        // The currentCr is coming to be more than idealCR. Discuss.
        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }
        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }
        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');
        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');
        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now
        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not
        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }
    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-27-08 09:26:59 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:26:59 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 28650
completion_tokens: 1
total_tokens: 28651
cost: $-1.000000


[2024-27-08 09:26:59 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
.]

Security

[2024-27-08 09:26:59 INFO] **[Seminar Conclusion]**:

 Security

[2024-27-08 09:26:59 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-27-08 09:26:59 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-27-08 09:26:59 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId; address lender_0;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     lender_0 = lenders[0].lenderAddress;      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 10);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 200);      // Now we travel past the expiration date     vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      // Now the PCL should be in the LIQUIDATED state     PCLUser(lender_0).liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated'); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Liquidated PCL cannot be started function assert_start_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1'); }  function test_borrowerCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1'); }  function test_lenderCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in liquidated state',         'LP:S1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1'); }  function test_lenderCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in liquidated state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1'); }  function test_lenderCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a liquidated PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the Liquidated state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrowALiquidatedPCL() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB3'     ); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB1'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInLiquidatedState(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     admin.transferToken(address(borrowAsset), address(_user), 100);     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), 100);     }      try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_borrowerCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_lenderCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw collateral in Liquidated state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw zero collateral in Liquidated state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_Liquidated_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawLiquidity(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Liquidated PCL cannot be liquidated',         'PCL:L2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue(             (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                 (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                 true         );          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } }  function test_adminCanTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         borrower,         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_liquidated_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          //Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          vm.warp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 10);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.repay(_requestId, currentDebt / 200);      vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);      assert_pool_token_transfer_in_liquidated_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user == PCLUser(lenders[1].lenderAddress)) {         uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));         _user.withdrawTokensAfterLiquidation(_id);         uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));         assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);         if (request.collateralRatio != 0) {             assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);         }     } else {         try _user.withdrawTokensAfterLiquidation(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         admin,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         borrower,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_lenderCanWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentCR; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal; uint256 _currentDebt; uint256 collateralHeld;  function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);      log_named_uint('CD', _currentDebt);     log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);      if (request.collateralRatio != 0) {         (, , , , collateralHeld) = lp.pooledCLVariables(_id);          log_named_uint('Collateral Held', collateralHeld);          if (request.collateralAssetStrategy == compoundYieldAddress) {             assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)         } else {             // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');         }     } else {         log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral         assertGt(_equivalentCollateralTokens, 0);     }      // The currentCr is coming to be more than idealCR. Discuss.      // 0. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     if (request.collateralRatio != 0) {         // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away     } else {         assertTrue(true);     }      // 1. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without withdrawnLiquidation');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL2');     }      // 2. withdrawableCollateral     (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation     uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);     uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(         _remainingCollateralInShares,         address(collateralAsset)     );     uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);      assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been liquidated or not      // 6. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     log_named_uint('First Interest Repaid', _totalInterestRepaid);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt'); }  function test_helperFunctionsInLiquidatedState() public {     assert_helper_functionalities_in_liquidated_state(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 requestId;\n    address lender_0;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        lender_0 = lenders[0].lenderAddress;\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 10);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, currentDebt / 200);\n\n        // Now we travel past the expiration date\n        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n\n        // Now the PCL should be in the LIQUIDATED state\n        PCLUser(lender_0).liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test0: Test SetUp\n    function test_SetUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // START function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // Test1: Liquidated PCL cannot be started\n    function assert_start_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertString,\n        string memory _errorString\n    ) public {\n        try _user.start(_id) {\n            revert(_revertString);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorString);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_adminCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');\n    }\n\n    function test_borrowerCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');\n    }\n\n    function test_lenderCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot start a PCL in liquidated state',\n            'LP:S1'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CANCEL function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_cancel_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_adminCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');\n    }\n\n    function test_lenderCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot Cancel a PCL in liquidated state',\n            'PCL:OCLB1'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CLOSE function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_close_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_adminCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');\n    }\n\n    function test_lenderCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot close a liquidated PCL',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Deposit collateral function calls\n    *******************/\n\n    function assert_collateralCannotBeDepositedInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        if (_depositor != borrower) {\n            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n        }\n\n        try _depositor.depositCollateral(_id, _amount, false) {\n            revert('Collateral cannot be deposited in the Liquidated state');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:DC2');\n        }\n    }\n\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);\n    }\n\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);\n    }\n\n    /*******************\n    Borrow function tests\n    *******************/\n\n    function assertBorrowFunctionalityInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Admin cannot borrow a PCL in Liquidated state',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotBorrowALiquidatedPCL() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot borrow a PCL in Liquidated state',\n            'PCL:IB3'\n        );\n    }\n\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot borrow a PCL in Liquidated state',\n            'PCL:IB1'\n        );\n    }\n\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Lender cannot borrow a PCL in Liquidated state',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Repay function tests\n    *******************/\n\n    function assertRepayFunctionalityInLiquidatedState(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        admin.transferToken(address(borrowAsset), address(_user), 100);\n        if (_user != borrower) {\n            _user.setAllowance(address(pcl), address(borrowAsset), 100);\n        }\n\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Admin cannot repay a Liquidated PCL',\n            'PCL:REP2'\n        );\n    }\n\n    function test_borrowerCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot repay a Liquidated PCL',\n            'PCL:REP2'\n        );\n    }\n\n    function test_lenderCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Lender cannot repay a Liquidated PCL',\n            'PCL:REP2'\n        );\n    }\n\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n\n    function assertWithdrawCollateralFunctionalityInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawAllCollateral(_id, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertGe(_balanceAfter, _balanceBefore);\n        } else {\n            try _user.withdrawAllCollateral(_id, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessageAll);\n            }\n        }\n\n        if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawCollateral(_id, _amount, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);\n        } else {\n            try _user.withdrawCollateral(_id, _amount, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n    }\n\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Admin cannot withdraw collateral in Liquidated state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot withdraw collateral in Liquidated state',\n            'PCL:WC1',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot withdraw zero collateral in Liquidated state',\n            'PCL:WC2',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Lender cannot withdraw collateral in Liquidated state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    WithdrawLiquidity function calls\n    ********************/\n\n    function assert_withdraw_liquidity_functionality_in_Liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.withdrawLiquidity(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Admin cannot withdraw liquidity a PCL in Liquidated state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot withdraw liquidity a PCL in Liquidated state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Lender cannot withdraw liquidity a PCL in Liquidated state',\n            'LP:IWL2'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // LIQUIDATE function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_liquidate_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_adminCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');\n    }\n\n    function test_borrowerCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');\n    }\n\n    function test_lenderCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Liquidated PCL cannot be liquidated',\n            'PCL:L2'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Terminate function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_terminate_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));\n\n        try _user.terminate(_id) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n\n            if (_user == admin) {\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);\n                assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);\n                if (request.collateralRatio != 0) {\n                    assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);\n                }\n            } else {\n                assertTrue(\n                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                        true\n                );\n                revert(_revertMessage);\n            }\n        } catch Error(string memory reason) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n\n            assertTrue(\n                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                    true\n            );\n\n            assertEq(reason, _errorMessage);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        }\n    }\n\n    function test_adminCanTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');\n    }\n\n    function test_borrowerCannotTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(\n            requestId,\n            borrower,\n            'Cannot terminate a PCL that is liquidated',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    function test_lenderCannotTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Cannot terminate a PCL that is liquidated',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Pool Token Transfer function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    uint256 lender0PoolTokenBalance;\n    uint256 lender1PoolTokenBalance;\n    uint256 lender2PoolTokenBalance;\n    uint256 lender3PoolTokenBalance;\n    uint256 _from1BalancePostBurn;\n    uint256 lender0PoolTokenBalanceFinal;\n    uint256 lender1PoolTokenBalanceFinal;\n    uint256 lender2PoolTokenBalanceFinal;\n    uint256 lender3PoolTokenBalanceFinal;\n    uint256 _defaultTimeStamp;\n\n    PCLUser _from1;\n    PCLUser _from2;\n    PCLUser _to1;\n    PCLUser _to2;\n\n    function assert_pool_token_transfer_in_liquidated_stage(\n        uint256 _id,\n        uint256 _fractionOfPTSupply,\n        bool _positiveCase,\n        address _From1,\n        address _From2,\n        address _To1,\n        address _To2,\n        string memory _errorString\n    ) public {\n        _from1 = PCLUser(_From1);\n        _from2 = PCLUser(_From2);\n        _to1 = PCLUser(_To1);\n        _to2 = PCLUser(_To2);\n\n        if (_positiveCase) {\n            // Ensuring that these lenders indeed had lent something\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);\n            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);\n\n            assertGt(lender0PoolTokenBalance, 0);\n            assertGt(lender1PoolTokenBalance, 0);\n            assertGt(lender2PoolTokenBalance, 0);\n            assertGt(lender3PoolTokenBalance, 0);\n\n            // Lender0 transfers pool tokens to lender1\n            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));\n\n            //Checking the transfer took place or not\n            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);\n\n            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));\n            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));\n\n            vm.warp(block.timestamp + request.defaultGracePeriod);\n\n            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);\n\n            // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');\n\n            // Lender2 transfers pool tokens to lender3\n            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);\n\n            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);\n\n            // Checking whether the transfer took place or not\n            assertTrue(lender2PoolTokenBalanceFinal == 0);\n            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {\n                if (_To1 == address(0)) {\n                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);\n                    assertEq(_from1BalancePostBurn, 0);\n                } else {\n                    revert('REVERT');\n                }\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorString);\n            }\n        }\n    }\n\n    function test_poolTokenTransferComplete_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartial_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            2,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartialByFour_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            4,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_cannotBurnPoolToken_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(0),\n            address(0),\n            'ERC1155: transfer to the zero address'\n        );\n    }\n\n    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[0].lenderAddress,\n            address(0),\n            'LP:IT1'\n        );\n    }\n\n    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            protocolFeeCollectorAddress,\n            address(0),\n            'LP:IT3'\n        );\n    }\n\n    function test_cannotTransferLPTokensToBorrower() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(borrower),\n            address(0),\n            'LP:IT2'\n        );\n    }\n\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_requestId, _requiredCollateral, false);\n        }\n\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount);\n\n        vm.warp(block.timestamp + request.duration / 10);\n        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.repay(_requestId, currentDebt / 200);\n\n        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n\n        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);\n\n        assert_pool_token_transfer_in_liquidated_stage(\n            _requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[1].lenderAddress,\n            address(0),\n            'LP:IT5'\n        );\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert('External user cannot create');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert('External user cannot terminate');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert('Lender cannot lend zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L1');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Unverified lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L2');\n        }\n    }\n\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Interest function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_withdraw_interest_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);\n            }\n\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');\n    }\n\n    function test_borrowerCannotWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');\n    }\n\n    function test_lendersCanWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Liquidation function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_withdraw_liquidation_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_user == PCLUser(lenders[1].lenderAddress)) {\n            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));\n            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));\n            _user.withdrawTokensAfterLiquidation(_id);\n            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));\n            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));\n            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);\n            if (request.collateralRatio != 0) {\n                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);\n            }\n        } else {\n            try _user.withdrawTokensAfterLiquidation(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n    }\n\n    function test_adminCannotWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(\n            requestId,\n            admin,\n            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',\n            'LP:WLC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(\n            requestId,\n            borrower,\n            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',\n            'LP:WLC1'\n        );\n    }\n\n    function test_lenderCanWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // View/calculation function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    uint256 _currentCR;\n    uint256 _totalInterestPending;\n    uint256 _totalInterestRepaid;\n    uint256 _principal;\n    uint256 _currentDebt;\n    uint256 collateralHeld;\n\n    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 0. collateralTokensToLiquidate\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);\n\n        log_named_uint('CD', _currentDebt);\n        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);\n\n        if (request.collateralRatio != 0) {\n            (, , , , collateralHeld) = lp.pooledCLVariables(_id);\n\n            log_named_uint('Collateral Held', collateralHeld);\n\n            if (request.collateralAssetStrategy == compoundYieldAddress) {\n                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)\n            } else {\n                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');\n            }\n        } else {\n            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral\n            assertGt(_equivalentCollateralTokens, 0);\n        }\n\n        // The currentCr is coming to be more than idealCR. Discuss.\n\n        // 0. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        if (request.collateralRatio != 0) {\n            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away\n        } else {\n            assertTrue(true);\n        }\n\n        // 1. calculatePrincipalWithdrawable\n        try _lender.withdrawLiquidity(_id) {\n            revert('Cannot be called without withdrawnLiquidation');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL2');\n        }\n\n        // 2. withdrawableCollateral\n        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation\n        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);\n        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(\n            _remainingCollateralInShares,\n            address(collateralAsset)\n        );\n        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n\n        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');\n\n        // 3.calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');\n\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now\n\n        // 5. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment\n        // doesn't matter whether the PCL has been liquidated or not\n\n        // 6. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);\n        _totalInterestPending = _borrower.calculateInterestAccrued(_id);\n        log_named_uint('First Interest Repaid', _totalInterestRepaid);\n        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;\n        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');\n    }\n\n    function test_helperFunctionsInLiquidatedState() public {\n        assert_helper_functionalities_in_liquidated_state(requestId);\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:26:59 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId; address lender_0;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     lender_0 = lenders[0].lenderAddress;      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 10);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 200);      // Now we travel past the expiration date     vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      // Now the PCL should be in the LIQUIDATED state     PCLUser(lender_0).liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated'); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Liquidated PCL cannot be started function assert_start_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1'); }  function test_borrowerCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1'); }  function test_lenderCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in liquidated state',         'LP:S1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1'); }  function test_lenderCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in liquidated state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1'); }  function test_lenderCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a liquidated PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the Liquidated state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrowALiquidatedPCL() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB3'     ); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB1'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInLiquidatedState(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     admin.transferToken(address(borrowAsset), address(_user), 100);     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), 100);     }      try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_borrowerCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_lenderCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw collateral in Liquidated state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw zero collateral in Liquidated state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_Liquidated_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawLiquidity(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Liquidated PCL cannot be liquidated',         'PCL:L2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue(             (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                 (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                 true         );          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } }  function test_adminCanTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         borrower,         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_liquidated_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          //Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          vm.warp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 10);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.repay(_requestId, currentDebt / 200);      vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);      assert_pool_token_transfer_in_liquidated_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user == PCLUser(lenders[1].lenderAddress)) {         uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));         _user.withdrawTokensAfterLiquidation(_id);         uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));         assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);         if (request.collateralRatio != 0) {             assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);         }     } else {         try _user.withdrawTokensAfterLiquidation(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         admin,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         borrower,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_lenderCanWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentCR; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal; uint256 _currentDebt; uint256 collateralHeld;  function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);      log_named_uint('CD', _currentDebt);     log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);      if (request.collateralRatio != 0) {         (, , , , collateralHeld) = lp.pooledCLVariables(_id);          log_named_uint('Collateral Held', collateralHeld);          if (request.collateralAssetStrategy == compoundYieldAddress) {             assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)         } else {             // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');         }     } else {         log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral         assertGt(_equivalentCollateralTokens, 0);     }      // The currentCr is coming to be more than idealCR. Discuss.      // 0. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     if (request.collateralRatio != 0) {         // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away     } else {         assertTrue(true);     }      // 1. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without withdrawnLiquidation');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL2');     }      // 2. withdrawableCollateral     (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation     uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);     uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(         _remainingCollateralInShares,         address(collateralAsset)     );     uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);      assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been liquidated or not      // 6. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     log_named_uint('First Interest Repaid', _totalInterestRepaid);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt'); }  function test_helperFunctionsInLiquidatedState() public {     assert_helper_functionalities_in_liquidated_state(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:26:59 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:27:06 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:27:06 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19061
completion_tokens: 1
total_tokens: 19062
cost: $-1.000000


[2024-27-08 09:27:06 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
.]

###

[2024-27-08 09:27:06 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:27:06 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-27-08 09:27:06 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId; address lender_0;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     lender_0 = lenders[0].lenderAddress;      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 10);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 200);      // Now we travel past the expiration date     vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      // Now the PCL should be in the LIQUIDATED state     PCLUser(lender_0).liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated'); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Liquidated PCL cannot be started function assert_start_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1'); }  function test_borrowerCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1'); }  function test_lenderCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in liquidated state',         'LP:S1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1'); }  function test_lenderCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in liquidated state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1'); }  function test_lenderCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a liquidated PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the Liquidated state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrowALiquidatedPCL() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB3'     ); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB1'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInLiquidatedState(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     admin.transferToken(address(borrowAsset), address(_user), 100);     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), 100);     }      try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_borrowerCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_lenderCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw collateral in Liquidated state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw zero collateral in Liquidated state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_Liquidated_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawLiquidity(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Liquidated PCL cannot be liquidated',         'PCL:L2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue(             (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                 (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                 true         );          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } }  function test_adminCanTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         borrower,         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_liquidated_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          //Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          vm.warp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 10);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.repay(_requestId, currentDebt / 200);      vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);      assert_pool_token_transfer_in_liquidated_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user == PCLUser(lenders[1].lenderAddress)) {         uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));         _user.withdrawTokensAfterLiquidation(_id);         uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));         assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);         if (request.collateralRatio != 0) {             assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);         }     } else {         try _user.withdrawTokensAfterLiquidation(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         admin,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         borrower,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_lenderCanWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentCR; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal; uint256 _currentDebt; uint256 collateralHeld;  function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);      log_named_uint('CD', _currentDebt);     log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);      if (request.collateralRatio != 0) {         (, , , , collateralHeld) = lp.pooledCLVariables(_id);          log_named_uint('Collateral Held', collateralHeld);          if (request.collateralAssetStrategy == compoundYieldAddress) {             assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)         } else {             // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');         }     } else {         log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral         assertGt(_equivalentCollateralTokens, 0);     }      // The currentCr is coming to be more than idealCR. Discuss.      // 0. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     if (request.collateralRatio != 0) {         // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away     } else {         assertTrue(true);     }      // 1. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without withdrawnLiquidation');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL2');     }      // 2. withdrawableCollateral     (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation     uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);     uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(         _remainingCollateralInShares,         address(collateralAsset)     );     uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);      assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been liquidated or not      // 6. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     log_named_uint('First Interest Repaid', _totalInterestRepaid);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt'); }  function test_helperFunctionsInLiquidatedState() public {     assert_helper_functionalities_in_liquidated_state(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:27:06 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId; address lender_0;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     lender_0 = lenders[0].lenderAddress;      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 10);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 200);      // Now we travel past the expiration date     vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      // Now the PCL should be in the LIQUIDATED state     PCLUser(lender_0).liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated'); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Liquidated PCL cannot be started function assert_start_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1'); }  function test_borrowerCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1'); }  function test_lenderCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in liquidated state',         'LP:S1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1'); }  function test_lenderCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in liquidated state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1'); }  function test_lenderCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a liquidated PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the Liquidated state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrowALiquidatedPCL() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB3'     ); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB1'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInLiquidatedState(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     admin.transferToken(address(borrowAsset), address(_user), 100);     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), 100);     }      try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_borrowerCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_lenderCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw collateral in Liquidated state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw zero collateral in Liquidated state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_Liquidated_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawLiquidity(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Liquidated PCL cannot be liquidated',         'PCL:L2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue(             (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                 (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                 true         );          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } }  function test_adminCanTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         borrower,         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_liquidated_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          //Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          vm.warp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 10);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.repay(_requestId, currentDebt / 200);      vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);      assert_pool_token_transfer_in_liquidated_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user == PCLUser(lenders[1].lenderAddress)) {         uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));         _user.withdrawTokensAfterLiquidation(_id);         uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));         assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);         if (request.collateralRatio != 0) {             assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);         }     } else {         try _user.withdrawTokensAfterLiquidation(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         admin,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         borrower,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_lenderCanWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentCR; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal; uint256 _currentDebt; uint256 collateralHeld;  function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);      log_named_uint('CD', _currentDebt);     log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);      if (request.collateralRatio != 0) {         (, , , , collateralHeld) = lp.pooledCLVariables(_id);          log_named_uint('Collateral Held', collateralHeld);          if (request.collateralAssetStrategy == compoundYieldAddress) {             assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)         } else {             // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');         }     } else {         log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral         assertGt(_equivalentCollateralTokens, 0);     }      // The currentCr is coming to be more than idealCR. Discuss.      // 0. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     if (request.collateralRatio != 0) {         // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away     } else {         assertTrue(true);     }      // 1. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without withdrawnLiquidation');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL2');     }      // 2. withdrawableCollateral     (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation     uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);     uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(         _remainingCollateralInShares,         address(collateralAsset)     );     uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);      assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been liquidated or not      // 6. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     log_named_uint('First Interest Repaid', _totalInterestRepaid);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt'); }  function test_helperFunctionsInLiquidatedState() public {     assert_helper_functionalities_in_liquidated_state(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:27:06 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:27:15 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:27:15 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 9590
completion_tokens: 651
total_tokens: 10241
cost: $-1.000000


[2024-27-08 09:27:15 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
.]

Based on the provided Solidity smart contract code for the `PCLLiquidatedStage` and its associated analysis, the following security vulnerabilities and issues have been identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Risks**:
   - The contract does not implement any reentrancy guards, which could allow malicious users to exploit functions that transfer tokens or modify state variables.

2. **Lack of Input Validation**:
   - Several functions do not validate input parameters adequately, such as ensuring that amounts being borrowed, lent, or deposited are greater than zero. This could lead to unexpected behaviors or state changes.

3. **Improper Access Control**:
   - Functions that should be restricted to certain roles (e.g., admin, borrower, lender) may not have adequate access control checks, allowing unauthorized users to execute sensitive operations.

4. **Error Handling**:
   - The contract relies heavily on `try/catch` for error handling, which may not cover all edge cases. Additionally, revert messages may not provide sufficient context for debugging.

5. **Token Transfer Failures**:
   - The contract does not handle scenarios where token transfers fail. This could lead to inconsistencies in the state of the contract if a transfer is expected to succeed but does not.

6. **Potential for Gas Limit Issues**:
   - Functions that involve loops or extensive state changes may run into gas limit issues, especially if they are called in a transaction with other operations.

7. **Lack of Event Emissions**:
   - Important state changes (e.g., liquidations, repayments) may not emit events, making it difficult to track contract activity on-chain.

8. **Hardcoded Values**:
   - The use of hardcoded values for certain parameters (e.g., interest rates, limits) could lead to inflexibility and potential exploits if market conditions change.

9. **Inadequate Testing Coverage**:
   - While the contract includes tests, there may be insufficient coverage for edge cases, particularly around state transitions and error conditions.

### Comprehensive Analysis Report:

The `PCLLiquidatedStage` contract exhibits several security vulnerabilities that could be exploited by malicious actors, leading to financial loss or unintended behavior. The absence of reentrancy guards poses a significant risk, especially in functions that handle token transfers. Input validation is crucial to ensure that only valid amounts are processed, preventing unexpected states.

Access control mechanisms must be reinforced to ensure that only authorized users can execute sensitive functions. The reliance on `try/catch` for error handling may not be sufficient, and better error messaging would aid in debugging and user experience.

Token transfer failures should be handled gracefully to maintain contract integrity, and careful consideration should be given to gas limits in functions that may require extensive computation. Emitting events for significant state changes is essential for transparency and tracking.

Finally, the use of hardcoded values limits the contract's adaptability, and thorough testing is necessary to cover all potential edge cases. Addressing these vulnerabilities will enhance the security and reliability of the `PCLLiquidatedStage` contract, ensuring a safer environment for users and stakeholders. 

It is recommended to conduct a thorough audit and implement best practices in Solidity development to mitigate these risks effectively.

[2024-27-08 09:27:15 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `PCLLiquidatedStage` and its associated analysis, the following security vulnerabilities and issues have been identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Risks**:
   - The contract does not implement any reentrancy guards, which could allow malicious users to exploit functions that transfer tokens or modify state variables.

2. **Lack of Input Validation**:
   - Several functions do not validate input parameters adequately, such as ensuring that amounts being borrowed, lent, or deposited are greater than zero. This could lead to unexpected behaviors or state changes.

3. **Improper Access Control**:
   - Functions that should be restricted to certain roles (e.g., admin, borrower, lender) may not have adequate access control checks, allowing unauthorized users to execute sensitive operations.

4. **Error Handling**:
   - The contract relies heavily on `try/catch` for error handling, which may not cover all edge cases. Additionally, revert messages may not provide sufficient context for debugging.

5. **Token Transfer Failures**:
   - The contract does not handle scenarios where token transfers fail. This could lead to inconsistencies in the state of the contract if a transfer is expected to succeed but does not.

6. **Potential for Gas Limit Issues**:
   - Functions that involve loops or extensive state changes may run into gas limit issues, especially if they are called in a transaction with other operations.

7. **Lack of Event Emissions**:
   - Important state changes (e.g., liquidations, repayments) may not emit events, making it difficult to track contract activity on-chain.

8. **Hardcoded Values**:
   - The use of hardcoded values for certain parameters (e.g., interest rates, limits) could lead to inflexibility and potential exploits if market conditions change.

9. **Inadequate Testing Coverage**:
   - While the contract includes tests, there may be insufficient coverage for edge cases, particularly around state transitions and error conditions.

### Comprehensive Analysis Report:

The `PCLLiquidatedStage` contract exhibits several security vulnerabilities that could be exploited by malicious actors, leading to financial loss or unintended behavior. The absence of reentrancy guards poses a significant risk, especially in functions that handle token transfers. Input validation is crucial to ensure that only valid amounts are processed, preventing unexpected states.

Access control mechanisms must be reinforced to ensure that only authorized users can execute sensitive functions. The reliance on `try/catch` for error handling may not be sufficient, and better error messaging would aid in debugging and user experience.

Token transfer failures should be handled gracefully to maintain contract integrity, and careful consideration should be given to gas limits in functions that may require extensive computation. Emitting events for significant state changes is essential for transparency and tracking.

Finally, the use of hardcoded values limits the contract's adaptability, and thorough testing is necessary to cover all potential edge cases. Addressing these vulnerabilities will enhance the security and reliability of the `PCLLiquidatedStage` contract, ensuring a safer environment for users and stakeholders. 

It is recommended to conduct a thorough audit and implement best practices in Solidity development to mitigate these risks effectively.

[2024-27-08 09:27:15 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-27-08 09:27:15 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId; address lender_0;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     lender_0 = lenders[0].lenderAddress;      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 10);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 200);      // Now we travel past the expiration date     vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      // Now the PCL should be in the LIQUIDATED state     PCLUser(lender_0).liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated'); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Liquidated PCL cannot be started function assert_start_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1'); }  function test_borrowerCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1'); }  function test_lenderCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in liquidated state',         'LP:S1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1'); }  function test_lenderCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in liquidated state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1'); }  function test_lenderCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a liquidated PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the Liquidated state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrowALiquidatedPCL() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB3'     ); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB1'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInLiquidatedState(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     admin.transferToken(address(borrowAsset), address(_user), 100);     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), 100);     }      try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_borrowerCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_lenderCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw collateral in Liquidated state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw zero collateral in Liquidated state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_Liquidated_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawLiquidity(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Liquidated PCL cannot be liquidated',         'PCL:L2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue(             (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                 (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                 true         );          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } }  function test_adminCanTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         borrower,         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_liquidated_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          //Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          vm.warp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 10);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.repay(_requestId, currentDebt / 200);      vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);      assert_pool_token_transfer_in_liquidated_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user == PCLUser(lenders[1].lenderAddress)) {         uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));         _user.withdrawTokensAfterLiquidation(_id);         uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));         assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);         if (request.collateralRatio != 0) {             assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);         }     } else {         try _user.withdrawTokensAfterLiquidation(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         admin,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         borrower,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_lenderCanWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentCR; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal; uint256 _currentDebt; uint256 collateralHeld;  function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);      log_named_uint('CD', _currentDebt);     log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);      if (request.collateralRatio != 0) {         (, , , , collateralHeld) = lp.pooledCLVariables(_id);          log_named_uint('Collateral Held', collateralHeld);          if (request.collateralAssetStrategy == compoundYieldAddress) {             assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)         } else {             // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');         }     } else {         log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral         assertGt(_equivalentCollateralTokens, 0);     }      // The currentCr is coming to be more than idealCR. Discuss.      // 0. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     if (request.collateralRatio != 0) {         // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away     } else {         assertTrue(true);     }      // 1. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without withdrawnLiquidation');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL2');     }      // 2. withdrawableCollateral     (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation     uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);     uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(         _remainingCollateralInShares,         address(collateralAsset)     );     uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);      assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been liquidated or not      // 6. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     log_named_uint('First Interest Repaid', _totalInterestRepaid);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt'); }  function test_helperFunctionsInLiquidatedState() public {     assert_helper_functionalities_in_liquidated_state(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 requestId;\n    address lender_0;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        lender_0 = lenders[0].lenderAddress;\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 10);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, currentDebt / 200);\n\n        // Now we travel past the expiration date\n        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n\n        // Now the PCL should be in the LIQUIDATED state\n        PCLUser(lender_0).liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test0: Test SetUp\n    function test_SetUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // START function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // Test1: Liquidated PCL cannot be started\n    function assert_start_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertString,\n        string memory _errorString\n    ) public {\n        try _user.start(_id) {\n            revert(_revertString);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorString);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_adminCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');\n    }\n\n    function test_borrowerCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');\n    }\n\n    function test_lenderCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot start a PCL in liquidated state',\n            'LP:S1'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CANCEL function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_cancel_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_adminCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');\n    }\n\n    function test_lenderCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot Cancel a PCL in liquidated state',\n            'PCL:OCLB1'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CLOSE function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_close_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_adminCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');\n    }\n\n    function test_lenderCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot close a liquidated PCL',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Deposit collateral function calls\n    *******************/\n\n    function assert_collateralCannotBeDepositedInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        if (_depositor != borrower) {\n            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n        }\n\n        try _depositor.depositCollateral(_id, _amount, false) {\n            revert('Collateral cannot be deposited in the Liquidated state');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:DC2');\n        }\n    }\n\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);\n    }\n\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);\n    }\n\n    /*******************\n    Borrow function tests\n    *******************/\n\n    function assertBorrowFunctionalityInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Admin cannot borrow a PCL in Liquidated state',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotBorrowALiquidatedPCL() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot borrow a PCL in Liquidated state',\n            'PCL:IB3'\n        );\n    }\n\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot borrow a PCL in Liquidated state',\n            'PCL:IB1'\n        );\n    }\n\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Lender cannot borrow a PCL in Liquidated state',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Repay function tests\n    *******************/\n\n    function assertRepayFunctionalityInLiquidatedState(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        admin.transferToken(address(borrowAsset), address(_user), 100);\n        if (_user != borrower) {\n            _user.setAllowance(address(pcl), address(borrowAsset), 100);\n        }\n\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Admin cannot repay a Liquidated PCL',\n            'PCL:REP2'\n        );\n    }\n\n    function test_borrowerCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot repay a Liquidated PCL',\n            'PCL:REP2'\n        );\n    }\n\n    function test_lenderCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Lender cannot repay a Liquidated PCL',\n            'PCL:REP2'\n        );\n    }\n\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n\n    function assertWithdrawCollateralFunctionalityInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawAllCollateral(_id, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertGe(_balanceAfter, _balanceBefore);\n        } else {\n            try _user.withdrawAllCollateral(_id, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessageAll);\n            }\n        }\n\n        if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawCollateral(_id, _amount, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);\n        } else {\n            try _user.withdrawCollateral(_id, _amount, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n    }\n\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Admin cannot withdraw collateral in Liquidated state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot withdraw collateral in Liquidated state',\n            'PCL:WC1',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot withdraw zero collateral in Liquidated state',\n            'PCL:WC2',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Lender cannot withdraw collateral in Liquidated state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    WithdrawLiquidity function calls\n    ********************/\n\n    function assert_withdraw_liquidity_functionality_in_Liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.withdrawLiquidity(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Admin cannot withdraw liquidity a PCL in Liquidated state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot withdraw liquidity a PCL in Liquidated state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Lender cannot withdraw liquidity a PCL in Liquidated state',\n            'LP:IWL2'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // LIQUIDATE function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_liquidate_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_adminCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');\n    }\n\n    function test_borrowerCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');\n    }\n\n    function test_lenderCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Liquidated PCL cannot be liquidated',\n            'PCL:L2'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Terminate function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_terminate_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));\n\n        try _user.terminate(_id) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n\n            if (_user == admin) {\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);\n                assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);\n                if (request.collateralRatio != 0) {\n                    assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);\n                }\n            } else {\n                assertTrue(\n                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                        true\n                );\n                revert(_revertMessage);\n            }\n        } catch Error(string memory reason) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n\n            assertTrue(\n                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                    true\n            );\n\n            assertEq(reason, _errorMessage);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        }\n    }\n\n    function test_adminCanTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');\n    }\n\n    function test_borrowerCannotTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(\n            requestId,\n            borrower,\n            'Cannot terminate a PCL that is liquidated',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    function test_lenderCannotTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Cannot terminate a PCL that is liquidated',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Pool Token Transfer function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    uint256 lender0PoolTokenBalance;\n    uint256 lender1PoolTokenBalance;\n    uint256 lender2PoolTokenBalance;\n    uint256 lender3PoolTokenBalance;\n    uint256 _from1BalancePostBurn;\n    uint256 lender0PoolTokenBalanceFinal;\n    uint256 lender1PoolTokenBalanceFinal;\n    uint256 lender2PoolTokenBalanceFinal;\n    uint256 lender3PoolTokenBalanceFinal;\n    uint256 _defaultTimeStamp;\n\n    PCLUser _from1;\n    PCLUser _from2;\n    PCLUser _to1;\n    PCLUser _to2;\n\n    function assert_pool_token_transfer_in_liquidated_stage(\n        uint256 _id,\n        uint256 _fractionOfPTSupply,\n        bool _positiveCase,\n        address _From1,\n        address _From2,\n        address _To1,\n        address _To2,\n        string memory _errorString\n    ) public {\n        _from1 = PCLUser(_From1);\n        _from2 = PCLUser(_From2);\n        _to1 = PCLUser(_To1);\n        _to2 = PCLUser(_To2);\n\n        if (_positiveCase) {\n            // Ensuring that these lenders indeed had lent something\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);\n            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);\n\n            assertGt(lender0PoolTokenBalance, 0);\n            assertGt(lender1PoolTokenBalance, 0);\n            assertGt(lender2PoolTokenBalance, 0);\n            assertGt(lender3PoolTokenBalance, 0);\n\n            // Lender0 transfers pool tokens to lender1\n            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));\n\n            //Checking the transfer took place or not\n            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);\n\n            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));\n            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));\n\n            vm.warp(block.timestamp + request.defaultGracePeriod);\n\n            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);\n\n            // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');\n\n            // Lender2 transfers pool tokens to lender3\n            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);\n\n            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);\n\n            // Checking whether the transfer took place or not\n            assertTrue(lender2PoolTokenBalanceFinal == 0);\n            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {\n                if (_To1 == address(0)) {\n                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);\n                    assertEq(_from1BalancePostBurn, 0);\n                } else {\n                    revert('REVERT');\n                }\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorString);\n            }\n        }\n    }\n\n    function test_poolTokenTransferComplete_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartial_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            2,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartialByFour_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            4,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_cannotBurnPoolToken_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(0),\n            address(0),\n            'ERC1155: transfer to the zero address'\n        );\n    }\n\n    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[0].lenderAddress,\n            address(0),\n            'LP:IT1'\n        );\n    }\n\n    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            protocolFeeCollectorAddress,\n            address(0),\n            'LP:IT3'\n        );\n    }\n\n    function test_cannotTransferLPTokensToBorrower() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(borrower),\n            address(0),\n            'LP:IT2'\n        );\n    }\n\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_requestId, _requiredCollateral, false);\n        }\n\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount);\n\n        vm.warp(block.timestamp + request.duration / 10);\n        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.repay(_requestId, currentDebt / 200);\n\n        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n\n        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);\n\n        assert_pool_token_transfer_in_liquidated_stage(\n            _requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[1].lenderAddress,\n            address(0),\n            'LP:IT5'\n        );\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert('External user cannot create');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert('External user cannot terminate');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert('Lender cannot lend zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L1');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Unverified lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L2');\n        }\n    }\n\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Interest function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_withdraw_interest_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);\n            }\n\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');\n    }\n\n    function test_borrowerCannotWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');\n    }\n\n    function test_lendersCanWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Liquidation function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_withdraw_liquidation_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_user == PCLUser(lenders[1].lenderAddress)) {\n            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));\n            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));\n            _user.withdrawTokensAfterLiquidation(_id);\n            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));\n            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));\n            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);\n            if (request.collateralRatio != 0) {\n                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);\n            }\n        } else {\n            try _user.withdrawTokensAfterLiquidation(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n    }\n\n    function test_adminCannotWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(\n            requestId,\n            admin,\n            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',\n            'LP:WLC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(\n            requestId,\n            borrower,\n            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',\n            'LP:WLC1'\n        );\n    }\n\n    function test_lenderCanWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // View/calculation function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    uint256 _currentCR;\n    uint256 _totalInterestPending;\n    uint256 _totalInterestRepaid;\n    uint256 _principal;\n    uint256 _currentDebt;\n    uint256 collateralHeld;\n\n    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 0. collateralTokensToLiquidate\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);\n\n        log_named_uint('CD', _currentDebt);\n        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);\n\n        if (request.collateralRatio != 0) {\n            (, , , , collateralHeld) = lp.pooledCLVariables(_id);\n\n            log_named_uint('Collateral Held', collateralHeld);\n\n            if (request.collateralAssetStrategy == compoundYieldAddress) {\n                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)\n            } else {\n                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');\n            }\n        } else {\n            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral\n            assertGt(_equivalentCollateralTokens, 0);\n        }\n\n        // The currentCr is coming to be more than idealCR. Discuss.\n\n        // 0. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        if (request.collateralRatio != 0) {\n            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away\n        } else {\n            assertTrue(true);\n        }\n\n        // 1. calculatePrincipalWithdrawable\n        try _lender.withdrawLiquidity(_id) {\n            revert('Cannot be called without withdrawnLiquidation');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL2');\n        }\n\n        // 2. withdrawableCollateral\n        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation\n        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);\n        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(\n            _remainingCollateralInShares,\n            address(collateralAsset)\n        );\n        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n\n        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');\n\n        // 3.calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');\n\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now\n\n        // 5. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment\n        // doesn't matter whether the PCL has been liquidated or not\n\n        // 6. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);\n        _totalInterestPending = _borrower.calculateInterestAccrued(_id);\n        log_named_uint('First Interest Repaid', _totalInterestRepaid);\n        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;\n        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');\n    }\n\n    function test_helperFunctionsInLiquidatedState() public {\n        assert_helper_functionalities_in_liquidated_state(requestId);\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:27:15 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId; address lender_0;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     lender_0 = lenders[0].lenderAddress;      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 10);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 200);      // Now we travel past the expiration date     vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      // Now the PCL should be in the LIQUIDATED state     PCLUser(lender_0).liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated'); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Liquidated PCL cannot be started function assert_start_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1'); }  function test_borrowerCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1'); }  function test_lenderCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in liquidated state',         'LP:S1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1'); }  function test_lenderCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in liquidated state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1'); }  function test_lenderCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a liquidated PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the Liquidated state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrowALiquidatedPCL() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB3'     ); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB1'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInLiquidatedState(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     admin.transferToken(address(borrowAsset), address(_user), 100);     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), 100);     }      try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_borrowerCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_lenderCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw collateral in Liquidated state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw zero collateral in Liquidated state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_Liquidated_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawLiquidity(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Liquidated PCL cannot be liquidated',         'PCL:L2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue(             (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                 (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                 true         );          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } }  function test_adminCanTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         borrower,         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_liquidated_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          //Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          vm.warp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 10);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.repay(_requestId, currentDebt / 200);      vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);      assert_pool_token_transfer_in_liquidated_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user == PCLUser(lenders[1].lenderAddress)) {         uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));         _user.withdrawTokensAfterLiquidation(_id);         uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));         assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);         if (request.collateralRatio != 0) {             assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);         }     } else {         try _user.withdrawTokensAfterLiquidation(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         admin,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         borrower,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_lenderCanWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentCR; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal; uint256 _currentDebt; uint256 collateralHeld;  function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);      log_named_uint('CD', _currentDebt);     log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);      if (request.collateralRatio != 0) {         (, , , , collateralHeld) = lp.pooledCLVariables(_id);          log_named_uint('Collateral Held', collateralHeld);          if (request.collateralAssetStrategy == compoundYieldAddress) {             assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)         } else {             // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');         }     } else {         log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral         assertGt(_equivalentCollateralTokens, 0);     }      // The currentCr is coming to be more than idealCR. Discuss.      // 0. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     if (request.collateralRatio != 0) {         // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away     } else {         assertTrue(true);     }      // 1. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without withdrawnLiquidation');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL2');     }      // 2. withdrawableCollateral     (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation     uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);     uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(         _remainingCollateralInShares,         address(collateralAsset)     );     uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);      assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been liquidated or not      // 6. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     log_named_uint('First Interest Repaid', _totalInterestRepaid);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt'); }  function test_helperFunctionsInLiquidatedState() public {     assert_helper_functionalities_in_liquidated_state(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:27:15 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:27:20 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:27:20 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19061
completion_tokens: 1
total_tokens: 19062
cost: $-1.000000


[2024-27-08 09:27:20 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
.]

###

[2024-27-08 09:27:20 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:27:20 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-27-08 09:27:20 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId; address lender_0;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     lender_0 = lenders[0].lenderAddress;      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 10);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 200);      // Now we travel past the expiration date     vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      // Now the PCL should be in the LIQUIDATED state     PCLUser(lender_0).liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated'); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Liquidated PCL cannot be started function assert_start_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1'); }  function test_borrowerCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1'); }  function test_lenderCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in liquidated state',         'LP:S1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1'); }  function test_lenderCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in liquidated state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1'); }  function test_lenderCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a liquidated PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the Liquidated state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrowALiquidatedPCL() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB3'     ); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB1'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInLiquidatedState(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     admin.transferToken(address(borrowAsset), address(_user), 100);     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), 100);     }      try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_borrowerCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_lenderCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw collateral in Liquidated state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw zero collateral in Liquidated state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_Liquidated_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawLiquidity(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Liquidated PCL cannot be liquidated',         'PCL:L2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue(             (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                 (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                 true         );          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } }  function test_adminCanTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         borrower,         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_liquidated_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          //Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          vm.warp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 10);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.repay(_requestId, currentDebt / 200);      vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);      assert_pool_token_transfer_in_liquidated_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user == PCLUser(lenders[1].lenderAddress)) {         uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));         _user.withdrawTokensAfterLiquidation(_id);         uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));         assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);         if (request.collateralRatio != 0) {             assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);         }     } else {         try _user.withdrawTokensAfterLiquidation(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         admin,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         borrower,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_lenderCanWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentCR; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal; uint256 _currentDebt; uint256 collateralHeld;  function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);      log_named_uint('CD', _currentDebt);     log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);      if (request.collateralRatio != 0) {         (, , , , collateralHeld) = lp.pooledCLVariables(_id);          log_named_uint('Collateral Held', collateralHeld);          if (request.collateralAssetStrategy == compoundYieldAddress) {             assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)         } else {             // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');         }     } else {         log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral         assertGt(_equivalentCollateralTokens, 0);     }      // The currentCr is coming to be more than idealCR. Discuss.      // 0. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     if (request.collateralRatio != 0) {         // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away     } else {         assertTrue(true);     }      // 1. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without withdrawnLiquidation');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL2');     }      // 2. withdrawableCollateral     (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation     uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);     uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(         _remainingCollateralInShares,         address(collateralAsset)     );     uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);      assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been liquidated or not      // 6. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     log_named_uint('First Interest Repaid', _totalInterestRepaid);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt'); }  function test_helperFunctionsInLiquidatedState() public {     assert_helper_functionalities_in_liquidated_state(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:27:20 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId; address lender_0;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     lender_0 = lenders[0].lenderAddress;      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 10);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 200);      // Now we travel past the expiration date     vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      // Now the PCL should be in the LIQUIDATED state     PCLUser(lender_0).liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated'); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Liquidated PCL cannot be started function assert_start_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1'); }  function test_borrowerCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1'); }  function test_lenderCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in liquidated state',         'LP:S1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1'); }  function test_lenderCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in liquidated state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1'); }  function test_lenderCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a liquidated PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the Liquidated state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrowALiquidatedPCL() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB3'     ); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB1'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInLiquidatedState(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     admin.transferToken(address(borrowAsset), address(_user), 100);     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), 100);     }      try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_borrowerCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_lenderCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw collateral in Liquidated state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw zero collateral in Liquidated state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_Liquidated_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawLiquidity(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Liquidated PCL cannot be liquidated',         'PCL:L2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue(             (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                 (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                 true         );          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } }  function test_adminCanTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         borrower,         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_liquidated_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          //Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          vm.warp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 10);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.repay(_requestId, currentDebt / 200);      vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);      assert_pool_token_transfer_in_liquidated_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user == PCLUser(lenders[1].lenderAddress)) {         uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));         _user.withdrawTokensAfterLiquidation(_id);         uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));         assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);         if (request.collateralRatio != 0) {             assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);         }     } else {         try _user.withdrawTokensAfterLiquidation(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         admin,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         borrower,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_lenderCanWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentCR; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal; uint256 _currentDebt; uint256 collateralHeld;  function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);      log_named_uint('CD', _currentDebt);     log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);      if (request.collateralRatio != 0) {         (, , , , collateralHeld) = lp.pooledCLVariables(_id);          log_named_uint('Collateral Held', collateralHeld);          if (request.collateralAssetStrategy == compoundYieldAddress) {             assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)         } else {             // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');         }     } else {         log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral         assertGt(_equivalentCollateralTokens, 0);     }      // The currentCr is coming to be more than idealCR. Discuss.      // 0. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     if (request.collateralRatio != 0) {         // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away     } else {         assertTrue(true);     }      // 1. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without withdrawnLiquidation');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL2');     }      // 2. withdrawableCollateral     (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation     uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);     uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(         _remainingCollateralInShares,         address(collateralAsset)     );     uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);      assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been liquidated or not      // 6. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     log_named_uint('First Interest Repaid', _totalInterestRepaid);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt'); }  function test_helperFunctionsInLiquidatedState() public {     assert_helper_functionalities_in_liquidated_state(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:27:20 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:27:32 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:27:32 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 9590
completion_tokens: 740
total_tokens: 10330
cost: $-1.000000


[2024-27-08 09:27:32 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
.]

Based on the provided Solidity smart contract code for the `PCLLiquidatedStage` and the context of its functionality, here is a summary of potential security vulnerabilities and concerns identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Attacks**:
   - The contract does not appear to implement any reentrancy guards. Functions that transfer tokens or modify state variables should be protected against reentrancy attacks, especially those involving external calls.

2. **Access Control Issues**:
   - The contract relies on the assumption that only authorized users (admin, borrower, lenders) will call certain functions. However, there are no explicit access control modifiers (like `onlyOwner`) in place for critical functions, which could allow unauthorized access.

3. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, it is crucial to ensure that all arithmetic operations are consistently wrapped in `SafeMath` functions to prevent overflow or underflow vulnerabilities.

4. **Improper Error Handling**:
   - The contract uses `try/catch` for error handling in several places. If the error messages are not well-defined or if the revert reasons are not unique, it could lead to difficulties in debugging and understanding the failure reasons.

5. **Gas Limit Issues**:
   - Functions that involve loops or extensive state changes could run into gas limit issues, especially if the number of lenders or collateral amounts is large. This could lead to failed transactions.

6. **Lack of Input Validation**:
   - There is insufficient validation on inputs for functions that modify state or transfer tokens. For example, checks on the amounts being transferred or borrowed should be in place to prevent invalid operations.

7. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, where a malicious actor could observe pending transactions and exploit them for profit.

8. **State Variable Visibility**:
   - Some state variables may not have appropriate visibility modifiers (public, internal, private). This could expose sensitive data to unauthorized access.

9. **Lack of Event Emission**:
   - Critical state-changing functions should emit events to provide transparency and allow for easier tracking of contract activity. The absence of events could hinder monitoring and auditing.

### Comprehensive Analysis Report:

The `PCLLiquidatedStage` contract presents a robust framework for managing pooled credit lines, but several security vulnerabilities could pose significant risks if not addressed. The lack of reentrancy guards and explicit access control mechanisms could lead to unauthorized access and manipulation of contract state. Furthermore, while the use of `SafeMath` mitigates overflow and underflow risks, it is essential to ensure that all arithmetic operations are consistently protected.

Error handling through `try/catch` is a double-edged sword; while it provides a way to manage exceptions, poorly defined revert messages can complicate debugging. Additionally, the potential for gas limit issues and front-running attacks highlights the need for careful design and implementation of critical functions.

Input validation is crucial to prevent invalid operations, and the visibility of state variables should be reviewed to ensure sensitive data is adequately protected. Lastly, the absence of event emissions for state changes limits the contract's transparency and makes monitoring difficult.

In conclusion, while the contract demonstrates a well-structured approach to managing pooled credit lines, addressing the identified vulnerabilities is essential to enhance security and ensure the integrity of the contract's operations. Implementing best practices for access control, input validation, error handling, and event logging will significantly improve the contract's resilience against potential attacks and misuse. Regular audits and updates should be conducted to adapt to evolving security threats in the blockchain ecosystem.

[2024-27-08 09:27:32 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `PCLLiquidatedStage` and the context of its functionality, here is a summary of potential security vulnerabilities and concerns identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Attacks**:
   - The contract does not appear to implement any reentrancy guards. Functions that transfer tokens or modify state variables should be protected against reentrancy attacks, especially those involving external calls.

2. **Access Control Issues**:
   - The contract relies on the assumption that only authorized users (admin, borrower, lenders) will call certain functions. However, there are no explicit access control modifiers (like `onlyOwner`) in place for critical functions, which could allow unauthorized access.

3. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, it is crucial to ensure that all arithmetic operations are consistently wrapped in `SafeMath` functions to prevent overflow or underflow vulnerabilities.

4. **Improper Error Handling**:
   - The contract uses `try/catch` for error handling in several places. If the error messages are not well-defined or if the revert reasons are not unique, it could lead to difficulties in debugging and understanding the failure reasons.

5. **Gas Limit Issues**:
   - Functions that involve loops or extensive state changes could run into gas limit issues, especially if the number of lenders or collateral amounts is large. This could lead to failed transactions.

6. **Lack of Input Validation**:
   - There is insufficient validation on inputs for functions that modify state or transfer tokens. For example, checks on the amounts being transferred or borrowed should be in place to prevent invalid operations.

7. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, where a malicious actor could observe pending transactions and exploit them for profit.

8. **State Variable Visibility**:
   - Some state variables may not have appropriate visibility modifiers (public, internal, private). This could expose sensitive data to unauthorized access.

9. **Lack of Event Emission**:
   - Critical state-changing functions should emit events to provide transparency and allow for easier tracking of contract activity. The absence of events could hinder monitoring and auditing.

### Comprehensive Analysis Report:

The `PCLLiquidatedStage` contract presents a robust framework for managing pooled credit lines, but several security vulnerabilities could pose significant risks if not addressed. The lack of reentrancy guards and explicit access control mechanisms could lead to unauthorized access and manipulation of contract state. Furthermore, while the use of `SafeMath` mitigates overflow and underflow risks, it is essential to ensure that all arithmetic operations are consistently protected.

Error handling through `try/catch` is a double-edged sword; while it provides a way to manage exceptions, poorly defined revert messages can complicate debugging. Additionally, the potential for gas limit issues and front-running attacks highlights the need for careful design and implementation of critical functions.

Input validation is crucial to prevent invalid operations, and the visibility of state variables should be reviewed to ensure sensitive data is adequately protected. Lastly, the absence of event emissions for state changes limits the contract's transparency and makes monitoring difficult.

In conclusion, while the contract demonstrates a well-structured approach to managing pooled credit lines, addressing the identified vulnerabilities is essential to enhance security and ensure the integrity of the contract's operations. Implementing best practices for access control, input validation, error handling, and event logging will significantly improve the contract's resilience against potential attacks and misuse. Regular audits and updates should be conducted to adapt to evolving security threats in the blockchain ecosystem.

[2024-27-08 09:27:32 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-27-08 09:27:32 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId; address lender_0;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     lender_0 = lenders[0].lenderAddress;      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 10);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 200);      // Now we travel past the expiration date     vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      // Now the PCL should be in the LIQUIDATED state     PCLUser(lender_0).liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated'); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Liquidated PCL cannot be started function assert_start_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1'); }  function test_borrowerCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1'); }  function test_lenderCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in liquidated state',         'LP:S1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1'); }  function test_lenderCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in liquidated state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1'); }  function test_lenderCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a liquidated PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the Liquidated state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrowALiquidatedPCL() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB3'     ); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB1'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInLiquidatedState(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     admin.transferToken(address(borrowAsset), address(_user), 100);     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), 100);     }      try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_borrowerCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_lenderCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw collateral in Liquidated state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw zero collateral in Liquidated state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_Liquidated_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawLiquidity(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Liquidated PCL cannot be liquidated',         'PCL:L2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue(             (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                 (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                 true         );          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } }  function test_adminCanTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         borrower,         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_liquidated_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          //Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          vm.warp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 10);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.repay(_requestId, currentDebt / 200);      vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);      assert_pool_token_transfer_in_liquidated_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user == PCLUser(lenders[1].lenderAddress)) {         uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));         _user.withdrawTokensAfterLiquidation(_id);         uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));         assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);         if (request.collateralRatio != 0) {             assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);         }     } else {         try _user.withdrawTokensAfterLiquidation(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         admin,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         borrower,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_lenderCanWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentCR; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal; uint256 _currentDebt; uint256 collateralHeld;  function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);      log_named_uint('CD', _currentDebt);     log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);      if (request.collateralRatio != 0) {         (, , , , collateralHeld) = lp.pooledCLVariables(_id);          log_named_uint('Collateral Held', collateralHeld);          if (request.collateralAssetStrategy == compoundYieldAddress) {             assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)         } else {             // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');         }     } else {         log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral         assertGt(_equivalentCollateralTokens, 0);     }      // The currentCr is coming to be more than idealCR. Discuss.      // 0. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     if (request.collateralRatio != 0) {         // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away     } else {         assertTrue(true);     }      // 1. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without withdrawnLiquidation');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL2');     }      // 2. withdrawableCollateral     (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation     uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);     uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(         _remainingCollateralInShares,         address(collateralAsset)     );     uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);      assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been liquidated or not      // 6. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     log_named_uint('First Interest Repaid', _totalInterestRepaid);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt'); }  function test_helperFunctionsInLiquidatedState() public {     assert_helper_functionalities_in_liquidated_state(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 requestId;\n    address lender_0;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        lender_0 = lenders[0].lenderAddress;\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 10);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, currentDebt / 200);\n\n        // Now we travel past the expiration date\n        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n\n        // Now the PCL should be in the LIQUIDATED state\n        PCLUser(lender_0).liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test0: Test SetUp\n    function test_SetUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // START function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // Test1: Liquidated PCL cannot be started\n    function assert_start_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertString,\n        string memory _errorString\n    ) public {\n        try _user.start(_id) {\n            revert(_revertString);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorString);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_adminCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');\n    }\n\n    function test_borrowerCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');\n    }\n\n    function test_lenderCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot start a PCL in liquidated state',\n            'LP:S1'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CANCEL function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_cancel_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_adminCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');\n    }\n\n    function test_lenderCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot Cancel a PCL in liquidated state',\n            'PCL:OCLB1'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CLOSE function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_close_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_adminCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');\n    }\n\n    function test_lenderCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot close a liquidated PCL',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Deposit collateral function calls\n    *******************/\n\n    function assert_collateralCannotBeDepositedInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        if (_depositor != borrower) {\n            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n        }\n\n        try _depositor.depositCollateral(_id, _amount, false) {\n            revert('Collateral cannot be deposited in the Liquidated state');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:DC2');\n        }\n    }\n\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);\n    }\n\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);\n    }\n\n    /*******************\n    Borrow function tests\n    *******************/\n\n    function assertBorrowFunctionalityInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Admin cannot borrow a PCL in Liquidated state',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotBorrowALiquidatedPCL() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot borrow a PCL in Liquidated state',\n            'PCL:IB3'\n        );\n    }\n\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot borrow a PCL in Liquidated state',\n            'PCL:IB1'\n        );\n    }\n\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Lender cannot borrow a PCL in Liquidated state',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Repay function tests\n    *******************/\n\n    function assertRepayFunctionalityInLiquidatedState(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        admin.transferToken(address(borrowAsset), address(_user), 100);\n        if (_user != borrower) {\n            _user.setAllowance(address(pcl), address(borrowAsset), 100);\n        }\n\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Admin cannot repay a Liquidated PCL',\n            'PCL:REP2'\n        );\n    }\n\n    function test_borrowerCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot repay a Liquidated PCL',\n            'PCL:REP2'\n        );\n    }\n\n    function test_lenderCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Lender cannot repay a Liquidated PCL',\n            'PCL:REP2'\n        );\n    }\n\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n\n    function assertWithdrawCollateralFunctionalityInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawAllCollateral(_id, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertGe(_balanceAfter, _balanceBefore);\n        } else {\n            try _user.withdrawAllCollateral(_id, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessageAll);\n            }\n        }\n\n        if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawCollateral(_id, _amount, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);\n        } else {\n            try _user.withdrawCollateral(_id, _amount, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n    }\n\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Admin cannot withdraw collateral in Liquidated state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot withdraw collateral in Liquidated state',\n            'PCL:WC1',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot withdraw zero collateral in Liquidated state',\n            'PCL:WC2',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Lender cannot withdraw collateral in Liquidated state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    WithdrawLiquidity function calls\n    ********************/\n\n    function assert_withdraw_liquidity_functionality_in_Liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.withdrawLiquidity(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Admin cannot withdraw liquidity a PCL in Liquidated state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot withdraw liquidity a PCL in Liquidated state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Lender cannot withdraw liquidity a PCL in Liquidated state',\n            'LP:IWL2'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // LIQUIDATE function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_liquidate_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_adminCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');\n    }\n\n    function test_borrowerCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');\n    }\n\n    function test_lenderCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Liquidated PCL cannot be liquidated',\n            'PCL:L2'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Terminate function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_terminate_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));\n\n        try _user.terminate(_id) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n\n            if (_user == admin) {\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);\n                assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);\n                if (request.collateralRatio != 0) {\n                    assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);\n                }\n            } else {\n                assertTrue(\n                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                        true\n                );\n                revert(_revertMessage);\n            }\n        } catch Error(string memory reason) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n\n            assertTrue(\n                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                    true\n            );\n\n            assertEq(reason, _errorMessage);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        }\n    }\n\n    function test_adminCanTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');\n    }\n\n    function test_borrowerCannotTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(\n            requestId,\n            borrower,\n            'Cannot terminate a PCL that is liquidated',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    function test_lenderCannotTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Cannot terminate a PCL that is liquidated',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Pool Token Transfer function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    uint256 lender0PoolTokenBalance;\n    uint256 lender1PoolTokenBalance;\n    uint256 lender2PoolTokenBalance;\n    uint256 lender3PoolTokenBalance;\n    uint256 _from1BalancePostBurn;\n    uint256 lender0PoolTokenBalanceFinal;\n    uint256 lender1PoolTokenBalanceFinal;\n    uint256 lender2PoolTokenBalanceFinal;\n    uint256 lender3PoolTokenBalanceFinal;\n    uint256 _defaultTimeStamp;\n\n    PCLUser _from1;\n    PCLUser _from2;\n    PCLUser _to1;\n    PCLUser _to2;\n\n    function assert_pool_token_transfer_in_liquidated_stage(\n        uint256 _id,\n        uint256 _fractionOfPTSupply,\n        bool _positiveCase,\n        address _From1,\n        address _From2,\n        address _To1,\n        address _To2,\n        string memory _errorString\n    ) public {\n        _from1 = PCLUser(_From1);\n        _from2 = PCLUser(_From2);\n        _to1 = PCLUser(_To1);\n        _to2 = PCLUser(_To2);\n\n        if (_positiveCase) {\n            // Ensuring that these lenders indeed had lent something\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);\n            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);\n\n            assertGt(lender0PoolTokenBalance, 0);\n            assertGt(lender1PoolTokenBalance, 0);\n            assertGt(lender2PoolTokenBalance, 0);\n            assertGt(lender3PoolTokenBalance, 0);\n\n            // Lender0 transfers pool tokens to lender1\n            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));\n\n            //Checking the transfer took place or not\n            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);\n\n            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));\n            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));\n\n            vm.warp(block.timestamp + request.defaultGracePeriod);\n\n            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);\n\n            // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');\n\n            // Lender2 transfers pool tokens to lender3\n            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);\n\n            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);\n\n            // Checking whether the transfer took place or not\n            assertTrue(lender2PoolTokenBalanceFinal == 0);\n            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {\n                if (_To1 == address(0)) {\n                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);\n                    assertEq(_from1BalancePostBurn, 0);\n                } else {\n                    revert('REVERT');\n                }\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorString);\n            }\n        }\n    }\n\n    function test_poolTokenTransferComplete_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartial_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            2,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartialByFour_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            4,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_cannotBurnPoolToken_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(0),\n            address(0),\n            'ERC1155: transfer to the zero address'\n        );\n    }\n\n    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[0].lenderAddress,\n            address(0),\n            'LP:IT1'\n        );\n    }\n\n    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            protocolFeeCollectorAddress,\n            address(0),\n            'LP:IT3'\n        );\n    }\n\n    function test_cannotTransferLPTokensToBorrower() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(borrower),\n            address(0),\n            'LP:IT2'\n        );\n    }\n\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_requestId, _requiredCollateral, false);\n        }\n\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount);\n\n        vm.warp(block.timestamp + request.duration / 10);\n        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.repay(_requestId, currentDebt / 200);\n\n        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n\n        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);\n\n        assert_pool_token_transfer_in_liquidated_stage(\n            _requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[1].lenderAddress,\n            address(0),\n            'LP:IT5'\n        );\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert('External user cannot create');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert('External user cannot terminate');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert('Lender cannot lend zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L1');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Unverified lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L2');\n        }\n    }\n\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Interest function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_withdraw_interest_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);\n            }\n\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');\n    }\n\n    function test_borrowerCannotWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');\n    }\n\n    function test_lendersCanWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Liquidation function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_withdraw_liquidation_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_user == PCLUser(lenders[1].lenderAddress)) {\n            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));\n            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));\n            _user.withdrawTokensAfterLiquidation(_id);\n            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));\n            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));\n            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);\n            if (request.collateralRatio != 0) {\n                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);\n            }\n        } else {\n            try _user.withdrawTokensAfterLiquidation(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n    }\n\n    function test_adminCannotWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(\n            requestId,\n            admin,\n            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',\n            'LP:WLC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(\n            requestId,\n            borrower,\n            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',\n            'LP:WLC1'\n        );\n    }\n\n    function test_lenderCanWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // View/calculation function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    uint256 _currentCR;\n    uint256 _totalInterestPending;\n    uint256 _totalInterestRepaid;\n    uint256 _principal;\n    uint256 _currentDebt;\n    uint256 collateralHeld;\n\n    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 0. collateralTokensToLiquidate\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);\n\n        log_named_uint('CD', _currentDebt);\n        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);\n\n        if (request.collateralRatio != 0) {\n            (, , , , collateralHeld) = lp.pooledCLVariables(_id);\n\n            log_named_uint('Collateral Held', collateralHeld);\n\n            if (request.collateralAssetStrategy == compoundYieldAddress) {\n                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)\n            } else {\n                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');\n            }\n        } else {\n            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral\n            assertGt(_equivalentCollateralTokens, 0);\n        }\n\n        // The currentCr is coming to be more than idealCR. Discuss.\n\n        // 0. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        if (request.collateralRatio != 0) {\n            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away\n        } else {\n            assertTrue(true);\n        }\n\n        // 1. calculatePrincipalWithdrawable\n        try _lender.withdrawLiquidity(_id) {\n            revert('Cannot be called without withdrawnLiquidation');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL2');\n        }\n\n        // 2. withdrawableCollateral\n        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation\n        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);\n        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(\n            _remainingCollateralInShares,\n            address(collateralAsset)\n        );\n        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n\n        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');\n\n        // 3.calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');\n\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now\n\n        // 5. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment\n        // doesn't matter whether the PCL has been liquidated or not\n\n        // 6. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);\n        _totalInterestPending = _borrower.calculateInterestAccrued(_id);\n        log_named_uint('First Interest Repaid', _totalInterestRepaid);\n        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;\n        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');\n    }\n\n    function test_helperFunctionsInLiquidatedState() public {\n        assert_helper_functionalities_in_liquidated_state(requestId);\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:27:32 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId; address lender_0;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     lender_0 = lenders[0].lenderAddress;      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 10);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 200);      // Now we travel past the expiration date     vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      // Now the PCL should be in the LIQUIDATED state     PCLUser(lender_0).liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated'); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Liquidated PCL cannot be started function assert_start_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1'); }  function test_borrowerCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1'); }  function test_lenderCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in liquidated state',         'LP:S1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1'); }  function test_lenderCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in liquidated state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1'); }  function test_lenderCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a liquidated PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the Liquidated state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrowALiquidatedPCL() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB3'     ); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB1'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInLiquidatedState(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     admin.transferToken(address(borrowAsset), address(_user), 100);     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), 100);     }      try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_borrowerCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_lenderCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw collateral in Liquidated state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw zero collateral in Liquidated state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_Liquidated_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawLiquidity(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Liquidated PCL cannot be liquidated',         'PCL:L2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue(             (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                 (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                 true         );          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } }  function test_adminCanTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         borrower,         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_liquidated_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          //Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          vm.warp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 10);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.repay(_requestId, currentDebt / 200);      vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);      assert_pool_token_transfer_in_liquidated_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user == PCLUser(lenders[1].lenderAddress)) {         uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));         _user.withdrawTokensAfterLiquidation(_id);         uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));         assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);         if (request.collateralRatio != 0) {             assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);         }     } else {         try _user.withdrawTokensAfterLiquidation(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         admin,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         borrower,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_lenderCanWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentCR; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal; uint256 _currentDebt; uint256 collateralHeld;  function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);      log_named_uint('CD', _currentDebt);     log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);      if (request.collateralRatio != 0) {         (, , , , collateralHeld) = lp.pooledCLVariables(_id);          log_named_uint('Collateral Held', collateralHeld);          if (request.collateralAssetStrategy == compoundYieldAddress) {             assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)         } else {             // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');         }     } else {         log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral         assertGt(_equivalentCollateralTokens, 0);     }      // The currentCr is coming to be more than idealCR. Discuss.      // 0. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     if (request.collateralRatio != 0) {         // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away     } else {         assertTrue(true);     }      // 1. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without withdrawnLiquidation');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL2');     }      // 2. withdrawableCollateral     (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation     uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);     uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(         _remainingCollateralInShares,         address(collateralAsset)     );     uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);      assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been liquidated or not      // 6. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     log_named_uint('First Interest Repaid', _totalInterestRepaid);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt'); }  function test_helperFunctionsInLiquidatedState() public {     assert_helper_functionalities_in_liquidated_state(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:27:32 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:27:35 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:27:35 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19061
completion_tokens: 1
total_tokens: 19062
cost: $-1.000000


[2024-27-08 09:27:35 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
.]

###

[2024-27-08 09:27:35 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:27:35 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-27-08 09:27:35 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId; address lender_0;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     lender_0 = lenders[0].lenderAddress;      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 10);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 200);      // Now we travel past the expiration date     vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      // Now the PCL should be in the LIQUIDATED state     PCLUser(lender_0).liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated'); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Liquidated PCL cannot be started function assert_start_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1'); }  function test_borrowerCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1'); }  function test_lenderCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in liquidated state',         'LP:S1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1'); }  function test_lenderCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in liquidated state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1'); }  function test_lenderCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a liquidated PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the Liquidated state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrowALiquidatedPCL() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB3'     ); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB1'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInLiquidatedState(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     admin.transferToken(address(borrowAsset), address(_user), 100);     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), 100);     }      try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_borrowerCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_lenderCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw collateral in Liquidated state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw zero collateral in Liquidated state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_Liquidated_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawLiquidity(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Liquidated PCL cannot be liquidated',         'PCL:L2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue(             (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                 (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                 true         );          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } }  function test_adminCanTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         borrower,         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_liquidated_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          //Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          vm.warp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 10);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.repay(_requestId, currentDebt / 200);      vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);      assert_pool_token_transfer_in_liquidated_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user == PCLUser(lenders[1].lenderAddress)) {         uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));         _user.withdrawTokensAfterLiquidation(_id);         uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));         assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);         if (request.collateralRatio != 0) {             assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);         }     } else {         try _user.withdrawTokensAfterLiquidation(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         admin,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         borrower,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_lenderCanWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentCR; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal; uint256 _currentDebt; uint256 collateralHeld;  function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);      log_named_uint('CD', _currentDebt);     log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);      if (request.collateralRatio != 0) {         (, , , , collateralHeld) = lp.pooledCLVariables(_id);          log_named_uint('Collateral Held', collateralHeld);          if (request.collateralAssetStrategy == compoundYieldAddress) {             assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)         } else {             // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');         }     } else {         log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral         assertGt(_equivalentCollateralTokens, 0);     }      // The currentCr is coming to be more than idealCR. Discuss.      // 0. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     if (request.collateralRatio != 0) {         // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away     } else {         assertTrue(true);     }      // 1. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without withdrawnLiquidation');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL2');     }      // 2. withdrawableCollateral     (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation     uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);     uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(         _remainingCollateralInShares,         address(collateralAsset)     );     uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);      assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been liquidated or not      // 6. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     log_named_uint('First Interest Repaid', _totalInterestRepaid);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt'); }  function test_helperFunctionsInLiquidatedState() public {     assert_helper_functionalities_in_liquidated_state(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:27:36 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId; address lender_0;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     lender_0 = lenders[0].lenderAddress;      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 10);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 200);      // Now we travel past the expiration date     vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      // Now the PCL should be in the LIQUIDATED state     PCLUser(lender_0).liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated'); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Liquidated PCL cannot be started function assert_start_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1'); }  function test_borrowerCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1'); }  function test_lenderCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in liquidated state',         'LP:S1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1'); }  function test_lenderCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in liquidated state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1'); }  function test_lenderCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a liquidated PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the Liquidated state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrowALiquidatedPCL() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB3'     ); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB1'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInLiquidatedState(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     admin.transferToken(address(borrowAsset), address(_user), 100);     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), 100);     }      try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_borrowerCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_lenderCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw collateral in Liquidated state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw zero collateral in Liquidated state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_Liquidated_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawLiquidity(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Liquidated PCL cannot be liquidated',         'PCL:L2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue(             (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                 (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                 true         );          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } }  function test_adminCanTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         borrower,         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_liquidated_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          //Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          vm.warp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 10);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.repay(_requestId, currentDebt / 200);      vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);      assert_pool_token_transfer_in_liquidated_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user == PCLUser(lenders[1].lenderAddress)) {         uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));         _user.withdrawTokensAfterLiquidation(_id);         uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));         assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);         if (request.collateralRatio != 0) {             assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);         }     } else {         try _user.withdrawTokensAfterLiquidation(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         admin,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         borrower,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_lenderCanWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentCR; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal; uint256 _currentDebt; uint256 collateralHeld;  function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);      log_named_uint('CD', _currentDebt);     log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);      if (request.collateralRatio != 0) {         (, , , , collateralHeld) = lp.pooledCLVariables(_id);          log_named_uint('Collateral Held', collateralHeld);          if (request.collateralAssetStrategy == compoundYieldAddress) {             assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)         } else {             // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');         }     } else {         log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral         assertGt(_equivalentCollateralTokens, 0);     }      // The currentCr is coming to be more than idealCR. Discuss.      // 0. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     if (request.collateralRatio != 0) {         // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away     } else {         assertTrue(true);     }      // 1. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without withdrawnLiquidation');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL2');     }      // 2. withdrawableCollateral     (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation     uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);     uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(         _remainingCollateralInShares,         address(collateralAsset)     );     uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);      assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been liquidated or not      // 6. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     log_named_uint('First Interest Repaid', _totalInterestRepaid);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt'); }  function test_helperFunctionsInLiquidatedState() public {     assert_helper_functionalities_in_liquidated_state(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:27:36 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:27:48 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:27:48 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 9590
completion_tokens: 681
total_tokens: 10271
cost: $-1.000000


[2024-27-08 09:27:48 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
.]

Based on the provided smart contract code for the `PCLLiquidatedStage` contract, the following security vulnerabilities and issues have been identified:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**: 
   - The contract does not implement any reentrancy guards. Functions that transfer tokens or modify state variables could be susceptible to reentrancy attacks, especially in functions like `withdrawTokensAfterLiquidation`, `withdrawCollateral`, and `borrow`.

2. **Lack of Input Validation**:
   - Functions such as `borrow`, `repay`, and `depositCollateral` do not have sufficient checks for input values. For example, borrowing a zero amount or invalid collateral amounts could lead to unexpected behavior.

3. **Access Control Issues**:
   - The contract allows certain actions to be performed by users who should not have permission, such as liquidating a PCL by unauthorized users. The access control mechanisms need to be reinforced to ensure that only authorized users can perform sensitive operations.

4. **Error Handling**:
   - The contract relies heavily on `try/catch` for error handling, which may not cover all possible failure scenarios. This could lead to unexpected behavior if an error occurs that is not caught.

5. **Gas Limit Issues**:
   - Some functions may consume a significant amount of gas, especially those that involve looping through arrays or performing multiple state changes. This could lead to out-of-gas errors during execution.

6. **Potential Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, it is essential to ensure that all arithmetic operations are adequately protected against overflow and underflow, especially in critical financial calculations.

7. **Lack of Events**:
   - The contract does not emit events for critical state changes, such as liquidations, deposits, and withdrawals. This lack of transparency can hinder tracking and auditing of contract activities.

8. **Improper Handling of Collateral**:
   - The logic for calculating and handling collateral may not be robust enough to prevent scenarios where users can manipulate the system to withdraw more collateral than they should be entitled to.

### Comprehensive Analysis Report

The `PCLLiquidatedStage` contract presents several security vulnerabilities that could potentially lead to significant financial losses or exploitation. The absence of reentrancy guards poses a critical risk, especially in functions that involve transferring tokens. Furthermore, insufficient input validation could allow users to perform unintended actions, such as borrowing zero amounts or invalid collateral deposits.

Access control mechanisms must be strengthened to ensure that only authorized users can execute sensitive functions, particularly those related to liquidations and withdrawals. The reliance on `try/catch` for error handling may not adequately cover all failure scenarios, which could lead to unexpected contract behavior.

Additionally, the contract's gas consumption should be optimized to prevent out-of-gas errors, and careful attention must be paid to arithmetic operations to avoid integer overflow or underflow issues. The lack of emitted events for significant state changes reduces the transparency and traceability of contract activities, which is essential for auditing and monitoring.

In conclusion, while the `PCLLiquidatedStage` contract implements several functionalities related to pooled credit lines, it requires significant improvements in security practices, error handling, and access control to ensure the safety and reliability of the contract. A thorough audit and testing phase should be conducted to address these vulnerabilities before deployment.

[2024-27-08 09:27:48 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `PCLLiquidatedStage` contract, the following security vulnerabilities and issues have been identified:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**: 
   - The contract does not implement any reentrancy guards. Functions that transfer tokens or modify state variables could be susceptible to reentrancy attacks, especially in functions like `withdrawTokensAfterLiquidation`, `withdrawCollateral`, and `borrow`.

2. **Lack of Input Validation**:
   - Functions such as `borrow`, `repay`, and `depositCollateral` do not have sufficient checks for input values. For example, borrowing a zero amount or invalid collateral amounts could lead to unexpected behavior.

3. **Access Control Issues**:
   - The contract allows certain actions to be performed by users who should not have permission, such as liquidating a PCL by unauthorized users. The access control mechanisms need to be reinforced to ensure that only authorized users can perform sensitive operations.

4. **Error Handling**:
   - The contract relies heavily on `try/catch` for error handling, which may not cover all possible failure scenarios. This could lead to unexpected behavior if an error occurs that is not caught.

5. **Gas Limit Issues**:
   - Some functions may consume a significant amount of gas, especially those that involve looping through arrays or performing multiple state changes. This could lead to out-of-gas errors during execution.

6. **Potential Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, it is essential to ensure that all arithmetic operations are adequately protected against overflow and underflow, especially in critical financial calculations.

7. **Lack of Events**:
   - The contract does not emit events for critical state changes, such as liquidations, deposits, and withdrawals. This lack of transparency can hinder tracking and auditing of contract activities.

8. **Improper Handling of Collateral**:
   - The logic for calculating and handling collateral may not be robust enough to prevent scenarios where users can manipulate the system to withdraw more collateral than they should be entitled to.

### Comprehensive Analysis Report

The `PCLLiquidatedStage` contract presents several security vulnerabilities that could potentially lead to significant financial losses or exploitation. The absence of reentrancy guards poses a critical risk, especially in functions that involve transferring tokens. Furthermore, insufficient input validation could allow users to perform unintended actions, such as borrowing zero amounts or invalid collateral deposits.

Access control mechanisms must be strengthened to ensure that only authorized users can execute sensitive functions, particularly those related to liquidations and withdrawals. The reliance on `try/catch` for error handling may not adequately cover all failure scenarios, which could lead to unexpected contract behavior.

Additionally, the contract's gas consumption should be optimized to prevent out-of-gas errors, and careful attention must be paid to arithmetic operations to avoid integer overflow or underflow issues. The lack of emitted events for significant state changes reduces the transparency and traceability of contract activities, which is essential for auditing and monitoring.

In conclusion, while the `PCLLiquidatedStage` contract implements several functionalities related to pooled credit lines, it requires significant improvements in security practices, error handling, and access control to ensure the safety and reliability of the contract. A thorough audit and testing phase should be conducted to address these vulnerabilities before deployment.

[2024-27-08 09:27:51 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId; address lender_0;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     lender_0 = lenders[0].lenderAddress;      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 10);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 200);      // Now we travel past the expiration date     vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      // Now the PCL should be in the LIQUIDATED state     PCLUser(lender_0).liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated'); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Liquidated PCL cannot be started function assert_start_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1'); }  function test_borrowerCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1'); }  function test_lenderCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in liquidated state',         'LP:S1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1'); }  function test_lenderCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in liquidated state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1'); }  function test_lenderCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a liquidated PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the Liquidated state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrowALiquidatedPCL() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB3'     ); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB1'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInLiquidatedState(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     admin.transferToken(address(borrowAsset), address(_user), 100);     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), 100);     }      try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_borrowerCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_lenderCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw collateral in Liquidated state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw zero collateral in Liquidated state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_Liquidated_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawLiquidity(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Liquidated PCL cannot be liquidated',         'PCL:L2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue(             (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                 (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                 true         );          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } }  function test_adminCanTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         borrower,         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_liquidated_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          //Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          vm.warp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 10);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.repay(_requestId, currentDebt / 200);      vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);      assert_pool_token_transfer_in_liquidated_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user == PCLUser(lenders[1].lenderAddress)) {         uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));         _user.withdrawTokensAfterLiquidation(_id);         uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));         assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);         if (request.collateralRatio != 0) {             assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);         }     } else {         try _user.withdrawTokensAfterLiquidation(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         admin,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         borrower,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_lenderCanWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentCR; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal; uint256 _currentDebt; uint256 collateralHeld;  function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);      log_named_uint('CD', _currentDebt);     log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);      if (request.collateralRatio != 0) {         (, , , , collateralHeld) = lp.pooledCLVariables(_id);          log_named_uint('Collateral Held', collateralHeld);          if (request.collateralAssetStrategy == compoundYieldAddress) {             assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)         } else {             // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');         }     } else {         log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral         assertGt(_equivalentCollateralTokens, 0);     }      // The currentCr is coming to be more than idealCR. Discuss.      // 0. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     if (request.collateralRatio != 0) {         // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away     } else {         assertTrue(true);     }      // 1. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without withdrawnLiquidation');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL2');     }      // 2. withdrawableCollateral     (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation     uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);     uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(         _remainingCollateralInShares,         address(collateralAsset)     );     uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);      assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been liquidated or not      // 6. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     log_named_uint('First Interest Repaid', _totalInterestRepaid);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt'); }  function test_helperFunctionsInLiquidatedState() public {     assert_helper_functionalities_in_liquidated_state(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 requestId;\n    address lender_0;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        lender_0 = lenders[0].lenderAddress;\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 10);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, currentDebt / 200);\n\n        // Now we travel past the expiration date\n        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n\n        // Now the PCL should be in the LIQUIDATED state\n        PCLUser(lender_0).liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test0: Test SetUp\n    function test_SetUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // START function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // Test1: Liquidated PCL cannot be started\n    function assert_start_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertString,\n        string memory _errorString\n    ) public {\n        try _user.start(_id) {\n            revert(_revertString);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorString);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_adminCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');\n    }\n\n    function test_borrowerCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');\n    }\n\n    function test_lenderCannotStartALiquidatedPCL() public {\n        assert_start_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot start a PCL in liquidated state',\n            'LP:S1'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CANCEL function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_cancel_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_adminCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');\n    }\n\n    function test_lenderCannotCancelALiquidatedPCL() public {\n        assert_cancel_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot Cancel a PCL in liquidated state',\n            'PCL:OCLB1'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // CLOSE function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_close_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_adminCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');\n    }\n\n    function test_lenderCannotCloseALiquidatedPCL() public {\n        assert_close_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot close a liquidated PCL',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Deposit collateral function calls\n    *******************/\n\n    function assert_collateralCannotBeDepositedInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        if (_depositor != borrower) {\n            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n        }\n\n        try _depositor.depositCollateral(_id, _amount, false) {\n            revert('Collateral cannot be deposited in the Liquidated state');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:DC2');\n        }\n    }\n\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);\n    }\n\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);\n    }\n\n    /*******************\n    Borrow function tests\n    *******************/\n\n    function assertBorrowFunctionalityInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Admin cannot borrow a PCL in Liquidated state',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotBorrowALiquidatedPCL() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot borrow a PCL in Liquidated state',\n            'PCL:IB3'\n        );\n    }\n\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot borrow a PCL in Liquidated state',\n            'PCL:IB1'\n        );\n    }\n\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Lender cannot borrow a PCL in Liquidated state',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Repay function tests\n    *******************/\n\n    function assertRepayFunctionalityInLiquidatedState(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        admin.transferToken(address(borrowAsset), address(_user), 100);\n        if (_user != borrower) {\n            _user.setAllowance(address(pcl), address(borrowAsset), 100);\n        }\n\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Admin cannot repay a Liquidated PCL',\n            'PCL:REP2'\n        );\n    }\n\n    function test_borrowerCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot repay a Liquidated PCL',\n            'PCL:REP2'\n        );\n    }\n\n    function test_lenderCannotRepayALiquidatedPCL() public {\n        assertRepayFunctionalityInLiquidatedState(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Lender cannot repay a Liquidated PCL',\n            'PCL:REP2'\n        );\n    }\n\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n\n    function assertWithdrawCollateralFunctionalityInLiquidatedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public {\n        if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawAllCollateral(_id, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertGe(_balanceAfter, _balanceBefore);\n        } else {\n            try _user.withdrawAllCollateral(_id, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessageAll);\n            }\n        }\n\n        if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawCollateral(_id, _amount, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);\n        } else {\n            try _user.withdrawCollateral(_id, _amount, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n    }\n\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Admin cannot withdraw collateral in Liquidated state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot withdraw collateral in Liquidated state',\n            'PCL:WC1',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            0,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot withdraw zero collateral in Liquidated state',\n            'PCL:WC2',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInLiquidatedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Lender cannot withdraw collateral in Liquidated state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    WithdrawLiquidity function calls\n    ********************/\n\n    function assert_withdraw_liquidity_functionality_in_Liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        uint256 _stateToAssert,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.withdrawLiquidity(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);\n    }\n\n    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            admin,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Admin cannot withdraw liquidity a PCL in Liquidated state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            borrower,\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Borrower cannot withdraw liquidity a PCL in Liquidated state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {\n        assert_withdraw_liquidity_functionality_in_Liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            uint256(PooledCreditLineStatus.LIQUIDATED),\n            'Lender cannot withdraw liquidity a PCL in Liquidated state',\n            'LP:IWL2'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // LIQUIDATE function calls\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_liquidate_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    function test_adminCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');\n    }\n\n    function test_borrowerCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');\n    }\n\n    function test_lenderCannotLiquidateALiquidatedPCL() public {\n        assert_liquidate_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Liquidated PCL cannot be liquidated',\n            'PCL:L2'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Terminate function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_terminate_functionality_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));\n\n        try _user.terminate(_id) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n\n            if (_user == admin) {\n                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);\n                assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);\n                if (request.collateralRatio != 0) {\n                    assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);\n                }\n            } else {\n                assertTrue(\n                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                        true\n                );\n                revert(_revertMessage);\n            }\n        } catch Error(string memory reason) {\n            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));\n            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));\n\n            assertTrue(\n                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==\n                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==\n                    true\n            );\n\n            assertEq(reason, _errorMessage);\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        }\n    }\n\n    function test_adminCanTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');\n    }\n\n    function test_borrowerCannotTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(\n            requestId,\n            borrower,\n            'Cannot terminate a PCL that is liquidated',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    function test_lenderCannotTerminateALiquidatedPCL() public {\n        assert_terminate_functionality_in_liquidated_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Cannot terminate a PCL that is liquidated',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Pool Token Transfer function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    uint256 lender0PoolTokenBalance;\n    uint256 lender1PoolTokenBalance;\n    uint256 lender2PoolTokenBalance;\n    uint256 lender3PoolTokenBalance;\n    uint256 _from1BalancePostBurn;\n    uint256 lender0PoolTokenBalanceFinal;\n    uint256 lender1PoolTokenBalanceFinal;\n    uint256 lender2PoolTokenBalanceFinal;\n    uint256 lender3PoolTokenBalanceFinal;\n    uint256 _defaultTimeStamp;\n\n    PCLUser _from1;\n    PCLUser _from2;\n    PCLUser _to1;\n    PCLUser _to2;\n\n    function assert_pool_token_transfer_in_liquidated_stage(\n        uint256 _id,\n        uint256 _fractionOfPTSupply,\n        bool _positiveCase,\n        address _From1,\n        address _From2,\n        address _To1,\n        address _To2,\n        string memory _errorString\n    ) public {\n        _from1 = PCLUser(_From1);\n        _from2 = PCLUser(_From2);\n        _to1 = PCLUser(_To1);\n        _to2 = PCLUser(_To2);\n\n        if (_positiveCase) {\n            // Ensuring that these lenders indeed had lent something\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);\n            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);\n\n            assertGt(lender0PoolTokenBalance, 0);\n            assertGt(lender1PoolTokenBalance, 0);\n            assertGt(lender2PoolTokenBalance, 0);\n            assertGt(lender3PoolTokenBalance, 0);\n\n            // Lender0 transfers pool tokens to lender1\n            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));\n\n            //Checking the transfer took place or not\n            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);\n            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);\n\n            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));\n            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));\n\n            vm.warp(block.timestamp + request.defaultGracePeriod);\n\n            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);\n\n            // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');\n\n            // Lender2 transfers pool tokens to lender3\n            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);\n\n            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);\n            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);\n\n            // Checking whether the transfer took place or not\n            assertTrue(lender2PoolTokenBalanceFinal == 0);\n            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n\n            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);\n            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {\n                if (_To1 == address(0)) {\n                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);\n                    assertEq(_from1BalancePostBurn, 0);\n                } else {\n                    revert('REVERT');\n                }\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorString);\n            }\n        }\n    }\n\n    function test_poolTokenTransferComplete_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartial_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            2,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartialByFour_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            4,\n            true,\n            lenders[0].lenderAddress,\n            lenders[1].lenderAddress,\n            lenders[2].lenderAddress,\n            lenders[3].lenderAddress,\n            ''\n        );\n    }\n\n    function test_cannotBurnPoolToken_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(0),\n            address(0),\n            'ERC1155: transfer to the zero address'\n        );\n    }\n\n    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[0].lenderAddress,\n            address(0),\n            'LP:IT1'\n        );\n    }\n\n    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            protocolFeeCollectorAddress,\n            address(0),\n            'LP:IT3'\n        );\n    }\n\n    function test_cannotTransferLPTokensToBorrower() public {\n        assert_pool_token_transfer_in_liquidated_stage(\n            requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            address(borrower),\n            address(0),\n            'LP:IT2'\n        );\n    }\n\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_requestId, _requiredCollateral, false);\n        }\n\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount);\n\n        vm.warp(block.timestamp + request.duration / 10);\n        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.repay(_requestId, currentDebt / 200);\n\n        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n\n        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);\n\n        assert_pool_token_transfer_in_liquidated_stage(\n            _requestId,\n            1,\n            false,\n            lenders[0].lenderAddress,\n            address(0),\n            lenders[1].lenderAddress,\n            address(0),\n            'LP:IT5'\n        );\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert('External user cannot create');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert('External user cannot terminate');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert('Lender cannot lend zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L1');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Unverified lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L2');\n        }\n    }\n\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Interest function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_withdraw_interest_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);\n            }\n\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');\n    }\n\n    function test_borrowerCannotWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');\n    }\n\n    function test_lendersCanWithdrawInterest_liquidatedState() public {\n        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Withdraw Liquidation function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function assert_withdraw_liquidation_in_liquidated_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_user == PCLUser(lenders[1].lenderAddress)) {\n            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));\n            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));\n            _user.withdrawTokensAfterLiquidation(_id);\n            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));\n            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));\n            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);\n            if (request.collateralRatio != 0) {\n                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);\n            }\n        } else {\n            try _user.withdrawTokensAfterLiquidation(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n    }\n\n    function test_adminCannotWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(\n            requestId,\n            admin,\n            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',\n            'LP:WLC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(\n            requestId,\n            borrower,\n            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',\n            'LP:WLC1'\n        );\n    }\n\n    function test_lenderCanWithdrawLiquidation_liquidatedState() public {\n        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // View/calculation function tests\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    uint256 _currentCR;\n    uint256 _totalInterestPending;\n    uint256 _totalInterestRepaid;\n    uint256 _principal;\n    uint256 _currentDebt;\n    uint256 collateralHeld;\n\n    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 0. collateralTokensToLiquidate\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);\n\n        log_named_uint('CD', _currentDebt);\n        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);\n\n        if (request.collateralRatio != 0) {\n            (, , , , collateralHeld) = lp.pooledCLVariables(_id);\n\n            log_named_uint('Collateral Held', collateralHeld);\n\n            if (request.collateralAssetStrategy == compoundYieldAddress) {\n                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)\n            } else {\n                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');\n            }\n        } else {\n            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral\n            assertGt(_equivalentCollateralTokens, 0);\n        }\n\n        // The currentCr is coming to be more than idealCR. Discuss.\n\n        // 0. calculateCurrentCollateralRatio\n        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);\n        if (request.collateralRatio != 0) {\n            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away\n        } else {\n            assertTrue(true);\n        }\n\n        // 1. calculatePrincipalWithdrawable\n        try _lender.withdrawLiquidity(_id) {\n            revert('Cannot be called without withdrawnLiquidation');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL2');\n        }\n\n        // 2. withdrawableCollateral\n        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation\n        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);\n        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(\n            _remainingCollateralInShares,\n            address(collateralAsset)\n        );\n        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n\n        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');\n\n        // 3.calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');\n\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now\n\n        // 5. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment\n        // doesn't matter whether the PCL has been liquidated or not\n\n        // 6. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);\n        _totalInterestPending = _borrower.calculateInterestAccrued(_id);\n        log_named_uint('First Interest Repaid', _totalInterestRepaid);\n        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;\n        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');\n    }\n\n    function test_helperFunctionsInLiquidatedState() public {\n        assert_helper_functionalities_in_liquidated_state(requestId);\n    }\n}\n", 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-27-08 09:27:51 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 requestId; address lender_0;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);     lender_0 = lenders[0].lenderAddress;      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 10);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, currentDebt / 200);      // Now we travel past the expiration date     vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      // Now the PCL should be in the LIQUIDATED state     PCLUser(lender_0).liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test0: Test SetUp function test_SetUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated'); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // START function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  // Test1: Liquidated PCL cannot be started function assert_start_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertString,     string memory _errorString ) public {     try _user.start(_id) {         revert(_revertString);     } catch Error(string memory reason) {         assertEq(reason, _errorString);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1'); }  function test_borrowerCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1'); }  function test_lenderCannotStartALiquidatedPCL() public {     assert_start_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in liquidated state',         'LP:S1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CANCEL function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_cancel_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1'); }  function test_lenderCannotCancelALiquidatedPCL() public {     assert_cancel_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot Cancel a PCL in liquidated state',         'PCL:OCLB1'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // CLOSE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_close_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1'); }  function test_lenderCannotCloseALiquidatedPCL() public {     assert_close_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a liquidated PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     if (_depositor != borrower) {         _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);     }      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the Liquidated state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  function test_borrowerCannotBorrowALiquidatedPCL() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB3'     ); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot borrow a PCL in Liquidated state',         'PCL:IB1'     ); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot borrow a PCL in Liquidated state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInLiquidatedState(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     admin.transferToken(address(borrowAsset), address(_user), 100);     if (_user != borrower) {         _user.setAllowance(address(pcl), address(borrowAsset), 100);     }      try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_borrowerCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  function test_lenderCannotRepayALiquidatedPCL() public {     assertRepayFunctionalityInLiquidatedState(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot repay a Liquidated PCL',         'PCL:REP2'     ); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInLiquidatedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw collateral in Liquidated state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         0,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw zero collateral in Liquidated state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInLiquidatedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw collateral in Liquidated state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_Liquidated_state(     uint256 _id,     PCLUser _user,     uint256 _stateToAssert,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.withdrawLiquidity(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert); }  function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         admin,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Admin cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         borrower,         uint256(PooledCreditLineStatus.LIQUIDATED),         'Borrower cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL1'     ); }  function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {     assert_withdraw_liquidity_functionality_in_Liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         uint256(PooledCreditLineStatus.LIQUIDATED),         'Lender cannot withdraw liquidity a PCL in Liquidated state',         'LP:IWL2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // LIQUIDATE function calls //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_liquidate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED); }  function test_adminCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateALiquidatedPCL() public {     assert_liquidate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Liquidated PCL cannot be liquidated',         'PCL:L2'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Terminate function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_terminate_functionality_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));      try _user.terminate(_id) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          if (_user == admin) {             assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);             assertTrue((_userBorrowTokenBalancePreTerminate &lt; _userBorrowTokenBalancePostTerminate) == true);             if (request.collateralRatio != 0) {                 assertTrue((_userCollateralTokenBalancePreTerminate &lt; _userCollateralTokenBalancePostTerminate) == true);             }         } else {             assertTrue(                 (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                     (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                     true             );             revert(_revertMessage);         }     } catch Error(string memory reason) {         uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));         uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));          assertTrue(             (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==                 (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==                 true         );          assertEq(reason, _errorMessage);         assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } }  function test_adminCanTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         borrower,         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateALiquidatedPCL() public {     assert_terminate_functionality_in_liquidated_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Cannot terminate a PCL that is liquidated',         'Ownable: caller is not the owner'     ); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Pool Token Transfer function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 lender0PoolTokenBalance; uint256 lender1PoolTokenBalance; uint256 lender2PoolTokenBalance; uint256 lender3PoolTokenBalance; uint256 _from1BalancePostBurn; uint256 lender0PoolTokenBalanceFinal; uint256 lender1PoolTokenBalanceFinal; uint256 lender2PoolTokenBalanceFinal; uint256 lender3PoolTokenBalanceFinal; uint256 _defaultTimeStamp;  PCLUser _from1; PCLUser _from2; PCLUser _to1; PCLUser _to2;  function assert_pool_token_transfer_in_liquidated_stage(     uint256 _id,     uint256 _fractionOfPTSupply,     bool _positiveCase,     address _From1,     address _From2,     address _To1,     address _To2,     string memory _errorString ) public {     _from1 = PCLUser(_From1);     _from2 = PCLUser(_From2);     _to1 = PCLUser(_To1);     _to2 = PCLUser(_To2);      if (_positiveCase) {         // Ensuring that these lenders indeed had lent something         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);         lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);          assertGt(lender0PoolTokenBalance, 0);         assertGt(lender1PoolTokenBalance, 0);         assertGt(lender2PoolTokenBalance, 0);         assertGt(lender3PoolTokenBalance, 0);          // Lender0 transfers pool tokens to lender1         _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));          //Checking the transfer took place or not         lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);         lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);          assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));         assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));          vm.warp(block.timestamp + request.defaultGracePeriod);          // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);          // assertTrue(block.timestamp &gt;= _defaultTimeStamp, '!Still not past default time');          // Lender2 transfers pool tokens to lender3         _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);          lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);         lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);          // Checking whether the transfer took place or not         assertTrue(lender2PoolTokenBalanceFinal == 0);         assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));          assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     } else {         lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);         try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {             if (_To1 == address(0)) {                 _from1BalancePostBurn = lp.balanceOf(_From1, _id);                 assertEq(_from1BalancePostBurn, 0);             } else {                 revert('REVERT');             }         } catch Error(string memory reason) {             assertEq(reason, _errorString);         }     } }  function test_poolTokenTransferComplete_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartial_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         2,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_poolTokenTransferPartialByFour_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         4,         true,         lenders[0].lenderAddress,         lenders[1].lenderAddress,         lenders[2].lenderAddress,         lenders[3].lenderAddress,         ''     ); }  function test_cannotBurnPoolToken_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(0),         address(0),         'ERC1155: transfer to the zero address'     ); }  function test_cannotTransferPoolTokensToSelf_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[0].lenderAddress,         address(0),         'LP:IT1'     ); }  function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         protocolFeeCollectorAddress,         address(0),         'LP:IT3'     ); }  function test_cannotTransferLPTokensToBorrower() public {     assert_pool_token_transfer_in_liquidated_stage(         requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         address(borrower),         address(0),         'LP:IT2'     ); }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_requestId, _requiredCollateral, false);     }      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 10);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.repay(_requestId, currentDebt / 200);      vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);      assert_pool_token_transfer_in_liquidated_stage(         _requestId,         1,         false,         lenders[0].lenderAddress,         address(0),         lenders[1].lenderAddress,         address(0),         'LP:IT5'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Interest function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_interest_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1'); }  function test_lendersCanWithdrawInterest_liquidatedState() public {     assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // Withdraw Liquidation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  function assert_withdraw_liquidation_in_liquidated_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user == PCLUser(lenders[1].lenderAddress)) {         uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));         _user.withdrawTokensAfterLiquidation(_id);         uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));         uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));         assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);         if (request.collateralRatio != 0) {             assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);         }     } else {         try _user.withdrawTokensAfterLiquidation(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } }  function test_adminCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         admin,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(         requestId,         borrower,         'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',         'LP:WLC1'     ); }  function test_lenderCanWithdrawLiquidation_liquidatedState() public {     assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', ''); }  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // View/calculation function tests //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  uint256 _currentCR; uint256 _totalInterestPending; uint256 _totalInterestRepaid; uint256 _principal; uint256 _currentDebt; uint256 collateralHeld;  function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 0. collateralTokensToLiquidate     _currentDebt = _borrower.calculateCurrentDebt(_id);     uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);      log_named_uint('CD', _currentDebt);     log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);      if (request.collateralRatio != 0) {         (, , , , collateralHeld) = lp.pooledCLVariables(_id);          log_named_uint('Collateral Held', collateralHeld);          if (request.collateralAssetStrategy == compoundYieldAddress) {             assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)         } else {             // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');         }     } else {         log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral         assertGt(_equivalentCollateralTokens, 0);     }      // The currentCr is coming to be more than idealCR. Discuss.      // 0. calculateCurrentCollateralRatio     _currentCR = _borrower.calculateCurrentCollateralRatio(_id);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);     if (request.collateralRatio != 0) {         // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away     } else {         assertTrue(true);     }      // 1. calculatePrincipalWithdrawable     try _lender.withdrawLiquidity(_id) {         revert('Cannot be called without withdrawnLiquidation');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL2');     }      // 2. withdrawableCollateral     (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation     uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);     uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(         _remainingCollateralInShares,         address(collateralAsset)     );     uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);      assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment     // doesn't matter whether the PCL has been liquidated or not      // 6. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);     _totalInterestPending = _borrower.calculateInterestAccrued(_id);     log_named_uint('First Interest Repaid', _totalInterestRepaid);     uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;     assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt'); }  function test_helperFunctionsInLiquidatedState() public {     assert_helper_functionalities_in_liquidated_state(requestId); }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:27:51 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

