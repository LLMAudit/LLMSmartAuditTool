[2024-27-08 09:27:52 INFO] **[Preprocessing]**

**ChatDev Starts** (20240827092752)

**Timestamp**: 20240827092752

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}


**project_name**: RealWorld_BA_101_PCLClosedStage.t

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_101_PCLClosedStage.t_RealWord_20240827092752.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-27-08 09:27:53 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      // The below function will create the PCL request and then lenders lend the entire requested amount     (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      borrowAndRepay(requestId);      // Now the PCL should be in the CLOSED state     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function borrowAndRepay(uint256 _id) public {     // Now we assert that we are in the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_id, _requiredCollateral, false);     }      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);     // And borrows the borrowable amount     borrower.borrow(_id, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(_id);     // Borrower decides to repay the entire debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);     borrower.repay(_id, currentDebt); }  /************************************************************************************************************************************* Start function calls *************************************************************************************************************************************/  function assert_start_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.start(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1'); }  function test_borrowerCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1'); }  function test_lenderCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in closed state',         'LP:S1'     ); }  /************************************************************************************************************************************* Cancel function calls *************************************************************************************************************************************/  function assert_cancel_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1'); }  function test_lenderCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot cancel a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Close function calls *************************************************************************************************************************************/  function assert_close_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1'); }  function test_lenderCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a closed PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the CLOSED state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAClosedPCL() public {     assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInClosedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2'); }  function test_borrowerCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2'); }  function test_lenderCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2'); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public virtual {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCanWithdrawCollateral() public {     // The below function will create the PCL request and then lenders lend the entire requested amount     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     borrowAndRepay(_id);     vm.warp(block.timestamp + request.duration.mul(110).div(100));     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     if (request.collateralRatio != 0) {         assertGt(_withdrawableCollateral, 0);         borrower.withdrawAllCollateral(_id, false);     }     uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));     assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         admin,         false,         'Admin cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         borrower,         false,         'Borrower cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot liquidate a closed PCL',         'PCL:L1'     ); }  /************************************************************************************************************************************* WithdrawInterest function calls **************************************************************************************************************************************/  function assert_withdraw_interest_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1'); }  function test_lenderCanWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user != admin) {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.terminate(_id);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     } }  function test_adminCanTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         borrower,         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _toInterestOwed; uint256 _fromInterestOwed; uint256 _fromBorrowTokenBalanceInitial; uint256 _toBorrowTokenBalanceInitial;  /************************************************************************************************************************************** Pool MockToken Transfer function tests **************************************************************************************************************************************/  function assert_pool_token_transfer_in_closed_stage(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));         _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));          _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));         _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));          _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));          assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);         assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  function test_poolTokenTransferComplete() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         1,         '',         ''     ); }  function test_poolTokenTransferPartial() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         4,         '',         ''     ); }  function test_poolTokenTransferToNonVerifiedUser() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         admin,         false,         4,         'Non-verified user should not be able to receive pool tokens',         'LP:IT3'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      uint256 _startBalance = borrowAsset.balanceOf(address(_lender));     _lender.withdrawInterest(requestId);     uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));     assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);      vm.warp(block.timestamp + request.duration);     borrower.close(_requestId);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  /************************************************************************************************************************************** View/calculation function tests **************************************************************************************************************************************/  function assert_helper_functionalities_in_closed_state(     uint256 _id,     PCLUser _lender,     PCLUser _borrower ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertGe(_principalWithdrawable, _userLiquidity);     _lender.withdrawLiquidity(_id);     uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));     assertGe(newBalance, _userLiquidity);      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());     assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0); // Since PCL is closed now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment      // 6. calculateCurrentDebt     uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off      // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1     // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws      // 7. calculateCurrentCollateralRatio     try _borrower.calculateCurrentCollateralRatio(_id) {         uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     }      // 8. collateralTokensToLiquidate     try _borrower.collateralTokensToLiquidate(_id, 0) {         uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);         assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     } }  function test_helperFunctionInClosedState() public {     assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower); }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../Helpers/PCLParent.t.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\n\ncontract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n\n    uint256 requestId;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        request.borrowLimit = uint128(1_000_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * 1e18) / 1e2);\n        request.collateralRatio = 1e18;\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * 1e18) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        // The below function will create the PCL request and then lenders lend the entire requested amount\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        borrowAndRepay(requestId);\n\n        // Now the PCL should be in the CLOSED state\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function borrowAndRepay(uint256 _id) public {\n        // Now we assert that we are in the ACTIVE state\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_id, _requiredCollateral, false);\n        }\n\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);\n        // And borrows the borrowable amount\n        borrower.borrow(_id, borrowableAmount);\n\n        // Borrower decides to repay everything at mid-duration\n\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(_id);\n        // Borrower decides to repay the entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);\n        borrower.repay(_id, currentDebt);\n    }\n\n    /*******************\n    Start function calls\n    *******************/\n\n    function assert_start_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.start(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');\n    }\n\n    function test_borrowerCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');\n    }\n\n    function test_lenderCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot start a PCL in closed state',\n            'LP:S1'\n        );\n    }\n\n    /*******************\n    Cancel function calls\n    *******************/\n\n    function assert_cancel_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');\n    }\n\n    function test_lenderCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot cancel a PCL in closed state',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Close function calls\n    *******************/\n\n    function assert_close_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');\n    }\n\n    function test_lenderCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot close a closed PCL',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Deposit collateral function calls\n    *******************/\n\n    function assert_collateralCannotBeDepositedInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n\n        try _depositor.depositCollateral(_id, _amount, false) {\n            revert('Collateral cannot be deposited in the CLOSED state');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:DC2');\n        }\n    }\n\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);\n    }\n\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);\n    }\n\n    /*******************\n    Borrow function tests\n    *******************/\n\n    function assertBorrowFunctionalityInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotBorrowAClosedPCL() public {\n        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');\n    }\n\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');\n    }\n\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInClosedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot borrow a PCL in closed state',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Repay function tests\n    *******************/\n\n    function assertRepayFunctionalityInClosedState(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');\n    }\n\n    function test_borrowerCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');\n    }\n\n    function test_lenderCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');\n    }\n\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n\n    function assertWithdrawCollateralFunctionalityInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public virtual {\n        if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawAllCollateral(_id, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertGe(_balanceAfter, _balanceBefore);\n        } else {\n            try _user.withdrawAllCollateral(_id, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessageAll);\n            }\n        }\n\n        if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawCollateral(_id, _amount, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);\n        } else {\n            try _user.withdrawCollateral(_id, _amount, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            admin,\n            'Admin cannot withdraw collateral in closed state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            borrower,\n            'Borrower cannot withdraw collateral in closed state',\n            'PCL:WC1',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            0,\n            borrower,\n            'Borrower cannot withdraw collateral in closed state',\n            'PCL:WC2',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot withdraw collateral in closed state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCanWithdrawCollateral() public {\n        // The below function will create the PCL request and then lenders lend the entire requested amount\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        borrowAndRepay(_id);\n        vm.warp(block.timestamp + request.duration.mul(110).div(100));\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n\n        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);\n        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);\n        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));\n        if (request.collateralRatio != 0) {\n            assertGt(_withdrawableCollateral, 0);\n            borrower.withdrawAllCollateral(_id, false);\n        }\n        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));\n        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);\n    }\n\n    /*******************\n    WithdrawLiquidity function calls\n    *******************/\n\n    function assert_withdraw_liquidity_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));\n            _user.withdrawLiquidity(_id);\n            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));\n\n            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);\n            assertEq(_poolTokenBalanceNew, 0);\n        } else {\n            try _user.withdrawLiquidity(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(\n            requestId,\n            admin,\n            false,\n            'Admin cannot WithdrawLiquidity a PCL in closed state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(\n            requestId,\n            borrower,\n            false,\n            'Borrower cannot WithdrawLiquidity a PCL in closed state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');\n    }\n\n    /*******************\n    Liquidate function tests\n    *******************/\n\n    function assert_liquidate_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');\n    }\n\n    function test_borrowerCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');\n    }\n\n    function test_lenderCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot liquidate a closed PCL',\n            'PCL:L1'\n        );\n    }\n\n    /********************\n    WithdrawInterest function calls\n    ********************/\n\n    function assert_withdraw_interest_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);\n            }\n\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');\n    }\n\n    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');\n    }\n\n    function test_lenderCanWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');\n    }\n\n    /********************\n    Terminate function tests\n    ********************/\n\n    function assert_terminate_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_user != admin) {\n            try _user.terminate(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _user.terminate(_id);\n            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        }\n    }\n\n    function test_adminCanTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');\n    }\n\n    function test_borrowerCannotTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(\n            requestId,\n            borrower,\n            'Should not be able to terminate a closed PCL',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    function test_lenderCannotTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Should not be able to terminate a closed PCL',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    uint256 _fromUserPoolTokenSupplyOld;\n    uint256 _toUserPoolTokenSupplyOld;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _toInterestOwed;\n    uint256 _fromInterestOwed;\n    uint256 _fromBorrowTokenBalanceInitial;\n    uint256 _toBorrowTokenBalanceInitial;\n\n    /********************\n    Pool MockToken Transfer function tests\n    ********************/\n\n    function assert_pool_token_transfer_in_closed_stage(\n        uint256 _id,\n        PCLUser _fromUser,\n        PCLUser _toUser,\n        bool _positiveCase,\n        uint256 _fractionOfPTSupply,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n\n        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);\n        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);\n\n        if (_positiveCase) {\n            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));\n            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));\n\n            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));\n            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));\n\n            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));\n\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n\n            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));\n            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));\n\n            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);\n            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);\n        } else {\n            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n\n            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);\n            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);\n        }\n    }\n\n    function test_poolTokenTransferComplete() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            PCLUser(lenders[1].lenderAddress),\n            true,\n            1,\n            '',\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartial() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            PCLUser(lenders[1].lenderAddress),\n            true,\n            4,\n            '',\n            ''\n        );\n    }\n\n    function test_poolTokenTransferToNonVerifiedUser() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            admin,\n            false,\n            4,\n            'Non-verified user should not be able to receive pool tokens',\n            'LP:IT3'\n        );\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert('External user cannot create');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert('External user cannot terminate');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert('Lender cannot lend zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L1');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Unverified lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L2');\n        }\n    }\n\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    function test_lenderCannotWithdrawZeroInterest() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertGt(_lenderInterestOwed, 0);\n\n        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));\n        _lender.withdrawInterest(requestId);\n        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));\n        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);\n        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertEq(_lenderInterestOwed, 0);\n\n        try _lender.withdrawInterest(requestId) {\n            revert('Lender cannot withdraw zero interest');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:WI1');\n        }\n    }\n\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert('Non lender cannot withdraw liquidated collateral tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:WLC1');\n        }\n    }\n\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert('Lender cannot withdraw liquidated collateral tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    function test_cannotTransferLPTokensToSameAddress() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert('Lender cannot transfer LP tokens to itself');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT1');\n        }\n    }\n\n    function test_cannotTransferLPTokensToBorrower() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {\n            revert('Lender cannot transfer LP tokens to borrower');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT2');\n        }\n    }\n\n    function test_cannotBurnPoolTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert('Lender cannot burn LP tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'ERC1155: transfer to the zero address');\n        }\n    }\n\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n\n        vm.warp(block.timestamp + request.duration);\n        borrower.close(_requestId);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);\n\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n\n        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {\n            revert('Lender cannot transfer non transferable LP tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT5');\n        }\n    }\n\n    /********************\n    View/calculation function tests\n    ********************/\n\n    function assert_helper_functionalities_in_closed_state(\n        uint256 _id,\n        PCLUser _lender,\n        PCLUser _borrower\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n\n        // 1. calculatePrincipalWithdrawable\n        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);\n        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertGe(_principalWithdrawable, _userLiquidity);\n        _lender.withdrawLiquidity(_id);\n        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));\n        assertGe(newBalance, _userLiquidity);\n\n        // 2. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        uint256 _oneUnitOfCollateral = 10(ERC20(address(collateralAsset)).decimals());\n        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);\n\n        // 3.calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);\n\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0); // Since PCL is closed now\n\n        // 5. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment\n\n        // 6. calculateCurrentDebt\n        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off\n\n        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1\n        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws\n\n        // 7. calculateCurrentCollateralRatio\n        try _borrower.calculateCurrentCollateralRatio(_id) {\n            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:IGUPT1');\n        }\n\n        // 8. collateralTokensToLiquidate\n        try _borrower.collateralTokensToLiquidate(_id, 0) {\n            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);\n            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:IGUPT1');\n        }\n    }\n\n    function test_helperFunctionInClosedState() public {\n        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);\n    }\n}\n"} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:27:53 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      // The below function will create the PCL request and then lenders lend the entire requested amount     (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      borrowAndRepay(requestId);      // Now the PCL should be in the CLOSED state     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function borrowAndRepay(uint256 _id) public {     // Now we assert that we are in the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_id, _requiredCollateral, false);     }      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);     // And borrows the borrowable amount     borrower.borrow(_id, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(_id);     // Borrower decides to repay the entire debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);     borrower.repay(_id, currentDebt); }  /************************************************************************************************************************************* Start function calls *************************************************************************************************************************************/  function assert_start_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.start(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1'); }  function test_borrowerCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1'); }  function test_lenderCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in closed state',         'LP:S1'     ); }  /************************************************************************************************************************************* Cancel function calls *************************************************************************************************************************************/  function assert_cancel_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1'); }  function test_lenderCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot cancel a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Close function calls *************************************************************************************************************************************/  function assert_close_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1'); }  function test_lenderCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a closed PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the CLOSED state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAClosedPCL() public {     assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInClosedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2'); }  function test_borrowerCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2'); }  function test_lenderCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2'); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public virtual {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCanWithdrawCollateral() public {     // The below function will create the PCL request and then lenders lend the entire requested amount     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     borrowAndRepay(_id);     vm.warp(block.timestamp + request.duration.mul(110).div(100));     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     if (request.collateralRatio != 0) {         assertGt(_withdrawableCollateral, 0);         borrower.withdrawAllCollateral(_id, false);     }     uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));     assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         admin,         false,         'Admin cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         borrower,         false,         'Borrower cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot liquidate a closed PCL',         'PCL:L1'     ); }  /************************************************************************************************************************************* WithdrawInterest function calls **************************************************************************************************************************************/  function assert_withdraw_interest_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1'); }  function test_lenderCanWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user != admin) {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.terminate(_id);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     } }  function test_adminCanTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         borrower,         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _toInterestOwed; uint256 _fromInterestOwed; uint256 _fromBorrowTokenBalanceInitial; uint256 _toBorrowTokenBalanceInitial;  /************************************************************************************************************************************** Pool MockToken Transfer function tests **************************************************************************************************************************************/  function assert_pool_token_transfer_in_closed_stage(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));         _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));          _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));         _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));          _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));          assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);         assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  function test_poolTokenTransferComplete() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         1,         '',         ''     ); }  function test_poolTokenTransferPartial() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         4,         '',         ''     ); }  function test_poolTokenTransferToNonVerifiedUser() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         admin,         false,         4,         'Non-verified user should not be able to receive pool tokens',         'LP:IT3'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      uint256 _startBalance = borrowAsset.balanceOf(address(_lender));     _lender.withdrawInterest(requestId);     uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));     assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);      vm.warp(block.timestamp + request.duration);     borrower.close(_requestId);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  /************************************************************************************************************************************** View/calculation function tests **************************************************************************************************************************************/  function assert_helper_functionalities_in_closed_state(     uint256 _id,     PCLUser _lender,     PCLUser _borrower ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertGe(_principalWithdrawable, _userLiquidity);     _lender.withdrawLiquidity(_id);     uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));     assertGe(newBalance, _userLiquidity);      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());     assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0); // Since PCL is closed now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment      // 6. calculateCurrentDebt     uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off      // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1     // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws      // 7. calculateCurrentCollateralRatio     try _borrower.calculateCurrentCollateralRatio(_id) {         uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     }      // 8. collateralTokensToLiquidate     try _borrower.collateralTokensToLiquidate(_id, 0) {         uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);         assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     } }  function test_helperFunctionInClosedState() public {     assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:27:53 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-27-08 09:27:56 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:27:56 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16430
completion_tokens: 1
total_tokens: 16431
cost: $-1.000000


[2024-27-08 09:27:56 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
.]

Let's

[2024-27-08 09:27:56 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      // The below function will create the PCL request and then lenders lend the entire requested amount     (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      borrowAndRepay(requestId);      // Now the PCL should be in the CLOSED state     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function borrowAndRepay(uint256 _id) public {     // Now we assert that we are in the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_id, _requiredCollateral, false);     }      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);     // And borrows the borrowable amount     borrower.borrow(_id, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(_id);     // Borrower decides to repay the entire debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);     borrower.repay(_id, currentDebt); }  /************************************************************************************************************************************* Start function calls *************************************************************************************************************************************/  function assert_start_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.start(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1'); }  function test_borrowerCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1'); }  function test_lenderCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in closed state',         'LP:S1'     ); }  /************************************************************************************************************************************* Cancel function calls *************************************************************************************************************************************/  function assert_cancel_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1'); }  function test_lenderCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot cancel a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Close function calls *************************************************************************************************************************************/  function assert_close_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1'); }  function test_lenderCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a closed PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the CLOSED state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAClosedPCL() public {     assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInClosedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2'); }  function test_borrowerCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2'); }  function test_lenderCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2'); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public virtual {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCanWithdrawCollateral() public {     // The below function will create the PCL request and then lenders lend the entire requested amount     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     borrowAndRepay(_id);     vm.warp(block.timestamp + request.duration.mul(110).div(100));     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     if (request.collateralRatio != 0) {         assertGt(_withdrawableCollateral, 0);         borrower.withdrawAllCollateral(_id, false);     }     uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));     assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         admin,         false,         'Admin cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         borrower,         false,         'Borrower cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot liquidate a closed PCL',         'PCL:L1'     ); }  /************************************************************************************************************************************* WithdrawInterest function calls **************************************************************************************************************************************/  function assert_withdraw_interest_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1'); }  function test_lenderCanWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user != admin) {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.terminate(_id);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     } }  function test_adminCanTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         borrower,         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _toInterestOwed; uint256 _fromInterestOwed; uint256 _fromBorrowTokenBalanceInitial; uint256 _toBorrowTokenBalanceInitial;  /************************************************************************************************************************************** Pool MockToken Transfer function tests **************************************************************************************************************************************/  function assert_pool_token_transfer_in_closed_stage(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));         _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));          _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));         _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));          _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));          assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);         assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  function test_poolTokenTransferComplete() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         1,         '',         ''     ); }  function test_poolTokenTransferPartial() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         4,         '',         ''     ); }  function test_poolTokenTransferToNonVerifiedUser() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         admin,         false,         4,         'Non-verified user should not be able to receive pool tokens',         'LP:IT3'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      uint256 _startBalance = borrowAsset.balanceOf(address(_lender));     _lender.withdrawInterest(requestId);     uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));     assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);      vm.warp(block.timestamp + request.duration);     borrower.close(_requestId);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  /************************************************************************************************************************************** View/calculation function tests **************************************************************************************************************************************/  function assert_helper_functionalities_in_closed_state(     uint256 _id,     PCLUser _lender,     PCLUser _borrower ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertGe(_principalWithdrawable, _userLiquidity);     _lender.withdrawLiquidity(_id);     uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));     assertGe(newBalance, _userLiquidity);      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());     assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0); // Since PCL is closed now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment      // 6. calculateCurrentDebt     uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off      // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1     // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws      // 7. calculateCurrentCollateralRatio     try _borrower.calculateCurrentCollateralRatio(_id) {         uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     }      // 8. collateralTokensToLiquidate     try _borrower.collateralTokensToLiquidate(_id, 0) {         uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);         assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     } }  function test_helperFunctionInClosedState() public {     assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower); }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\nimport \'../../../interfaces/IPooledCreditLineDeclarations.sol\';\ncontract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    uint256 requestId;\n    function setUp() public virtual override {\n        super.setUp();\n        request.borrowLimit = uint128(1_000_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * 1e18) / 1e2);\n        request.collateralRatio = 1e18;\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * 1e18) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n        // The below function will create the PCL request and then lenders lend the entire requested amount\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        borrowAndRepay(requestId);\n        // Now the PCL should be in the CLOSED state\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n    function borrowAndRepay(uint256 _id) public {\n        // Now we assert that we are in the ACTIVE state\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_id, _requiredCollateral, false);\n        }\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);\n        // And borrows the borrowable amount\n        borrower.borrow(_id, borrowableAmount);\n        // Borrower decides to repay everything at mid-duration\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(_id);\n        // Borrower decides to repay the entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);\n        borrower.repay(_id, currentDebt);\n    }\n    /*******************\n    Start function calls\n    *******************/\n    function assert_start_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.start(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n    function test_adminCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(requestId, admin, \'Admin cannot start a PCL in closed state\', \'LP:S1\');\n    }\n    function test_borrowerCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(requestId, borrower, \'Borrower cannot start a PCL in closed state\', \'LP:S1\');\n    }\n    function test_lenderCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot start a PCL in closed state\',\n            \'LP:S1\'\n        );\n    }\n    /*******************\n    Cancel function calls\n    *******************/\n    function assert_cancel_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n    function test_adminCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(requestId, admin, \'Admin cannot cancel a PCL in closed state\', \'PCL:OCLB1\');\n    }\n    function test_borrowerCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(requestId, borrower, \'Borrower cannot cancel a PCL in closed state\', \'PCL:CR1\');\n    }\n    function test_lenderCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot cancel a PCL in closed state\',\n            \'PCL:OCLB1\'\n        );\n    }\n    /*******************\n    Close function calls\n    *******************/\n    function assert_close_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n    function test_adminCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(requestId, admin, \'Admin cannot close a closed PCL\', \'PCL:OCLB1\');\n    }\n    function test_borrowerCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(requestId, borrower, \'Borrower cannot close a closed PCL\', \'PCL:C1\');\n    }\n    function test_lenderCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot close a closed PCL\',\n            \'PCL:OCLB1\'\n        );\n    }\n    /*******************\n    Deposit collateral function calls\n    *******************/\n    function assert_collateralCannotBeDepositedInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n        try _depositor.depositCollateral(_id, _amount, false) {\n            revert(\'Collateral cannot be deposited in the CLOSED state\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:DC2\');\n        }\n    }\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);\n    }\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);\n    }\n    /*******************\n    Borrow function tests\n    *******************/\n    function assertBorrowFunctionalityInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInClosedState(requestId, 1, admin, \'Admin cannot borrow a PCL in closed state\', \'PCL:OCLB1\');\n    }\n    function test_borrowerCannotBorrowAClosedPCL() public {\n        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, \'Borrower cannot borrow a PCL in closed state\', \'PCL:IB3\');\n    }\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, \'Borrower cannot borrow a PCL in closed state\', \'PCL:IB1\');\n    }\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInClosedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot borrow a PCL in closed state\',\n            \'PCL:OCLB1\'\n        );\n    }\n    /*******************\n    Repay function tests\n    *******************/\n    function assertRepayFunctionalityInClosedState(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n    function test_adminCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, admin, \'Admin cannot repay a closed PCL\', \'PCL:REP2\');\n    }\n    function test_borrowerCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, borrower, \'Borrower cannot repay a closed PCL\', \'PCL:REP2\');\n    }\n    function test_lenderCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), \'Lender cannot repay a closed PCL\', \'PCL:REP2\');\n    }\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n    function assertWithdrawCollateralFunctionalityInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public virtual {\n        if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawAllCollateral(_id, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertGe(_balanceAfter, _balanceBefore);\n        } else {\n            try _user.withdrawAllCollateral(_id, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessageAll);\n            }\n        }\n        if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawCollateral(_id, _amount, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);\n        } else {\n            try _user.withdrawCollateral(_id, _amount, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            admin,\n            \'Admin cannot withdraw collateral in closed state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            borrower,\n            \'Borrower cannot withdraw collateral in closed state\',\n            \'PCL:WC1\',\n            \'PCL:WAC1\'\n        );\n    }\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            0,\n            borrower,\n            \'Borrower cannot withdraw collateral in closed state\',\n            \'PCL:WC2\',\n            \'PCL:WAC1\'\n        );\n    }\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot withdraw collateral in closed state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n    function test_borrowerCanWithdrawCollateral() public {\n        // The below function will create the PCL request and then lenders lend the entire requested amount\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        borrowAndRepay(_id);\n        vm.warp(block.timestamp + request.duration.mul(110).div(100));\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);\n        emit log_named_uint(\'_withdrawableCollateral\', _withdrawableCollateral);\n        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));\n        if (request.collateralRatio != 0) {\n            assertGt(_withdrawableCollateral, 0);\n            borrower.withdrawAllCollateral(_id, false);\n        }\n        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));\n        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);\n    }\n    /*******************\n    WithdrawLiquidity function calls\n    *******************/\n    function assert_withdraw_liquidity_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));\n            _user.withdrawLiquidity(_id);\n            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));\n            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);\n            assertEq(_poolTokenBalanceNew, 0);\n        } else {\n            try _user.withdrawLiquidity(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(\n            requestId,\n            admin,\n            false,\n            \'Admin cannot WithdrawLiquidity a PCL in closed state\',\n            \'LP:IWL1\'\n        );\n    }\n    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(\n            requestId,\n            borrower,\n            false,\n            \'Borrower cannot WithdrawLiquidity a PCL in closed state\',\n            \'LP:IWL1\'\n        );\n    }\n    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, \'\', \'\');\n    }\n    /*******************\n    Liquidate function tests\n    *******************/\n    function assert_liquidate_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n    function test_adminCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(requestId, admin, \'Admin cannot liquidate a closed PCL\', \'LP:LIQ1\');\n    }\n    function test_borrowerCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(requestId, borrower, \'Borrower cannot liquidate a closed PCL\', \'LP:LIQ1\');\n    }\n    function test_lenderCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot liquidate a closed PCL\',\n            \'PCL:L1\'\n        );\n    }\n    /********************\n    WithdrawInterest function calls\n    ********************/\n    function assert_withdraw_interest_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);\n            }\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n    function test_adminCannotWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, \'LP:WI1\');\n    }\n    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, \'LP:WI1\');\n    }\n    function test_lenderCanWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), \'\');\n    }\n    /********************\n    Terminate function tests\n    ********************/\n    function assert_terminate_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_user != admin) {\n            try _user.terminate(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _user.terminate(_id);\n            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        }\n    }\n    function test_adminCanTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(requestId, admin, \'\', \'\');\n    }\n    function test_borrowerCannotTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(\n            requestId,\n            borrower,\n            \'Should not be able to terminate a closed PCL\',\n            \'Ownable: caller is not the owner\'\n        );\n    }\n    function test_lenderCannotTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Should not be able to terminate a closed PCL\',\n            \'Ownable: caller is not the owner\'\n        );\n    }\n    uint256 _fromUserPoolTokenSupplyOld;\n    uint256 _toUserPoolTokenSupplyOld;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _toInterestOwed;\n    uint256 _fromInterestOwed;\n    uint256 _fromBorrowTokenBalanceInitial;\n    uint256 _toBorrowTokenBalanceInitial;\n    /********************\n    Pool MockToken Transfer function tests\n    ********************/\n    function assert_pool_token_transfer_in_closed_stage(\n        uint256 _id,\n        PCLUser _fromUser,\n        PCLUser _toUser,\n        bool _positiveCase,\n        uint256 _fractionOfPTSupply,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);\n        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);\n        if (_positiveCase) {\n            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));\n            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));\n            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));\n            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));\n            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));\n            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));\n            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);\n            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);\n        } else {\n            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);\n            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);\n        }\n    }\n    function test_poolTokenTransferComplete() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            PCLUser(lenders[1].lenderAddress),\n            true,\n            1,\n            \'\',\n            \'\'\n        );\n    }\n    function test_poolTokenTransferPartial() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            PCLUser(lenders[1].lenderAddress),\n            true,\n            4,\n            \'\',\n            \'\'\n        );\n    }\n    function test_poolTokenTransferToNonVerifiedUser() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            admin,\n            false,\n            4,\n            \'Non-verified user should not be able to receive pool tokens\',\n            \'LP:IT3\'\n        );\n    }\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert(\'External user cannot create\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert(\'External user cannot terminate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert(\'Lender cannot lend zero amount\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L1\');\n        }\n    }\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Unverified lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L2\');\n        }\n    }\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L3\');\n        }\n    }\n    function test_lenderCannotWithdrawZeroInterest() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertGt(_lenderInterestOwed, 0);\n        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));\n        _lender.withdrawInterest(requestId);\n        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));\n        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);\n        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertEq(_lenderInterestOwed, 0);\n        try _lender.withdrawInterest(requestId) {\n            revert(\'Lender cannot withdraw zero interest\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WI1\');\n        }\n    }\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Non lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WLC1\');\n        }\n    }\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWLC1\');\n        }\n    }\n    function test_cannotTransferLPTokensToSameAddress() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert(\'Lender cannot transfer LP tokens to itself\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT1\');\n        }\n    }\n    function test_cannotTransferLPTokensToBorrower() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {\n            revert(\'Lender cannot transfer LP tokens to borrower\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT2\');\n        }\n    }\n    function test_cannotBurnPoolTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert(\'Lender cannot burn LP tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'ERC1155: transfer to the zero address\');\n        }\n    }\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        vm.warp(block.timestamp + request.duration);\n        borrower.close(_requestId);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {\n            revert(\'Lender cannot transfer non transferable LP tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT5\');\n        }\n    }\n    /********************\n    View/calculation function tests\n    ********************/\n    function assert_helper_functionalities_in_closed_state(\n        uint256 _id,\n        PCLUser _lender,\n        PCLUser _borrower\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n        // 1. calculatePrincipalWithdrawable\n        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);\n        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertGe(_principalWithdrawable, _userLiquidity);\n        _lender.withdrawLiquidity(_id);\n        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));\n        assertGe(newBalance, _userLiquidity);\n        // 2. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        uint256 _oneUnitOfCollateral = 10(ERC20(address(collateralAsset)).decimals());\n        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);\n        // 3.calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0); // Since PCL is closed now\n        // 5. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment\n        // 6. calculateCurrentDebt\n        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off\n        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1\n        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws\n        // 7. calculateCurrentCollateralRatio\n        try _borrower.calculateCurrentCollateralRatio(_id) {\n            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:IGUPT1\');\n        }\n        // 8. collateralTokensToLiquidate\n        try _borrower.collateralTokensToLiquidate(_id, 0) {\n            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);\n            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:IGUPT1\');\n        }\n    }\n    function test_helperFunctionInClosedState() public {\n        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\nimport \'../../../interfaces/IPooledCreditLineDeclarations.sol\';\ncontract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    uint256 requestId;\n    function setUp() public virtual override {\n        super.setUp();\n        request.borrowLimit = uint128(1_000_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * 1e18) / 1e2);\n        request.collateralRatio = 1e18;\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * 1e18) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n        // The below function will create the PCL request and then lenders lend the entire requested amount\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        borrowAndRepay(requestId);\n        // Now the PCL should be in the CLOSED state\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n    function borrowAndRepay(uint256 _id) public {\n        // Now we assert that we are in the ACTIVE state\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_id, _requiredCollateral, false);\n        }\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);\n        // And borrows the borrowable amount\n        borrower.borrow(_id, borrowableAmount);\n        // Borrower decides to repay everything at mid-duration\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(_id);\n        // Borrower decides to repay the entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);\n        borrower.repay(_id, currentDebt);\n    }\n    /*******************\n    Start function calls\n    *******************/\n    function assert_start_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.start(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n    function test_adminCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(requestId, admin, \'Admin cannot start a PCL in closed state\', \'LP:S1\');\n    }\n    function test_borrowerCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(requestId, borrower, \'Borrower cannot start a PCL in closed state\', \'LP:S1\');\n    }\n    function test_lenderCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot start a PCL in closed state\',\n            \'LP:S1\'\n        );\n    }\n    /*******************\n    Cancel function calls\n    *******************/\n    function assert_cancel_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n    function test_adminCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(requestId, admin, \'Admin cannot cancel a PCL in closed state\', \'PCL:OCLB1\');\n    }\n    function test_borrowerCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(requestId, borrower, \'Borrower cannot cancel a PCL in closed state\', \'PCL:CR1\');\n    }\n    function test_lenderCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot cancel a PCL in closed state\',\n            \'PCL:OCLB1\'\n        );\n    }\n    /*******************\n    Close function calls\n    *******************/\n    function assert_close_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n    function test_adminCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(requestId, admin, \'Admin cannot close a closed PCL\', \'PCL:OCLB1\');\n    }\n    function test_borrowerCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(requestId, borrower, \'Borrower cannot close a closed PCL\', \'PCL:C1\');\n    }\n    function test_lenderCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot close a closed PCL\',\n            \'PCL:OCLB1\'\n        );\n    }\n    /*******************\n    Deposit collateral function calls\n    *******************/\n    function assert_collateralCannotBeDepositedInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n        try _depositor.depositCollateral(_id, _amount, false) {\n            revert(\'Collateral cannot be deposited in the CLOSED state\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:DC2\');\n        }\n    }\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);\n    }\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);\n    }\n    /*******************\n    Borrow function tests\n    *******************/\n    function assertBorrowFunctionalityInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInClosedState(requestId, 1, admin, \'Admin cannot borrow a PCL in closed state\', \'PCL:OCLB1\');\n    }\n    function test_borrowerCannotBorrowAClosedPCL() public {\n        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, \'Borrower cannot borrow a PCL in closed state\', \'PCL:IB3\');\n    }\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, \'Borrower cannot borrow a PCL in closed state\', \'PCL:IB1\');\n    }\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInClosedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot borrow a PCL in closed state\',\n            \'PCL:OCLB1\'\n        );\n    }\n    /*******************\n    Repay function tests\n    *******************/\n    function assertRepayFunctionalityInClosedState(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n    function test_adminCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, admin, \'Admin cannot repay a closed PCL\', \'PCL:REP2\');\n    }\n    function test_borrowerCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, borrower, \'Borrower cannot repay a closed PCL\', \'PCL:REP2\');\n    }\n    function test_lenderCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), \'Lender cannot repay a closed PCL\', \'PCL:REP2\');\n    }\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n    function assertWithdrawCollateralFunctionalityInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public virtual {\n        if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawAllCollateral(_id, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertGe(_balanceAfter, _balanceBefore);\n        } else {\n            try _user.withdrawAllCollateral(_id, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessageAll);\n            }\n        }\n        if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawCollateral(_id, _amount, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);\n        } else {\n            try _user.withdrawCollateral(_id, _amount, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            admin,\n            \'Admin cannot withdraw collateral in closed state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            borrower,\n            \'Borrower cannot withdraw collateral in closed state\',\n            \'PCL:WC1\',\n            \'PCL:WAC1\'\n        );\n    }\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            0,\n            borrower,\n            \'Borrower cannot withdraw collateral in closed state\',\n            \'PCL:WC2\',\n            \'PCL:WAC1\'\n        );\n    }\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot withdraw collateral in closed state\',\n            \'PCL:OCLB1\',\n            \'PCL:OCLB1\'\n        );\n    }\n    function test_borrowerCanWithdrawCollateral() public {\n        // The below function will create the PCL request and then lenders lend the entire requested amount\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        borrowAndRepay(_id);\n        vm.warp(block.timestamp + request.duration.mul(110).div(100));\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);\n        emit log_named_uint(\'_withdrawableCollateral\', _withdrawableCollateral);\n        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));\n        if (request.collateralRatio != 0) {\n            assertGt(_withdrawableCollateral, 0);\n            borrower.withdrawAllCollateral(_id, false);\n        }\n        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));\n        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);\n    }\n    /*******************\n    WithdrawLiquidity function calls\n    *******************/\n    function assert_withdraw_liquidity_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));\n            _user.withdrawLiquidity(_id);\n            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));\n            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);\n            assertEq(_poolTokenBalanceNew, 0);\n        } else {\n            try _user.withdrawLiquidity(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(\n            requestId,\n            admin,\n            false,\n            \'Admin cannot WithdrawLiquidity a PCL in closed state\',\n            \'LP:IWL1\'\n        );\n    }\n    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(\n            requestId,\n            borrower,\n            false,\n            \'Borrower cannot WithdrawLiquidity a PCL in closed state\',\n            \'LP:IWL1\'\n        );\n    }\n    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, \'\', \'\');\n    }\n    /*******************\n    Liquidate function tests\n    *******************/\n    function assert_liquidate_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n    function test_adminCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(requestId, admin, \'Admin cannot liquidate a closed PCL\', \'LP:LIQ1\');\n    }\n    function test_borrowerCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(requestId, borrower, \'Borrower cannot liquidate a closed PCL\', \'LP:LIQ1\');\n    }\n    function test_lenderCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Lender cannot liquidate a closed PCL\',\n            \'PCL:L1\'\n        );\n    }\n    /********************\n    WithdrawInterest function calls\n    ********************/\n    function assert_withdraw_interest_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);\n            }\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n    function test_adminCannotWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, \'LP:WI1\');\n    }\n    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, \'LP:WI1\');\n    }\n    function test_lenderCanWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), \'\');\n    }\n    /********************\n    Terminate function tests\n    ********************/\n    function assert_terminate_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_user != admin) {\n            try _user.terminate(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _user.terminate(_id);\n            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        }\n    }\n    function test_adminCanTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(requestId, admin, \'\', \'\');\n    }\n    function test_borrowerCannotTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(\n            requestId,\n            borrower,\n            \'Should not be able to terminate a closed PCL\',\n            \'Ownable: caller is not the owner\'\n        );\n    }\n    function test_lenderCannotTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            \'Should not be able to terminate a closed PCL\',\n            \'Ownable: caller is not the owner\'\n        );\n    }\n    uint256 _fromUserPoolTokenSupplyOld;\n    uint256 _toUserPoolTokenSupplyOld;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _toInterestOwed;\n    uint256 _fromInterestOwed;\n    uint256 _fromBorrowTokenBalanceInitial;\n    uint256 _toBorrowTokenBalanceInitial;\n    /********************\n    Pool MockToken Transfer function tests\n    ********************/\n    function assert_pool_token_transfer_in_closed_stage(\n        uint256 _id,\n        PCLUser _fromUser,\n        PCLUser _toUser,\n        bool _positiveCase,\n        uint256 _fractionOfPTSupply,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);\n        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);\n        if (_positiveCase) {\n            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));\n            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));\n            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));\n            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));\n            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));\n            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));\n            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);\n            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);\n        } else {\n            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);\n            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);\n        }\n    }\n    function test_poolTokenTransferComplete() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            PCLUser(lenders[1].lenderAddress),\n            true,\n            1,\n            \'\',\n            \'\'\n        );\n    }\n    function test_poolTokenTransferPartial() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            PCLUser(lenders[1].lenderAddress),\n            true,\n            4,\n            \'\',\n            \'\'\n        );\n    }\n    function test_poolTokenTransferToNonVerifiedUser() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            admin,\n            false,\n            4,\n            \'Non-verified user should not be able to receive pool tokens\',\n            \'LP:IT3\'\n        );\n    }\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert(\'External user cannot create\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert(\'External user cannot terminate\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:OPCL1\');\n        }\n    }\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert(\'Lender cannot lend zero amount\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L1\');\n        }\n    }\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Unverified lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L2\');\n        }\n    }\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert(\'Lender cannot lend\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:L3\');\n        }\n    }\n    function test_lenderCannotWithdrawZeroInterest() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertGt(_lenderInterestOwed, 0);\n        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));\n        _lender.withdrawInterest(requestId);\n        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));\n        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);\n        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertEq(_lenderInterestOwed, 0);\n        try _lender.withdrawInterest(requestId) {\n            revert(\'Lender cannot withdraw zero interest\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WI1\');\n        }\n    }\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Non lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:WLC1\');\n        }\n    }\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Lender cannot withdraw liquidated collateral tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWLC1\');\n        }\n    }\n    function test_cannotTransferLPTokensToSameAddress() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert(\'Lender cannot transfer LP tokens to itself\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT1\');\n        }\n    }\n    function test_cannotTransferLPTokensToBorrower() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {\n            revert(\'Lender cannot transfer LP tokens to borrower\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT2\');\n        }\n    }\n    function test_cannotBurnPoolTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert(\'Lender cannot burn LP tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'ERC1155: transfer to the zero address\');\n        }\n    }\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        vm.warp(block.timestamp + request.duration);\n        borrower.close(_requestId);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {\n            revert(\'Lender cannot transfer non transferable LP tokens\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IT5\');\n        }\n    }\n    /********************\n    View/calculation function tests\n    ********************/\n    function assert_helper_functionalities_in_closed_state(\n        uint256 _id,\n        PCLUser _lender,\n        PCLUser _borrower\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n        // 1. calculatePrincipalWithdrawable\n        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);\n        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertGe(_principalWithdrawable, _userLiquidity);\n        _lender.withdrawLiquidity(_id);\n        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));\n        assertGe(newBalance, _userLiquidity);\n        // 2. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        uint256 _oneUnitOfCollateral = 10(ERC20(address(collateralAsset)).decimals());\n        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);\n        // 3.calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0); // Since PCL is closed now\n        // 5. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment\n        // 6. calculateCurrentDebt\n        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off\n        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1\n        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws\n        // 7. calculateCurrentCollateralRatio\n        try _borrower.calculateCurrentCollateralRatio(_id) {\n            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:IGUPT1\');\n        }\n        // 8. collateralTokensToLiquidate\n        try _borrower.collateralTokensToLiquidate(_id, 0) {\n            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);\n            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:IGUPT1\');\n        }\n    }\n    function test_helperFunctionInClosedState() public {\n        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:27:56 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      // The below function will create the PCL request and then lenders lend the entire requested amount     (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      borrowAndRepay(requestId);      // Now the PCL should be in the CLOSED state     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function borrowAndRepay(uint256 _id) public {     // Now we assert that we are in the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_id, _requiredCollateral, false);     }      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);     // And borrows the borrowable amount     borrower.borrow(_id, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(_id);     // Borrower decides to repay the entire debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);     borrower.repay(_id, currentDebt); }  /************************************************************************************************************************************* Start function calls *************************************************************************************************************************************/  function assert_start_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.start(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1'); }  function test_borrowerCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1'); }  function test_lenderCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in closed state',         'LP:S1'     ); }  /************************************************************************************************************************************* Cancel function calls *************************************************************************************************************************************/  function assert_cancel_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1'); }  function test_lenderCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot cancel a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Close function calls *************************************************************************************************************************************/  function assert_close_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1'); }  function test_lenderCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a closed PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the CLOSED state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAClosedPCL() public {     assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInClosedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2'); }  function test_borrowerCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2'); }  function test_lenderCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2'); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public virtual {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCanWithdrawCollateral() public {     // The below function will create the PCL request and then lenders lend the entire requested amount     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     borrowAndRepay(_id);     vm.warp(block.timestamp + request.duration.mul(110).div(100));     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     if (request.collateralRatio != 0) {         assertGt(_withdrawableCollateral, 0);         borrower.withdrawAllCollateral(_id, false);     }     uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));     assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         admin,         false,         'Admin cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         borrower,         false,         'Borrower cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot liquidate a closed PCL',         'PCL:L1'     ); }  /************************************************************************************************************************************* WithdrawInterest function calls **************************************************************************************************************************************/  function assert_withdraw_interest_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1'); }  function test_lenderCanWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user != admin) {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.terminate(_id);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     } }  function test_adminCanTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         borrower,         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _toInterestOwed; uint256 _fromInterestOwed; uint256 _fromBorrowTokenBalanceInitial; uint256 _toBorrowTokenBalanceInitial;  /************************************************************************************************************************************** Pool MockToken Transfer function tests **************************************************************************************************************************************/  function assert_pool_token_transfer_in_closed_stage(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));         _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));          _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));         _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));          _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));          assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);         assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  function test_poolTokenTransferComplete() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         1,         '',         ''     ); }  function test_poolTokenTransferPartial() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         4,         '',         ''     ); }  function test_poolTokenTransferToNonVerifiedUser() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         admin,         false,         4,         'Non-verified user should not be able to receive pool tokens',         'LP:IT3'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      uint256 _startBalance = borrowAsset.balanceOf(address(_lender));     _lender.withdrawInterest(requestId);     uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));     assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);      vm.warp(block.timestamp + request.duration);     borrower.close(_requestId);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  /************************************************************************************************************************************** View/calculation function tests **************************************************************************************************************************************/  function assert_helper_functionalities_in_closed_state(     uint256 _id,     PCLUser _lender,     PCLUser _borrower ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertGe(_principalWithdrawable, _userLiquidity);     _lender.withdrawLiquidity(_id);     uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));     assertGe(newBalance, _userLiquidity);      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());     assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0); // Since PCL is closed now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment      // 6. calculateCurrentDebt     uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off      // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1     // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws      // 7. calculateCurrentCollateralRatio     try _borrower.calculateCurrentCollateralRatio(_id) {         uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     }      // 8. collateralTokensToLiquidate     try _borrower.collateralTokensToLiquidate(_id, 0) {         uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);         assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     } }  function test_helperFunctionInClosedState() public {     assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:27:56 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    uint256 requestId;
    function setUp() public virtual override {
        super.setUp();
        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(requestId);
        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }
        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);
        // Borrower decides to repay everything at mid-duration
        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }
    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/
    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }
    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }
    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }
    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/
    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }
    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }
    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }
    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/
    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }
    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }
    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }
    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/
    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }
        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }
    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }
    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }
    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }
    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/
    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }
    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }
    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }
    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }
    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/
    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }
    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }
    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }
    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/
    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }
        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }
    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }
    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }
    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }
    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }
    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/
    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }
    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }
    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }
    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/
    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }
    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }
    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }
    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/
    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);
        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));
        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);
            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }
            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }
    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }
    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }
    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }
    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/
    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }
    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }
    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }
    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;
    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/
    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);
        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));
            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));
            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);
            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);
            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }
    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }
    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }
    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }
    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }
    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }
    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }
    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }
    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }
    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);
        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);
        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }
    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }
    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }
    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);
        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }
    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);
        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }
    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);
        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }
    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/
    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);
        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);
        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);
        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now
        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off
        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws
        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }
    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    uint256 requestId;
    function setUp() public virtual override {
        super.setUp();
        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(requestId);
        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }
        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);
        // Borrower decides to repay everything at mid-duration
        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }
    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/
    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }
    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }
    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }
    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/
    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }
    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }
    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }
    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/
    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }
    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }
    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }
    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/
    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }
        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }
    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }
    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }
    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }
    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/
    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }
    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }
    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }
    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }
    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/
    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }
    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }
    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }
    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/
    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }
        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }
    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }
    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }
    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }
    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }
    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/
    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }
    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }
    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }
    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/
    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }
    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }
    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }
    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/
    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);
        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));
        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);
            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }
            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }
    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }
    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }
    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }
    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/
    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }
    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }
    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }
    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;
    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/
    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);
        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));
            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));
            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);
            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);
            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }
    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }
    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }
    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }
    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }
    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }
    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }
    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }
    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);
        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }
    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);
        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);
        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }
    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }
    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }
    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);
        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }
    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);
        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }
    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);
        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }
    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/
    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);
        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);
        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);
        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now
        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off
        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws
        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }
    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-27-08 09:28:12 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:28:12 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 24674
completion_tokens: 1
total_tokens: 24675
cost: $-1.000000


[2024-27-08 09:28:12 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
.]

Security

[2024-27-08 09:28:12 INFO] **[Seminar Conclusion]**:

 Security

[2024-27-08 09:28:12 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-27-08 09:28:12 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-27-08 09:28:12 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      // The below function will create the PCL request and then lenders lend the entire requested amount     (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      borrowAndRepay(requestId);      // Now the PCL should be in the CLOSED state     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function borrowAndRepay(uint256 _id) public {     // Now we assert that we are in the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_id, _requiredCollateral, false);     }      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);     // And borrows the borrowable amount     borrower.borrow(_id, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(_id);     // Borrower decides to repay the entire debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);     borrower.repay(_id, currentDebt); }  /************************************************************************************************************************************* Start function calls *************************************************************************************************************************************/  function assert_start_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.start(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1'); }  function test_borrowerCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1'); }  function test_lenderCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in closed state',         'LP:S1'     ); }  /************************************************************************************************************************************* Cancel function calls *************************************************************************************************************************************/  function assert_cancel_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1'); }  function test_lenderCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot cancel a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Close function calls *************************************************************************************************************************************/  function assert_close_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1'); }  function test_lenderCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a closed PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the CLOSED state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAClosedPCL() public {     assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInClosedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2'); }  function test_borrowerCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2'); }  function test_lenderCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2'); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public virtual {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCanWithdrawCollateral() public {     // The below function will create the PCL request and then lenders lend the entire requested amount     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     borrowAndRepay(_id);     vm.warp(block.timestamp + request.duration.mul(110).div(100));     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     if (request.collateralRatio != 0) {         assertGt(_withdrawableCollateral, 0);         borrower.withdrawAllCollateral(_id, false);     }     uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));     assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         admin,         false,         'Admin cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         borrower,         false,         'Borrower cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot liquidate a closed PCL',         'PCL:L1'     ); }  /************************************************************************************************************************************* WithdrawInterest function calls **************************************************************************************************************************************/  function assert_withdraw_interest_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1'); }  function test_lenderCanWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user != admin) {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.terminate(_id);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     } }  function test_adminCanTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         borrower,         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _toInterestOwed; uint256 _fromInterestOwed; uint256 _fromBorrowTokenBalanceInitial; uint256 _toBorrowTokenBalanceInitial;  /************************************************************************************************************************************** Pool MockToken Transfer function tests **************************************************************************************************************************************/  function assert_pool_token_transfer_in_closed_stage(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));         _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));          _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));         _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));          _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));          assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);         assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  function test_poolTokenTransferComplete() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         1,         '',         ''     ); }  function test_poolTokenTransferPartial() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         4,         '',         ''     ); }  function test_poolTokenTransferToNonVerifiedUser() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         admin,         false,         4,         'Non-verified user should not be able to receive pool tokens',         'LP:IT3'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      uint256 _startBalance = borrowAsset.balanceOf(address(_lender));     _lender.withdrawInterest(requestId);     uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));     assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);      vm.warp(block.timestamp + request.duration);     borrower.close(_requestId);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  /************************************************************************************************************************************** View/calculation function tests **************************************************************************************************************************************/  function assert_helper_functionalities_in_closed_state(     uint256 _id,     PCLUser _lender,     PCLUser _borrower ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertGe(_principalWithdrawable, _userLiquidity);     _lender.withdrawLiquidity(_id);     uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));     assertGe(newBalance, _userLiquidity);      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());     assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0); // Since PCL is closed now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment      // 6. calculateCurrentDebt     uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off      // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1     // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws      // 7. calculateCurrentCollateralRatio     try _borrower.calculateCurrentCollateralRatio(_id) {         uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     }      // 8. collateralTokensToLiquidate     try _borrower.collateralTokensToLiquidate(_id, 0) {         uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);         assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     } }  function test_helperFunctionInClosedState() public {     assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../Helpers/PCLParent.t.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\n\ncontract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n\n    uint256 requestId;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        request.borrowLimit = uint128(1_000_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * 1e18) / 1e2);\n        request.collateralRatio = 1e18;\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * 1e18) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        // The below function will create the PCL request and then lenders lend the entire requested amount\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        borrowAndRepay(requestId);\n\n        // Now the PCL should be in the CLOSED state\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function borrowAndRepay(uint256 _id) public {\n        // Now we assert that we are in the ACTIVE state\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_id, _requiredCollateral, false);\n        }\n\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);\n        // And borrows the borrowable amount\n        borrower.borrow(_id, borrowableAmount);\n\n        // Borrower decides to repay everything at mid-duration\n\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(_id);\n        // Borrower decides to repay the entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);\n        borrower.repay(_id, currentDebt);\n    }\n\n    /*******************\n    Start function calls\n    *******************/\n\n    function assert_start_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.start(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');\n    }\n\n    function test_borrowerCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');\n    }\n\n    function test_lenderCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot start a PCL in closed state',\n            'LP:S1'\n        );\n    }\n\n    /*******************\n    Cancel function calls\n    *******************/\n\n    function assert_cancel_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');\n    }\n\n    function test_lenderCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot cancel a PCL in closed state',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Close function calls\n    *******************/\n\n    function assert_close_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');\n    }\n\n    function test_lenderCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot close a closed PCL',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Deposit collateral function calls\n    *******************/\n\n    function assert_collateralCannotBeDepositedInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n\n        try _depositor.depositCollateral(_id, _amount, false) {\n            revert('Collateral cannot be deposited in the CLOSED state');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:DC2');\n        }\n    }\n\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);\n    }\n\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);\n    }\n\n    /*******************\n    Borrow function tests\n    *******************/\n\n    function assertBorrowFunctionalityInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotBorrowAClosedPCL() public {\n        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');\n    }\n\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');\n    }\n\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInClosedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot borrow a PCL in closed state',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Repay function tests\n    *******************/\n\n    function assertRepayFunctionalityInClosedState(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');\n    }\n\n    function test_borrowerCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');\n    }\n\n    function test_lenderCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');\n    }\n\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n\n    function assertWithdrawCollateralFunctionalityInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public virtual {\n        if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawAllCollateral(_id, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertGe(_balanceAfter, _balanceBefore);\n        } else {\n            try _user.withdrawAllCollateral(_id, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessageAll);\n            }\n        }\n\n        if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawCollateral(_id, _amount, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);\n        } else {\n            try _user.withdrawCollateral(_id, _amount, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            admin,\n            'Admin cannot withdraw collateral in closed state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            borrower,\n            'Borrower cannot withdraw collateral in closed state',\n            'PCL:WC1',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            0,\n            borrower,\n            'Borrower cannot withdraw collateral in closed state',\n            'PCL:WC2',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot withdraw collateral in closed state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCanWithdrawCollateral() public {\n        // The below function will create the PCL request and then lenders lend the entire requested amount\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        borrowAndRepay(_id);\n        vm.warp(block.timestamp + request.duration.mul(110).div(100));\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n\n        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);\n        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);\n        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));\n        if (request.collateralRatio != 0) {\n            assertGt(_withdrawableCollateral, 0);\n            borrower.withdrawAllCollateral(_id, false);\n        }\n        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));\n        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);\n    }\n\n    /*******************\n    WithdrawLiquidity function calls\n    *******************/\n\n    function assert_withdraw_liquidity_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));\n            _user.withdrawLiquidity(_id);\n            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));\n\n            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);\n            assertEq(_poolTokenBalanceNew, 0);\n        } else {\n            try _user.withdrawLiquidity(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(\n            requestId,\n            admin,\n            false,\n            'Admin cannot WithdrawLiquidity a PCL in closed state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(\n            requestId,\n            borrower,\n            false,\n            'Borrower cannot WithdrawLiquidity a PCL in closed state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');\n    }\n\n    /*******************\n    Liquidate function tests\n    *******************/\n\n    function assert_liquidate_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');\n    }\n\n    function test_borrowerCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');\n    }\n\n    function test_lenderCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot liquidate a closed PCL',\n            'PCL:L1'\n        );\n    }\n\n    /********************\n    WithdrawInterest function calls\n    ********************/\n\n    function assert_withdraw_interest_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);\n            }\n\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');\n    }\n\n    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');\n    }\n\n    function test_lenderCanWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');\n    }\n\n    /********************\n    Terminate function tests\n    ********************/\n\n    function assert_terminate_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_user != admin) {\n            try _user.terminate(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _user.terminate(_id);\n            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        }\n    }\n\n    function test_adminCanTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');\n    }\n\n    function test_borrowerCannotTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(\n            requestId,\n            borrower,\n            'Should not be able to terminate a closed PCL',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    function test_lenderCannotTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Should not be able to terminate a closed PCL',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    uint256 _fromUserPoolTokenSupplyOld;\n    uint256 _toUserPoolTokenSupplyOld;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _toInterestOwed;\n    uint256 _fromInterestOwed;\n    uint256 _fromBorrowTokenBalanceInitial;\n    uint256 _toBorrowTokenBalanceInitial;\n\n    /********************\n    Pool MockToken Transfer function tests\n    ********************/\n\n    function assert_pool_token_transfer_in_closed_stage(\n        uint256 _id,\n        PCLUser _fromUser,\n        PCLUser _toUser,\n        bool _positiveCase,\n        uint256 _fractionOfPTSupply,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n\n        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);\n        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);\n\n        if (_positiveCase) {\n            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));\n            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));\n\n            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));\n            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));\n\n            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));\n\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n\n            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));\n            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));\n\n            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);\n            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);\n        } else {\n            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n\n            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);\n            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);\n        }\n    }\n\n    function test_poolTokenTransferComplete() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            PCLUser(lenders[1].lenderAddress),\n            true,\n            1,\n            '',\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartial() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            PCLUser(lenders[1].lenderAddress),\n            true,\n            4,\n            '',\n            ''\n        );\n    }\n\n    function test_poolTokenTransferToNonVerifiedUser() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            admin,\n            false,\n            4,\n            'Non-verified user should not be able to receive pool tokens',\n            'LP:IT3'\n        );\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert('External user cannot create');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert('External user cannot terminate');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert('Lender cannot lend zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L1');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Unverified lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L2');\n        }\n    }\n\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    function test_lenderCannotWithdrawZeroInterest() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertGt(_lenderInterestOwed, 0);\n\n        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));\n        _lender.withdrawInterest(requestId);\n        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));\n        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);\n        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertEq(_lenderInterestOwed, 0);\n\n        try _lender.withdrawInterest(requestId) {\n            revert('Lender cannot withdraw zero interest');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:WI1');\n        }\n    }\n\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert('Non lender cannot withdraw liquidated collateral tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:WLC1');\n        }\n    }\n\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert('Lender cannot withdraw liquidated collateral tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    function test_cannotTransferLPTokensToSameAddress() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert('Lender cannot transfer LP tokens to itself');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT1');\n        }\n    }\n\n    function test_cannotTransferLPTokensToBorrower() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {\n            revert('Lender cannot transfer LP tokens to borrower');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT2');\n        }\n    }\n\n    function test_cannotBurnPoolTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert('Lender cannot burn LP tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'ERC1155: transfer to the zero address');\n        }\n    }\n\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n\n        vm.warp(block.timestamp + request.duration);\n        borrower.close(_requestId);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);\n\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n\n        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {\n            revert('Lender cannot transfer non transferable LP tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT5');\n        }\n    }\n\n    /********************\n    View/calculation function tests\n    ********************/\n\n    function assert_helper_functionalities_in_closed_state(\n        uint256 _id,\n        PCLUser _lender,\n        PCLUser _borrower\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n\n        // 1. calculatePrincipalWithdrawable\n        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);\n        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertGe(_principalWithdrawable, _userLiquidity);\n        _lender.withdrawLiquidity(_id);\n        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));\n        assertGe(newBalance, _userLiquidity);\n\n        // 2. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        uint256 _oneUnitOfCollateral = 10(ERC20(address(collateralAsset)).decimals());\n        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);\n\n        // 3.calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);\n\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0); // Since PCL is closed now\n\n        // 5. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment\n\n        // 6. calculateCurrentDebt\n        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off\n\n        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1\n        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws\n\n        // 7. calculateCurrentCollateralRatio\n        try _borrower.calculateCurrentCollateralRatio(_id) {\n            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:IGUPT1');\n        }\n\n        // 8. collateralTokensToLiquidate\n        try _borrower.collateralTokensToLiquidate(_id, 0) {\n            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);\n            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:IGUPT1');\n        }\n    }\n\n    function test_helperFunctionInClosedState() public {\n        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:28:12 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      // The below function will create the PCL request and then lenders lend the entire requested amount     (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      borrowAndRepay(requestId);      // Now the PCL should be in the CLOSED state     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function borrowAndRepay(uint256 _id) public {     // Now we assert that we are in the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_id, _requiredCollateral, false);     }      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);     // And borrows the borrowable amount     borrower.borrow(_id, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(_id);     // Borrower decides to repay the entire debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);     borrower.repay(_id, currentDebt); }  /************************************************************************************************************************************* Start function calls *************************************************************************************************************************************/  function assert_start_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.start(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1'); }  function test_borrowerCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1'); }  function test_lenderCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in closed state',         'LP:S1'     ); }  /************************************************************************************************************************************* Cancel function calls *************************************************************************************************************************************/  function assert_cancel_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1'); }  function test_lenderCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot cancel a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Close function calls *************************************************************************************************************************************/  function assert_close_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1'); }  function test_lenderCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a closed PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the CLOSED state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAClosedPCL() public {     assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInClosedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2'); }  function test_borrowerCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2'); }  function test_lenderCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2'); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public virtual {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCanWithdrawCollateral() public {     // The below function will create the PCL request and then lenders lend the entire requested amount     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     borrowAndRepay(_id);     vm.warp(block.timestamp + request.duration.mul(110).div(100));     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     if (request.collateralRatio != 0) {         assertGt(_withdrawableCollateral, 0);         borrower.withdrawAllCollateral(_id, false);     }     uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));     assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         admin,         false,         'Admin cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         borrower,         false,         'Borrower cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot liquidate a closed PCL',         'PCL:L1'     ); }  /************************************************************************************************************************************* WithdrawInterest function calls **************************************************************************************************************************************/  function assert_withdraw_interest_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1'); }  function test_lenderCanWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user != admin) {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.terminate(_id);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     } }  function test_adminCanTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         borrower,         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _toInterestOwed; uint256 _fromInterestOwed; uint256 _fromBorrowTokenBalanceInitial; uint256 _toBorrowTokenBalanceInitial;  /************************************************************************************************************************************** Pool MockToken Transfer function tests **************************************************************************************************************************************/  function assert_pool_token_transfer_in_closed_stage(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));         _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));          _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));         _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));          _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));          assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);         assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  function test_poolTokenTransferComplete() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         1,         '',         ''     ); }  function test_poolTokenTransferPartial() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         4,         '',         ''     ); }  function test_poolTokenTransferToNonVerifiedUser() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         admin,         false,         4,         'Non-verified user should not be able to receive pool tokens',         'LP:IT3'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      uint256 _startBalance = borrowAsset.balanceOf(address(_lender));     _lender.withdrawInterest(requestId);     uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));     assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);      vm.warp(block.timestamp + request.duration);     borrower.close(_requestId);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  /************************************************************************************************************************************** View/calculation function tests **************************************************************************************************************************************/  function assert_helper_functionalities_in_closed_state(     uint256 _id,     PCLUser _lender,     PCLUser _borrower ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertGe(_principalWithdrawable, _userLiquidity);     _lender.withdrawLiquidity(_id);     uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));     assertGe(newBalance, _userLiquidity);      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());     assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0); // Since PCL is closed now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment      // 6. calculateCurrentDebt     uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off      // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1     // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws      // 7. calculateCurrentCollateralRatio     try _borrower.calculateCurrentCollateralRatio(_id) {         uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     }      // 8. collateralTokensToLiquidate     try _borrower.collateralTokensToLiquidate(_id, 0) {         uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);         assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     } }  function test_helperFunctionInClosedState() public {     assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:28:12 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:28:16 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:28:16 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16421
completion_tokens: 1
total_tokens: 16422
cost: $-1.000000


[2024-27-08 09:28:16 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
.]

###

[2024-27-08 09:28:16 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:28:16 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-27-08 09:28:16 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      // The below function will create the PCL request and then lenders lend the entire requested amount     (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      borrowAndRepay(requestId);      // Now the PCL should be in the CLOSED state     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function borrowAndRepay(uint256 _id) public {     // Now we assert that we are in the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_id, _requiredCollateral, false);     }      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);     // And borrows the borrowable amount     borrower.borrow(_id, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(_id);     // Borrower decides to repay the entire debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);     borrower.repay(_id, currentDebt); }  /************************************************************************************************************************************* Start function calls *************************************************************************************************************************************/  function assert_start_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.start(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1'); }  function test_borrowerCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1'); }  function test_lenderCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in closed state',         'LP:S1'     ); }  /************************************************************************************************************************************* Cancel function calls *************************************************************************************************************************************/  function assert_cancel_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1'); }  function test_lenderCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot cancel a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Close function calls *************************************************************************************************************************************/  function assert_close_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1'); }  function test_lenderCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a closed PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the CLOSED state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAClosedPCL() public {     assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInClosedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2'); }  function test_borrowerCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2'); }  function test_lenderCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2'); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public virtual {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCanWithdrawCollateral() public {     // The below function will create the PCL request and then lenders lend the entire requested amount     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     borrowAndRepay(_id);     vm.warp(block.timestamp + request.duration.mul(110).div(100));     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     if (request.collateralRatio != 0) {         assertGt(_withdrawableCollateral, 0);         borrower.withdrawAllCollateral(_id, false);     }     uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));     assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         admin,         false,         'Admin cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         borrower,         false,         'Borrower cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot liquidate a closed PCL',         'PCL:L1'     ); }  /************************************************************************************************************************************* WithdrawInterest function calls **************************************************************************************************************************************/  function assert_withdraw_interest_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1'); }  function test_lenderCanWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user != admin) {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.terminate(_id);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     } }  function test_adminCanTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         borrower,         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _toInterestOwed; uint256 _fromInterestOwed; uint256 _fromBorrowTokenBalanceInitial; uint256 _toBorrowTokenBalanceInitial;  /************************************************************************************************************************************** Pool MockToken Transfer function tests **************************************************************************************************************************************/  function assert_pool_token_transfer_in_closed_stage(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));         _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));          _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));         _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));          _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));          assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);         assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  function test_poolTokenTransferComplete() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         1,         '',         ''     ); }  function test_poolTokenTransferPartial() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         4,         '',         ''     ); }  function test_poolTokenTransferToNonVerifiedUser() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         admin,         false,         4,         'Non-verified user should not be able to receive pool tokens',         'LP:IT3'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      uint256 _startBalance = borrowAsset.balanceOf(address(_lender));     _lender.withdrawInterest(requestId);     uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));     assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);      vm.warp(block.timestamp + request.duration);     borrower.close(_requestId);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  /************************************************************************************************************************************** View/calculation function tests **************************************************************************************************************************************/  function assert_helper_functionalities_in_closed_state(     uint256 _id,     PCLUser _lender,     PCLUser _borrower ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertGe(_principalWithdrawable, _userLiquidity);     _lender.withdrawLiquidity(_id);     uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));     assertGe(newBalance, _userLiquidity);      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());     assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0); // Since PCL is closed now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment      // 6. calculateCurrentDebt     uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off      // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1     // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws      // 7. calculateCurrentCollateralRatio     try _borrower.calculateCurrentCollateralRatio(_id) {         uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     }      // 8. collateralTokensToLiquidate     try _borrower.collateralTokensToLiquidate(_id, 0) {         uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);         assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     } }  function test_helperFunctionInClosedState() public {     assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:28:16 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      // The below function will create the PCL request and then lenders lend the entire requested amount     (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      borrowAndRepay(requestId);      // Now the PCL should be in the CLOSED state     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function borrowAndRepay(uint256 _id) public {     // Now we assert that we are in the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_id, _requiredCollateral, false);     }      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);     // And borrows the borrowable amount     borrower.borrow(_id, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(_id);     // Borrower decides to repay the entire debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);     borrower.repay(_id, currentDebt); }  /************************************************************************************************************************************* Start function calls *************************************************************************************************************************************/  function assert_start_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.start(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1'); }  function test_borrowerCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1'); }  function test_lenderCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in closed state',         'LP:S1'     ); }  /************************************************************************************************************************************* Cancel function calls *************************************************************************************************************************************/  function assert_cancel_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1'); }  function test_lenderCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot cancel a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Close function calls *************************************************************************************************************************************/  function assert_close_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1'); }  function test_lenderCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a closed PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the CLOSED state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAClosedPCL() public {     assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInClosedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2'); }  function test_borrowerCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2'); }  function test_lenderCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2'); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public virtual {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCanWithdrawCollateral() public {     // The below function will create the PCL request and then lenders lend the entire requested amount     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     borrowAndRepay(_id);     vm.warp(block.timestamp + request.duration.mul(110).div(100));     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     if (request.collateralRatio != 0) {         assertGt(_withdrawableCollateral, 0);         borrower.withdrawAllCollateral(_id, false);     }     uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));     assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         admin,         false,         'Admin cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         borrower,         false,         'Borrower cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot liquidate a closed PCL',         'PCL:L1'     ); }  /************************************************************************************************************************************* WithdrawInterest function calls **************************************************************************************************************************************/  function assert_withdraw_interest_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1'); }  function test_lenderCanWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user != admin) {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.terminate(_id);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     } }  function test_adminCanTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         borrower,         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _toInterestOwed; uint256 _fromInterestOwed; uint256 _fromBorrowTokenBalanceInitial; uint256 _toBorrowTokenBalanceInitial;  /************************************************************************************************************************************** Pool MockToken Transfer function tests **************************************************************************************************************************************/  function assert_pool_token_transfer_in_closed_stage(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));         _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));          _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));         _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));          _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));          assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);         assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  function test_poolTokenTransferComplete() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         1,         '',         ''     ); }  function test_poolTokenTransferPartial() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         4,         '',         ''     ); }  function test_poolTokenTransferToNonVerifiedUser() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         admin,         false,         4,         'Non-verified user should not be able to receive pool tokens',         'LP:IT3'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      uint256 _startBalance = borrowAsset.balanceOf(address(_lender));     _lender.withdrawInterest(requestId);     uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));     assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);      vm.warp(block.timestamp + request.duration);     borrower.close(_requestId);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  /************************************************************************************************************************************** View/calculation function tests **************************************************************************************************************************************/  function assert_helper_functionalities_in_closed_state(     uint256 _id,     PCLUser _lender,     PCLUser _borrower ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertGe(_principalWithdrawable, _userLiquidity);     _lender.withdrawLiquidity(_id);     uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));     assertGe(newBalance, _userLiquidity);      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());     assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0); // Since PCL is closed now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment      // 6. calculateCurrentDebt     uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off      // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1     // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws      // 7. calculateCurrentCollateralRatio     try _borrower.calculateCurrentCollateralRatio(_id) {         uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     }      // 8. collateralTokensToLiquidate     try _borrower.collateralTokensToLiquidate(_id, 0) {         uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);         assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     } }  function test_helperFunctionInClosedState() public {     assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:28:16 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:28:32 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:28:32 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8270
completion_tokens: 694
total_tokens: 8964
cost: $-1.000000


[2024-27-08 09:28:32 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
.]

Based on the provided Solidity smart contract code for the `PCLClosedStage` and its associated functionalities, the following security vulnerabilities and issues have been identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not implement any reentrancy guards, which could allow malicious actors to exploit functions that transfer tokens or modify state variables. This is particularly concerning in functions that involve transferring collateral or borrowing assets.

2. **Lack of Input Validation**:
   - Several functions do not validate input parameters adequately. For instance, functions like `borrowAndRepay` and `assert_collateralCannotBeDepositedInClosedState` assume that the input values are always valid without checks for zero or negative values.

3. **Potential Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are still areas where arithmetic operations could lead to unexpected results if not handled properly. For example, calculations involving user balances or collateral ratios should be carefully monitored.

4. **Improper Access Control**:
   - Functions that should be restricted to certain roles (like admin or borrower) do not have adequate access control checks. For instance, the `terminate` function allows the admin to terminate a closed PCL, but there are no checks to ensure that only the admin can call it.

5. **Error Handling**:
   - The contract relies heavily on `try/catch` for error handling, which may not always provide clear feedback to the user. This could lead to confusion about why certain operations fail.

6. **Gas Limit Issues**:
   - Some functions, especially those involving loops or multiple state changes, may exceed gas limits in certain scenarios, leading to failed transactions. This is particularly relevant in functions that handle multiple lenders or borrowers.

7. **Lack of Event Emissions**:
   - Important state changes (like closing a PCL or withdrawing collateral) do not emit events. This lack of transparency can hinder tracking and auditing of contract activities.

8. **Inadequate Testing Coverage**:
   - While there are numerous tests, certain edge cases may not be covered, such as scenarios involving maximum limits for deposits or withdrawals, which could lead to unexpected behaviors.

### Comprehensive Analysis Report:

The `PCLClosedStage` contract presents a robust framework for managing pooled credit lines; however, it is not without its vulnerabilities. The absence of reentrancy guards poses a significant risk, especially in functions that handle asset transfers. Input validation is crucial to prevent unexpected behaviors, and the reliance on `SafeMath` alone does not eliminate the risk of arithmetic errors.

Access control mechanisms need to be reinforced to ensure that only authorized users can execute sensitive functions. The error handling strategy should be refined to provide clearer feedback to users, enhancing the overall user experience.

Gas limit considerations are essential, particularly for functions that may involve multiple transactions or state changes. Additionally, the lack of event emissions for critical state changes reduces the transparency of contract operations, making it difficult to track activities.

Finally, while the testing framework is extensive, it is vital to ensure that all potential edge cases are covered to prevent unforeseen issues during contract execution.

In conclusion, addressing these vulnerabilities through careful code review, enhanced testing, and robust security practices will significantly improve the contract's resilience against attacks and operational failures. It is recommended to conduct a thorough audit and implement the suggested improvements before deploying the contract in a production environment.

[2024-27-08 09:28:32 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `PCLClosedStage` and its associated functionalities, the following security vulnerabilities and issues have been identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not implement any reentrancy guards, which could allow malicious actors to exploit functions that transfer tokens or modify state variables. This is particularly concerning in functions that involve transferring collateral or borrowing assets.

2. **Lack of Input Validation**:
   - Several functions do not validate input parameters adequately. For instance, functions like `borrowAndRepay` and `assert_collateralCannotBeDepositedInClosedState` assume that the input values are always valid without checks for zero or negative values.

3. **Potential Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are still areas where arithmetic operations could lead to unexpected results if not handled properly. For example, calculations involving user balances or collateral ratios should be carefully monitored.

4. **Improper Access Control**:
   - Functions that should be restricted to certain roles (like admin or borrower) do not have adequate access control checks. For instance, the `terminate` function allows the admin to terminate a closed PCL, but there are no checks to ensure that only the admin can call it.

5. **Error Handling**:
   - The contract relies heavily on `try/catch` for error handling, which may not always provide clear feedback to the user. This could lead to confusion about why certain operations fail.

6. **Gas Limit Issues**:
   - Some functions, especially those involving loops or multiple state changes, may exceed gas limits in certain scenarios, leading to failed transactions. This is particularly relevant in functions that handle multiple lenders or borrowers.

7. **Lack of Event Emissions**:
   - Important state changes (like closing a PCL or withdrawing collateral) do not emit events. This lack of transparency can hinder tracking and auditing of contract activities.

8. **Inadequate Testing Coverage**:
   - While there are numerous tests, certain edge cases may not be covered, such as scenarios involving maximum limits for deposits or withdrawals, which could lead to unexpected behaviors.

### Comprehensive Analysis Report:

The `PCLClosedStage` contract presents a robust framework for managing pooled credit lines; however, it is not without its vulnerabilities. The absence of reentrancy guards poses a significant risk, especially in functions that handle asset transfers. Input validation is crucial to prevent unexpected behaviors, and the reliance on `SafeMath` alone does not eliminate the risk of arithmetic errors.

Access control mechanisms need to be reinforced to ensure that only authorized users can execute sensitive functions. The error handling strategy should be refined to provide clearer feedback to users, enhancing the overall user experience.

Gas limit considerations are essential, particularly for functions that may involve multiple transactions or state changes. Additionally, the lack of event emissions for critical state changes reduces the transparency of contract operations, making it difficult to track activities.

Finally, while the testing framework is extensive, it is vital to ensure that all potential edge cases are covered to prevent unforeseen issues during contract execution.

In conclusion, addressing these vulnerabilities through careful code review, enhanced testing, and robust security practices will significantly improve the contract's resilience against attacks and operational failures. It is recommended to conduct a thorough audit and implement the suggested improvements before deploying the contract in a production environment.

[2024-27-08 09:28:32 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-27-08 09:28:32 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      // The below function will create the PCL request and then lenders lend the entire requested amount     (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      borrowAndRepay(requestId);      // Now the PCL should be in the CLOSED state     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function borrowAndRepay(uint256 _id) public {     // Now we assert that we are in the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_id, _requiredCollateral, false);     }      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);     // And borrows the borrowable amount     borrower.borrow(_id, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(_id);     // Borrower decides to repay the entire debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);     borrower.repay(_id, currentDebt); }  /************************************************************************************************************************************* Start function calls *************************************************************************************************************************************/  function assert_start_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.start(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1'); }  function test_borrowerCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1'); }  function test_lenderCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in closed state',         'LP:S1'     ); }  /************************************************************************************************************************************* Cancel function calls *************************************************************************************************************************************/  function assert_cancel_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1'); }  function test_lenderCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot cancel a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Close function calls *************************************************************************************************************************************/  function assert_close_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1'); }  function test_lenderCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a closed PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the CLOSED state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAClosedPCL() public {     assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInClosedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2'); }  function test_borrowerCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2'); }  function test_lenderCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2'); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public virtual {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCanWithdrawCollateral() public {     // The below function will create the PCL request and then lenders lend the entire requested amount     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     borrowAndRepay(_id);     vm.warp(block.timestamp + request.duration.mul(110).div(100));     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     if (request.collateralRatio != 0) {         assertGt(_withdrawableCollateral, 0);         borrower.withdrawAllCollateral(_id, false);     }     uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));     assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         admin,         false,         'Admin cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         borrower,         false,         'Borrower cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot liquidate a closed PCL',         'PCL:L1'     ); }  /************************************************************************************************************************************* WithdrawInterest function calls **************************************************************************************************************************************/  function assert_withdraw_interest_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1'); }  function test_lenderCanWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user != admin) {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.terminate(_id);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     } }  function test_adminCanTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         borrower,         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _toInterestOwed; uint256 _fromInterestOwed; uint256 _fromBorrowTokenBalanceInitial; uint256 _toBorrowTokenBalanceInitial;  /************************************************************************************************************************************** Pool MockToken Transfer function tests **************************************************************************************************************************************/  function assert_pool_token_transfer_in_closed_stage(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));         _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));          _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));         _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));          _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));          assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);         assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  function test_poolTokenTransferComplete() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         1,         '',         ''     ); }  function test_poolTokenTransferPartial() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         4,         '',         ''     ); }  function test_poolTokenTransferToNonVerifiedUser() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         admin,         false,         4,         'Non-verified user should not be able to receive pool tokens',         'LP:IT3'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      uint256 _startBalance = borrowAsset.balanceOf(address(_lender));     _lender.withdrawInterest(requestId);     uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));     assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);      vm.warp(block.timestamp + request.duration);     borrower.close(_requestId);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  /************************************************************************************************************************************** View/calculation function tests **************************************************************************************************************************************/  function assert_helper_functionalities_in_closed_state(     uint256 _id,     PCLUser _lender,     PCLUser _borrower ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertGe(_principalWithdrawable, _userLiquidity);     _lender.withdrawLiquidity(_id);     uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));     assertGe(newBalance, _userLiquidity);      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());     assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0); // Since PCL is closed now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment      // 6. calculateCurrentDebt     uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off      // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1     // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws      // 7. calculateCurrentCollateralRatio     try _borrower.calculateCurrentCollateralRatio(_id) {         uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     }      // 8. collateralTokensToLiquidate     try _borrower.collateralTokensToLiquidate(_id, 0) {         uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);         assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     } }  function test_helperFunctionInClosedState() public {     assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../Helpers/PCLParent.t.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\n\ncontract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n\n    uint256 requestId;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        request.borrowLimit = uint128(1_000_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * 1e18) / 1e2);\n        request.collateralRatio = 1e18;\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * 1e18) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        // The below function will create the PCL request and then lenders lend the entire requested amount\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        borrowAndRepay(requestId);\n\n        // Now the PCL should be in the CLOSED state\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function borrowAndRepay(uint256 _id) public {\n        // Now we assert that we are in the ACTIVE state\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_id, _requiredCollateral, false);\n        }\n\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);\n        // And borrows the borrowable amount\n        borrower.borrow(_id, borrowableAmount);\n\n        // Borrower decides to repay everything at mid-duration\n\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(_id);\n        // Borrower decides to repay the entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);\n        borrower.repay(_id, currentDebt);\n    }\n\n    /*******************\n    Start function calls\n    *******************/\n\n    function assert_start_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.start(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');\n    }\n\n    function test_borrowerCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');\n    }\n\n    function test_lenderCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot start a PCL in closed state',\n            'LP:S1'\n        );\n    }\n\n    /*******************\n    Cancel function calls\n    *******************/\n\n    function assert_cancel_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');\n    }\n\n    function test_lenderCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot cancel a PCL in closed state',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Close function calls\n    *******************/\n\n    function assert_close_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');\n    }\n\n    function test_lenderCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot close a closed PCL',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Deposit collateral function calls\n    *******************/\n\n    function assert_collateralCannotBeDepositedInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n\n        try _depositor.depositCollateral(_id, _amount, false) {\n            revert('Collateral cannot be deposited in the CLOSED state');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:DC2');\n        }\n    }\n\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);\n    }\n\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);\n    }\n\n    /*******************\n    Borrow function tests\n    *******************/\n\n    function assertBorrowFunctionalityInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotBorrowAClosedPCL() public {\n        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');\n    }\n\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');\n    }\n\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInClosedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot borrow a PCL in closed state',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Repay function tests\n    *******************/\n\n    function assertRepayFunctionalityInClosedState(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');\n    }\n\n    function test_borrowerCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');\n    }\n\n    function test_lenderCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');\n    }\n\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n\n    function assertWithdrawCollateralFunctionalityInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public virtual {\n        if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawAllCollateral(_id, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertGe(_balanceAfter, _balanceBefore);\n        } else {\n            try _user.withdrawAllCollateral(_id, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessageAll);\n            }\n        }\n\n        if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawCollateral(_id, _amount, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);\n        } else {\n            try _user.withdrawCollateral(_id, _amount, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            admin,\n            'Admin cannot withdraw collateral in closed state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            borrower,\n            'Borrower cannot withdraw collateral in closed state',\n            'PCL:WC1',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            0,\n            borrower,\n            'Borrower cannot withdraw collateral in closed state',\n            'PCL:WC2',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot withdraw collateral in closed state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCanWithdrawCollateral() public {\n        // The below function will create the PCL request and then lenders lend the entire requested amount\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        borrowAndRepay(_id);\n        vm.warp(block.timestamp + request.duration.mul(110).div(100));\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n\n        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);\n        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);\n        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));\n        if (request.collateralRatio != 0) {\n            assertGt(_withdrawableCollateral, 0);\n            borrower.withdrawAllCollateral(_id, false);\n        }\n        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));\n        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);\n    }\n\n    /*******************\n    WithdrawLiquidity function calls\n    *******************/\n\n    function assert_withdraw_liquidity_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));\n            _user.withdrawLiquidity(_id);\n            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));\n\n            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);\n            assertEq(_poolTokenBalanceNew, 0);\n        } else {\n            try _user.withdrawLiquidity(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(\n            requestId,\n            admin,\n            false,\n            'Admin cannot WithdrawLiquidity a PCL in closed state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(\n            requestId,\n            borrower,\n            false,\n            'Borrower cannot WithdrawLiquidity a PCL in closed state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');\n    }\n\n    /*******************\n    Liquidate function tests\n    *******************/\n\n    function assert_liquidate_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');\n    }\n\n    function test_borrowerCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');\n    }\n\n    function test_lenderCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot liquidate a closed PCL',\n            'PCL:L1'\n        );\n    }\n\n    /********************\n    WithdrawInterest function calls\n    ********************/\n\n    function assert_withdraw_interest_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);\n            }\n\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');\n    }\n\n    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');\n    }\n\n    function test_lenderCanWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');\n    }\n\n    /********************\n    Terminate function tests\n    ********************/\n\n    function assert_terminate_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_user != admin) {\n            try _user.terminate(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _user.terminate(_id);\n            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        }\n    }\n\n    function test_adminCanTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');\n    }\n\n    function test_borrowerCannotTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(\n            requestId,\n            borrower,\n            'Should not be able to terminate a closed PCL',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    function test_lenderCannotTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Should not be able to terminate a closed PCL',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    uint256 _fromUserPoolTokenSupplyOld;\n    uint256 _toUserPoolTokenSupplyOld;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _toInterestOwed;\n    uint256 _fromInterestOwed;\n    uint256 _fromBorrowTokenBalanceInitial;\n    uint256 _toBorrowTokenBalanceInitial;\n\n    /********************\n    Pool MockToken Transfer function tests\n    ********************/\n\n    function assert_pool_token_transfer_in_closed_stage(\n        uint256 _id,\n        PCLUser _fromUser,\n        PCLUser _toUser,\n        bool _positiveCase,\n        uint256 _fractionOfPTSupply,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n\n        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);\n        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);\n\n        if (_positiveCase) {\n            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));\n            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));\n\n            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));\n            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));\n\n            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));\n\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n\n            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));\n            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));\n\n            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);\n            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);\n        } else {\n            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n\n            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);\n            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);\n        }\n    }\n\n    function test_poolTokenTransferComplete() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            PCLUser(lenders[1].lenderAddress),\n            true,\n            1,\n            '',\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartial() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            PCLUser(lenders[1].lenderAddress),\n            true,\n            4,\n            '',\n            ''\n        );\n    }\n\n    function test_poolTokenTransferToNonVerifiedUser() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            admin,\n            false,\n            4,\n            'Non-verified user should not be able to receive pool tokens',\n            'LP:IT3'\n        );\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert('External user cannot create');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert('External user cannot terminate');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert('Lender cannot lend zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L1');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Unverified lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L2');\n        }\n    }\n\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    function test_lenderCannotWithdrawZeroInterest() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertGt(_lenderInterestOwed, 0);\n\n        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));\n        _lender.withdrawInterest(requestId);\n        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));\n        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);\n        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertEq(_lenderInterestOwed, 0);\n\n        try _lender.withdrawInterest(requestId) {\n            revert('Lender cannot withdraw zero interest');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:WI1');\n        }\n    }\n\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert('Non lender cannot withdraw liquidated collateral tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:WLC1');\n        }\n    }\n\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert('Lender cannot withdraw liquidated collateral tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    function test_cannotTransferLPTokensToSameAddress() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert('Lender cannot transfer LP tokens to itself');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT1');\n        }\n    }\n\n    function test_cannotTransferLPTokensToBorrower() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {\n            revert('Lender cannot transfer LP tokens to borrower');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT2');\n        }\n    }\n\n    function test_cannotBurnPoolTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert('Lender cannot burn LP tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'ERC1155: transfer to the zero address');\n        }\n    }\n\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n\n        vm.warp(block.timestamp + request.duration);\n        borrower.close(_requestId);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);\n\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n\n        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {\n            revert('Lender cannot transfer non transferable LP tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT5');\n        }\n    }\n\n    /********************\n    View/calculation function tests\n    ********************/\n\n    function assert_helper_functionalities_in_closed_state(\n        uint256 _id,\n        PCLUser _lender,\n        PCLUser _borrower\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n\n        // 1. calculatePrincipalWithdrawable\n        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);\n        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertGe(_principalWithdrawable, _userLiquidity);\n        _lender.withdrawLiquidity(_id);\n        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));\n        assertGe(newBalance, _userLiquidity);\n\n        // 2. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        uint256 _oneUnitOfCollateral = 10(ERC20(address(collateralAsset)).decimals());\n        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);\n\n        // 3.calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);\n\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0); // Since PCL is closed now\n\n        // 5. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment\n\n        // 6. calculateCurrentDebt\n        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off\n\n        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1\n        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws\n\n        // 7. calculateCurrentCollateralRatio\n        try _borrower.calculateCurrentCollateralRatio(_id) {\n            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:IGUPT1');\n        }\n\n        // 8. collateralTokensToLiquidate\n        try _borrower.collateralTokensToLiquidate(_id, 0) {\n            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);\n            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:IGUPT1');\n        }\n    }\n\n    function test_helperFunctionInClosedState() public {\n        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:28:32 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      // The below function will create the PCL request and then lenders lend the entire requested amount     (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      borrowAndRepay(requestId);      // Now the PCL should be in the CLOSED state     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function borrowAndRepay(uint256 _id) public {     // Now we assert that we are in the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_id, _requiredCollateral, false);     }      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);     // And borrows the borrowable amount     borrower.borrow(_id, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(_id);     // Borrower decides to repay the entire debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);     borrower.repay(_id, currentDebt); }  /************************************************************************************************************************************* Start function calls *************************************************************************************************************************************/  function assert_start_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.start(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1'); }  function test_borrowerCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1'); }  function test_lenderCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in closed state',         'LP:S1'     ); }  /************************************************************************************************************************************* Cancel function calls *************************************************************************************************************************************/  function assert_cancel_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1'); }  function test_lenderCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot cancel a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Close function calls *************************************************************************************************************************************/  function assert_close_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1'); }  function test_lenderCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a closed PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the CLOSED state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAClosedPCL() public {     assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInClosedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2'); }  function test_borrowerCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2'); }  function test_lenderCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2'); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public virtual {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCanWithdrawCollateral() public {     // The below function will create the PCL request and then lenders lend the entire requested amount     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     borrowAndRepay(_id);     vm.warp(block.timestamp + request.duration.mul(110).div(100));     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     if (request.collateralRatio != 0) {         assertGt(_withdrawableCollateral, 0);         borrower.withdrawAllCollateral(_id, false);     }     uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));     assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         admin,         false,         'Admin cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         borrower,         false,         'Borrower cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot liquidate a closed PCL',         'PCL:L1'     ); }  /************************************************************************************************************************************* WithdrawInterest function calls **************************************************************************************************************************************/  function assert_withdraw_interest_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1'); }  function test_lenderCanWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user != admin) {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.terminate(_id);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     } }  function test_adminCanTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         borrower,         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _toInterestOwed; uint256 _fromInterestOwed; uint256 _fromBorrowTokenBalanceInitial; uint256 _toBorrowTokenBalanceInitial;  /************************************************************************************************************************************** Pool MockToken Transfer function tests **************************************************************************************************************************************/  function assert_pool_token_transfer_in_closed_stage(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));         _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));          _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));         _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));          _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));          assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);         assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  function test_poolTokenTransferComplete() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         1,         '',         ''     ); }  function test_poolTokenTransferPartial() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         4,         '',         ''     ); }  function test_poolTokenTransferToNonVerifiedUser() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         admin,         false,         4,         'Non-verified user should not be able to receive pool tokens',         'LP:IT3'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      uint256 _startBalance = borrowAsset.balanceOf(address(_lender));     _lender.withdrawInterest(requestId);     uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));     assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);      vm.warp(block.timestamp + request.duration);     borrower.close(_requestId);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  /************************************************************************************************************************************** View/calculation function tests **************************************************************************************************************************************/  function assert_helper_functionalities_in_closed_state(     uint256 _id,     PCLUser _lender,     PCLUser _borrower ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertGe(_principalWithdrawable, _userLiquidity);     _lender.withdrawLiquidity(_id);     uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));     assertGe(newBalance, _userLiquidity);      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());     assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0); // Since PCL is closed now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment      // 6. calculateCurrentDebt     uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off      // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1     // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws      // 7. calculateCurrentCollateralRatio     try _borrower.calculateCurrentCollateralRatio(_id) {         uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     }      // 8. collateralTokensToLiquidate     try _borrower.collateralTokensToLiquidate(_id, 0) {         uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);         assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     } }  function test_helperFunctionInClosedState() public {     assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:28:32 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:28:36 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:28:36 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16421
completion_tokens: 1
total_tokens: 16422
cost: $-1.000000


[2024-27-08 09:28:36 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
.]

###

[2024-27-08 09:28:36 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:28:36 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-27-08 09:28:36 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      // The below function will create the PCL request and then lenders lend the entire requested amount     (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      borrowAndRepay(requestId);      // Now the PCL should be in the CLOSED state     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function borrowAndRepay(uint256 _id) public {     // Now we assert that we are in the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_id, _requiredCollateral, false);     }      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);     // And borrows the borrowable amount     borrower.borrow(_id, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(_id);     // Borrower decides to repay the entire debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);     borrower.repay(_id, currentDebt); }  /************************************************************************************************************************************* Start function calls *************************************************************************************************************************************/  function assert_start_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.start(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1'); }  function test_borrowerCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1'); }  function test_lenderCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in closed state',         'LP:S1'     ); }  /************************************************************************************************************************************* Cancel function calls *************************************************************************************************************************************/  function assert_cancel_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1'); }  function test_lenderCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot cancel a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Close function calls *************************************************************************************************************************************/  function assert_close_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1'); }  function test_lenderCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a closed PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the CLOSED state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAClosedPCL() public {     assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInClosedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2'); }  function test_borrowerCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2'); }  function test_lenderCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2'); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public virtual {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCanWithdrawCollateral() public {     // The below function will create the PCL request and then lenders lend the entire requested amount     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     borrowAndRepay(_id);     vm.warp(block.timestamp + request.duration.mul(110).div(100));     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     if (request.collateralRatio != 0) {         assertGt(_withdrawableCollateral, 0);         borrower.withdrawAllCollateral(_id, false);     }     uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));     assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         admin,         false,         'Admin cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         borrower,         false,         'Borrower cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot liquidate a closed PCL',         'PCL:L1'     ); }  /************************************************************************************************************************************* WithdrawInterest function calls **************************************************************************************************************************************/  function assert_withdraw_interest_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1'); }  function test_lenderCanWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user != admin) {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.terminate(_id);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     } }  function test_adminCanTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         borrower,         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _toInterestOwed; uint256 _fromInterestOwed; uint256 _fromBorrowTokenBalanceInitial; uint256 _toBorrowTokenBalanceInitial;  /************************************************************************************************************************************** Pool MockToken Transfer function tests **************************************************************************************************************************************/  function assert_pool_token_transfer_in_closed_stage(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));         _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));          _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));         _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));          _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));          assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);         assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  function test_poolTokenTransferComplete() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         1,         '',         ''     ); }  function test_poolTokenTransferPartial() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         4,         '',         ''     ); }  function test_poolTokenTransferToNonVerifiedUser() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         admin,         false,         4,         'Non-verified user should not be able to receive pool tokens',         'LP:IT3'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      uint256 _startBalance = borrowAsset.balanceOf(address(_lender));     _lender.withdrawInterest(requestId);     uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));     assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);      vm.warp(block.timestamp + request.duration);     borrower.close(_requestId);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  /************************************************************************************************************************************** View/calculation function tests **************************************************************************************************************************************/  function assert_helper_functionalities_in_closed_state(     uint256 _id,     PCLUser _lender,     PCLUser _borrower ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertGe(_principalWithdrawable, _userLiquidity);     _lender.withdrawLiquidity(_id);     uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));     assertGe(newBalance, _userLiquidity);      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());     assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0); // Since PCL is closed now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment      // 6. calculateCurrentDebt     uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off      // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1     // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws      // 7. calculateCurrentCollateralRatio     try _borrower.calculateCurrentCollateralRatio(_id) {         uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     }      // 8. collateralTokensToLiquidate     try _borrower.collateralTokensToLiquidate(_id, 0) {         uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);         assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     } }  function test_helperFunctionInClosedState() public {     assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:28:36 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      // The below function will create the PCL request and then lenders lend the entire requested amount     (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      borrowAndRepay(requestId);      // Now the PCL should be in the CLOSED state     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function borrowAndRepay(uint256 _id) public {     // Now we assert that we are in the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_id, _requiredCollateral, false);     }      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);     // And borrows the borrowable amount     borrower.borrow(_id, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(_id);     // Borrower decides to repay the entire debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);     borrower.repay(_id, currentDebt); }  /************************************************************************************************************************************* Start function calls *************************************************************************************************************************************/  function assert_start_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.start(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1'); }  function test_borrowerCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1'); }  function test_lenderCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in closed state',         'LP:S1'     ); }  /************************************************************************************************************************************* Cancel function calls *************************************************************************************************************************************/  function assert_cancel_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1'); }  function test_lenderCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot cancel a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Close function calls *************************************************************************************************************************************/  function assert_close_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1'); }  function test_lenderCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a closed PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the CLOSED state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAClosedPCL() public {     assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInClosedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2'); }  function test_borrowerCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2'); }  function test_lenderCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2'); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public virtual {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCanWithdrawCollateral() public {     // The below function will create the PCL request and then lenders lend the entire requested amount     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     borrowAndRepay(_id);     vm.warp(block.timestamp + request.duration.mul(110).div(100));     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     if (request.collateralRatio != 0) {         assertGt(_withdrawableCollateral, 0);         borrower.withdrawAllCollateral(_id, false);     }     uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));     assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         admin,         false,         'Admin cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         borrower,         false,         'Borrower cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot liquidate a closed PCL',         'PCL:L1'     ); }  /************************************************************************************************************************************* WithdrawInterest function calls **************************************************************************************************************************************/  function assert_withdraw_interest_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1'); }  function test_lenderCanWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user != admin) {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.terminate(_id);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     } }  function test_adminCanTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         borrower,         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _toInterestOwed; uint256 _fromInterestOwed; uint256 _fromBorrowTokenBalanceInitial; uint256 _toBorrowTokenBalanceInitial;  /************************************************************************************************************************************** Pool MockToken Transfer function tests **************************************************************************************************************************************/  function assert_pool_token_transfer_in_closed_stage(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));         _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));          _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));         _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));          _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));          assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);         assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  function test_poolTokenTransferComplete() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         1,         '',         ''     ); }  function test_poolTokenTransferPartial() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         4,         '',         ''     ); }  function test_poolTokenTransferToNonVerifiedUser() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         admin,         false,         4,         'Non-verified user should not be able to receive pool tokens',         'LP:IT3'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      uint256 _startBalance = borrowAsset.balanceOf(address(_lender));     _lender.withdrawInterest(requestId);     uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));     assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);      vm.warp(block.timestamp + request.duration);     borrower.close(_requestId);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  /************************************************************************************************************************************** View/calculation function tests **************************************************************************************************************************************/  function assert_helper_functionalities_in_closed_state(     uint256 _id,     PCLUser _lender,     PCLUser _borrower ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertGe(_principalWithdrawable, _userLiquidity);     _lender.withdrawLiquidity(_id);     uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));     assertGe(newBalance, _userLiquidity);      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());     assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0); // Since PCL is closed now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment      // 6. calculateCurrentDebt     uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off      // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1     // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws      // 7. calculateCurrentCollateralRatio     try _borrower.calculateCurrentCollateralRatio(_id) {         uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     }      // 8. collateralTokensToLiquidate     try _borrower.collateralTokensToLiquidate(_id, 0) {         uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);         assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     } }  function test_helperFunctionInClosedState() public {     assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:28:36 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:28:48 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:28:48 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8270
completion_tokens: 777
total_tokens: 9047
cost: $-1.000000


[2024-27-08 09:28:48 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
.]

Based on the provided Solidity smart contract code for the `PCLClosedStage` and the analysis reports, here is a summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not implement a reentrancy guard, which could allow malicious actors to exploit functions that transfer tokens or modify state variables, potentially leading to unexpected behavior or loss of funds.

2. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, it is essential to ensure that all arithmetic operations are consistently protected against overflow and underflow, especially in critical calculations involving user balances and limits.

3. **Access Control Issues**:
   - There are functions that could potentially be called by unauthorized users, especially in the context of state changes. For example, the `terminate` function can only be called by the admin, but if the admin's address is compromised, it could lead to unauthorized termination of the pooled credit line.

4. **Gas Limit and Loops**:
   - The contract contains functions that may involve loops (e.g., when handling multiple lenders). If the number of lenders grows significantly, it could lead to exceeding the gas limit, causing transactions to fail.

5. **Improper Error Handling**:
   - The contract relies on `try/catch` statements for error handling, which may not cover all edge cases. It is crucial to ensure that all potential failure points are adequately handled to prevent unexpected behavior.

6. **Lack of Event Emissions**:
   - Certain state-changing functions do not emit events, which is essential for tracking changes on-chain and for front-end applications to react appropriately to state changes.

7. **Token Transfer Failures**:
   - The contract does not check the return value of token transfers, which could lead to scenarios where tokens are not transferred as expected, resulting in a loss of funds or incorrect state.

8. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, where a malicious actor could observe pending transactions and exploit them for profit.

### Comprehensive Analysis Report:

The `PCLClosedStage` contract demonstrates a robust structure for managing pooled credit lines; however, it is not without its vulnerabilities. The identified issues primarily revolve around access control, error handling, and potential gas limit problems. 

1. **Reentrancy Protection**: Implementing a reentrancy guard is crucial, especially in functions that involve external calls. This will help mitigate the risk of reentrancy attacks.

2. **Access Control**: Strengthening access control mechanisms is necessary to ensure that only authorized users can execute sensitive functions. This includes implementing role-based access control or multi-signature requirements for critical operations.

3. **Gas Limit Considerations**: Functions that may involve loops should be optimized or designed to handle larger datasets without exceeding gas limits. This could involve batching operations or limiting the number of iterations.

4. **Error Handling**: A more comprehensive error handling strategy should be employed to ensure that all potential failure points are accounted for, reducing the risk of unexpected behavior.

5. **Event Emissions**: Ensuring that all state-changing functions emit appropriate events will enhance transparency and allow for better tracking of contract activity.

6. **Token Transfer Checks**: Implementing checks for token transfer success will prevent scenarios where funds are lost due to failed transfers.

7. **Front-Running Mitigation**: Consider implementing mechanisms to mitigate front-running risks, such as commit-reveal schemes or time-locks on sensitive operations.

In conclusion, while the `PCLClosedStage` contract is well-structured, addressing the identified vulnerabilities will significantly enhance its security posture and reliability. A thorough audit and testing phase should be conducted before deployment to ensure that all potential risks are mitigated.

[2024-27-08 09:28:48 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `PCLClosedStage` and the analysis reports, here is a summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not implement a reentrancy guard, which could allow malicious actors to exploit functions that transfer tokens or modify state variables, potentially leading to unexpected behavior or loss of funds.

2. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, it is essential to ensure that all arithmetic operations are consistently protected against overflow and underflow, especially in critical calculations involving user balances and limits.

3. **Access Control Issues**:
   - There are functions that could potentially be called by unauthorized users, especially in the context of state changes. For example, the `terminate` function can only be called by the admin, but if the admin's address is compromised, it could lead to unauthorized termination of the pooled credit line.

4. **Gas Limit and Loops**:
   - The contract contains functions that may involve loops (e.g., when handling multiple lenders). If the number of lenders grows significantly, it could lead to exceeding the gas limit, causing transactions to fail.

5. **Improper Error Handling**:
   - The contract relies on `try/catch` statements for error handling, which may not cover all edge cases. It is crucial to ensure that all potential failure points are adequately handled to prevent unexpected behavior.

6. **Lack of Event Emissions**:
   - Certain state-changing functions do not emit events, which is essential for tracking changes on-chain and for front-end applications to react appropriately to state changes.

7. **Token Transfer Failures**:
   - The contract does not check the return value of token transfers, which could lead to scenarios where tokens are not transferred as expected, resulting in a loss of funds or incorrect state.

8. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, where a malicious actor could observe pending transactions and exploit them for profit.

### Comprehensive Analysis Report:

The `PCLClosedStage` contract demonstrates a robust structure for managing pooled credit lines; however, it is not without its vulnerabilities. The identified issues primarily revolve around access control, error handling, and potential gas limit problems. 

1. **Reentrancy Protection**: Implementing a reentrancy guard is crucial, especially in functions that involve external calls. This will help mitigate the risk of reentrancy attacks.

2. **Access Control**: Strengthening access control mechanisms is necessary to ensure that only authorized users can execute sensitive functions. This includes implementing role-based access control or multi-signature requirements for critical operations.

3. **Gas Limit Considerations**: Functions that may involve loops should be optimized or designed to handle larger datasets without exceeding gas limits. This could involve batching operations or limiting the number of iterations.

4. **Error Handling**: A more comprehensive error handling strategy should be employed to ensure that all potential failure points are accounted for, reducing the risk of unexpected behavior.

5. **Event Emissions**: Ensuring that all state-changing functions emit appropriate events will enhance transparency and allow for better tracking of contract activity.

6. **Token Transfer Checks**: Implementing checks for token transfer success will prevent scenarios where funds are lost due to failed transfers.

7. **Front-Running Mitigation**: Consider implementing mechanisms to mitigate front-running risks, such as commit-reveal schemes or time-locks on sensitive operations.

In conclusion, while the `PCLClosedStage` contract is well-structured, addressing the identified vulnerabilities will significantly enhance its security posture and reliability. A thorough audit and testing phase should be conducted before deployment to ensure that all potential risks are mitigated.

[2024-27-08 09:28:48 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-27-08 09:28:48 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      // The below function will create the PCL request and then lenders lend the entire requested amount     (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      borrowAndRepay(requestId);      // Now the PCL should be in the CLOSED state     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function borrowAndRepay(uint256 _id) public {     // Now we assert that we are in the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_id, _requiredCollateral, false);     }      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);     // And borrows the borrowable amount     borrower.borrow(_id, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(_id);     // Borrower decides to repay the entire debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);     borrower.repay(_id, currentDebt); }  /************************************************************************************************************************************* Start function calls *************************************************************************************************************************************/  function assert_start_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.start(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1'); }  function test_borrowerCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1'); }  function test_lenderCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in closed state',         'LP:S1'     ); }  /************************************************************************************************************************************* Cancel function calls *************************************************************************************************************************************/  function assert_cancel_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1'); }  function test_lenderCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot cancel a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Close function calls *************************************************************************************************************************************/  function assert_close_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1'); }  function test_lenderCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a closed PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the CLOSED state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAClosedPCL() public {     assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInClosedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2'); }  function test_borrowerCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2'); }  function test_lenderCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2'); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public virtual {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCanWithdrawCollateral() public {     // The below function will create the PCL request and then lenders lend the entire requested amount     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     borrowAndRepay(_id);     vm.warp(block.timestamp + request.duration.mul(110).div(100));     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     if (request.collateralRatio != 0) {         assertGt(_withdrawableCollateral, 0);         borrower.withdrawAllCollateral(_id, false);     }     uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));     assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         admin,         false,         'Admin cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         borrower,         false,         'Borrower cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot liquidate a closed PCL',         'PCL:L1'     ); }  /************************************************************************************************************************************* WithdrawInterest function calls **************************************************************************************************************************************/  function assert_withdraw_interest_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1'); }  function test_lenderCanWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user != admin) {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.terminate(_id);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     } }  function test_adminCanTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         borrower,         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _toInterestOwed; uint256 _fromInterestOwed; uint256 _fromBorrowTokenBalanceInitial; uint256 _toBorrowTokenBalanceInitial;  /************************************************************************************************************************************** Pool MockToken Transfer function tests **************************************************************************************************************************************/  function assert_pool_token_transfer_in_closed_stage(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));         _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));          _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));         _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));          _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));          assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);         assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  function test_poolTokenTransferComplete() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         1,         '',         ''     ); }  function test_poolTokenTransferPartial() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         4,         '',         ''     ); }  function test_poolTokenTransferToNonVerifiedUser() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         admin,         false,         4,         'Non-verified user should not be able to receive pool tokens',         'LP:IT3'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      uint256 _startBalance = borrowAsset.balanceOf(address(_lender));     _lender.withdrawInterest(requestId);     uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));     assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);      vm.warp(block.timestamp + request.duration);     borrower.close(_requestId);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  /************************************************************************************************************************************** View/calculation function tests **************************************************************************************************************************************/  function assert_helper_functionalities_in_closed_state(     uint256 _id,     PCLUser _lender,     PCLUser _borrower ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertGe(_principalWithdrawable, _userLiquidity);     _lender.withdrawLiquidity(_id);     uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));     assertGe(newBalance, _userLiquidity);      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());     assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0); // Since PCL is closed now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment      // 6. calculateCurrentDebt     uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off      // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1     // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws      // 7. calculateCurrentCollateralRatio     try _borrower.calculateCurrentCollateralRatio(_id) {         uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     }      // 8. collateralTokensToLiquidate     try _borrower.collateralTokensToLiquidate(_id, 0) {         uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);         assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     } }  function test_helperFunctionInClosedState() public {     assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../Helpers/PCLParent.t.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\n\ncontract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n\n    uint256 requestId;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        request.borrowLimit = uint128(1_000_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * 1e18) / 1e2);\n        request.collateralRatio = 1e18;\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * 1e18) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        // The below function will create the PCL request and then lenders lend the entire requested amount\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        borrowAndRepay(requestId);\n\n        // Now the PCL should be in the CLOSED state\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function borrowAndRepay(uint256 _id) public {\n        // Now we assert that we are in the ACTIVE state\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_id, _requiredCollateral, false);\n        }\n\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);\n        // And borrows the borrowable amount\n        borrower.borrow(_id, borrowableAmount);\n\n        // Borrower decides to repay everything at mid-duration\n\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(_id);\n        // Borrower decides to repay the entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);\n        borrower.repay(_id, currentDebt);\n    }\n\n    /*******************\n    Start function calls\n    *******************/\n\n    function assert_start_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.start(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');\n    }\n\n    function test_borrowerCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');\n    }\n\n    function test_lenderCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot start a PCL in closed state',\n            'LP:S1'\n        );\n    }\n\n    /*******************\n    Cancel function calls\n    *******************/\n\n    function assert_cancel_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');\n    }\n\n    function test_lenderCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot cancel a PCL in closed state',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Close function calls\n    *******************/\n\n    function assert_close_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');\n    }\n\n    function test_lenderCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot close a closed PCL',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Deposit collateral function calls\n    *******************/\n\n    function assert_collateralCannotBeDepositedInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n\n        try _depositor.depositCollateral(_id, _amount, false) {\n            revert('Collateral cannot be deposited in the CLOSED state');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:DC2');\n        }\n    }\n\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);\n    }\n\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);\n    }\n\n    /*******************\n    Borrow function tests\n    *******************/\n\n    function assertBorrowFunctionalityInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotBorrowAClosedPCL() public {\n        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');\n    }\n\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');\n    }\n\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInClosedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot borrow a PCL in closed state',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Repay function tests\n    *******************/\n\n    function assertRepayFunctionalityInClosedState(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');\n    }\n\n    function test_borrowerCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');\n    }\n\n    function test_lenderCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');\n    }\n\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n\n    function assertWithdrawCollateralFunctionalityInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public virtual {\n        if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawAllCollateral(_id, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertGe(_balanceAfter, _balanceBefore);\n        } else {\n            try _user.withdrawAllCollateral(_id, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessageAll);\n            }\n        }\n\n        if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawCollateral(_id, _amount, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);\n        } else {\n            try _user.withdrawCollateral(_id, _amount, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            admin,\n            'Admin cannot withdraw collateral in closed state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            borrower,\n            'Borrower cannot withdraw collateral in closed state',\n            'PCL:WC1',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            0,\n            borrower,\n            'Borrower cannot withdraw collateral in closed state',\n            'PCL:WC2',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot withdraw collateral in closed state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCanWithdrawCollateral() public {\n        // The below function will create the PCL request and then lenders lend the entire requested amount\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        borrowAndRepay(_id);\n        vm.warp(block.timestamp + request.duration.mul(110).div(100));\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n\n        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);\n        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);\n        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));\n        if (request.collateralRatio != 0) {\n            assertGt(_withdrawableCollateral, 0);\n            borrower.withdrawAllCollateral(_id, false);\n        }\n        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));\n        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);\n    }\n\n    /*******************\n    WithdrawLiquidity function calls\n    *******************/\n\n    function assert_withdraw_liquidity_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));\n            _user.withdrawLiquidity(_id);\n            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));\n\n            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);\n            assertEq(_poolTokenBalanceNew, 0);\n        } else {\n            try _user.withdrawLiquidity(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(\n            requestId,\n            admin,\n            false,\n            'Admin cannot WithdrawLiquidity a PCL in closed state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(\n            requestId,\n            borrower,\n            false,\n            'Borrower cannot WithdrawLiquidity a PCL in closed state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');\n    }\n\n    /*******************\n    Liquidate function tests\n    *******************/\n\n    function assert_liquidate_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');\n    }\n\n    function test_borrowerCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');\n    }\n\n    function test_lenderCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot liquidate a closed PCL',\n            'PCL:L1'\n        );\n    }\n\n    /********************\n    WithdrawInterest function calls\n    ********************/\n\n    function assert_withdraw_interest_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);\n            }\n\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');\n    }\n\n    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');\n    }\n\n    function test_lenderCanWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');\n    }\n\n    /********************\n    Terminate function tests\n    ********************/\n\n    function assert_terminate_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_user != admin) {\n            try _user.terminate(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _user.terminate(_id);\n            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        }\n    }\n\n    function test_adminCanTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');\n    }\n\n    function test_borrowerCannotTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(\n            requestId,\n            borrower,\n            'Should not be able to terminate a closed PCL',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    function test_lenderCannotTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Should not be able to terminate a closed PCL',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    uint256 _fromUserPoolTokenSupplyOld;\n    uint256 _toUserPoolTokenSupplyOld;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _toInterestOwed;\n    uint256 _fromInterestOwed;\n    uint256 _fromBorrowTokenBalanceInitial;\n    uint256 _toBorrowTokenBalanceInitial;\n\n    /********************\n    Pool MockToken Transfer function tests\n    ********************/\n\n    function assert_pool_token_transfer_in_closed_stage(\n        uint256 _id,\n        PCLUser _fromUser,\n        PCLUser _toUser,\n        bool _positiveCase,\n        uint256 _fractionOfPTSupply,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n\n        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);\n        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);\n\n        if (_positiveCase) {\n            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));\n            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));\n\n            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));\n            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));\n\n            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));\n\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n\n            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));\n            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));\n\n            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);\n            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);\n        } else {\n            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n\n            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);\n            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);\n        }\n    }\n\n    function test_poolTokenTransferComplete() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            PCLUser(lenders[1].lenderAddress),\n            true,\n            1,\n            '',\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartial() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            PCLUser(lenders[1].lenderAddress),\n            true,\n            4,\n            '',\n            ''\n        );\n    }\n\n    function test_poolTokenTransferToNonVerifiedUser() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            admin,\n            false,\n            4,\n            'Non-verified user should not be able to receive pool tokens',\n            'LP:IT3'\n        );\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert('External user cannot create');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert('External user cannot terminate');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert('Lender cannot lend zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L1');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Unverified lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L2');\n        }\n    }\n\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    function test_lenderCannotWithdrawZeroInterest() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertGt(_lenderInterestOwed, 0);\n\n        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));\n        _lender.withdrawInterest(requestId);\n        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));\n        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);\n        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertEq(_lenderInterestOwed, 0);\n\n        try _lender.withdrawInterest(requestId) {\n            revert('Lender cannot withdraw zero interest');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:WI1');\n        }\n    }\n\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert('Non lender cannot withdraw liquidated collateral tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:WLC1');\n        }\n    }\n\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert('Lender cannot withdraw liquidated collateral tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    function test_cannotTransferLPTokensToSameAddress() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert('Lender cannot transfer LP tokens to itself');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT1');\n        }\n    }\n\n    function test_cannotTransferLPTokensToBorrower() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {\n            revert('Lender cannot transfer LP tokens to borrower');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT2');\n        }\n    }\n\n    function test_cannotBurnPoolTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert('Lender cannot burn LP tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'ERC1155: transfer to the zero address');\n        }\n    }\n\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n\n        vm.warp(block.timestamp + request.duration);\n        borrower.close(_requestId);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);\n\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n\n        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {\n            revert('Lender cannot transfer non transferable LP tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT5');\n        }\n    }\n\n    /********************\n    View/calculation function tests\n    ********************/\n\n    function assert_helper_functionalities_in_closed_state(\n        uint256 _id,\n        PCLUser _lender,\n        PCLUser _borrower\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n\n        // 1. calculatePrincipalWithdrawable\n        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);\n        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertGe(_principalWithdrawable, _userLiquidity);\n        _lender.withdrawLiquidity(_id);\n        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));\n        assertGe(newBalance, _userLiquidity);\n\n        // 2. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        uint256 _oneUnitOfCollateral = 10(ERC20(address(collateralAsset)).decimals());\n        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);\n\n        // 3.calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);\n\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0); // Since PCL is closed now\n\n        // 5. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment\n\n        // 6. calculateCurrentDebt\n        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off\n\n        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1\n        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws\n\n        // 7. calculateCurrentCollateralRatio\n        try _borrower.calculateCurrentCollateralRatio(_id) {\n            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:IGUPT1');\n        }\n\n        // 8. collateralTokensToLiquidate\n        try _borrower.collateralTokensToLiquidate(_id, 0) {\n            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);\n            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:IGUPT1');\n        }\n    }\n\n    function test_helperFunctionInClosedState() public {\n        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:28:48 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      // The below function will create the PCL request and then lenders lend the entire requested amount     (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      borrowAndRepay(requestId);      // Now the PCL should be in the CLOSED state     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function borrowAndRepay(uint256 _id) public {     // Now we assert that we are in the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_id, _requiredCollateral, false);     }      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);     // And borrows the borrowable amount     borrower.borrow(_id, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(_id);     // Borrower decides to repay the entire debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);     borrower.repay(_id, currentDebt); }  /************************************************************************************************************************************* Start function calls *************************************************************************************************************************************/  function assert_start_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.start(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1'); }  function test_borrowerCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1'); }  function test_lenderCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in closed state',         'LP:S1'     ); }  /************************************************************************************************************************************* Cancel function calls *************************************************************************************************************************************/  function assert_cancel_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1'); }  function test_lenderCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot cancel a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Close function calls *************************************************************************************************************************************/  function assert_close_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1'); }  function test_lenderCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a closed PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the CLOSED state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAClosedPCL() public {     assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInClosedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2'); }  function test_borrowerCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2'); }  function test_lenderCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2'); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public virtual {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCanWithdrawCollateral() public {     // The below function will create the PCL request and then lenders lend the entire requested amount     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     borrowAndRepay(_id);     vm.warp(block.timestamp + request.duration.mul(110).div(100));     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     if (request.collateralRatio != 0) {         assertGt(_withdrawableCollateral, 0);         borrower.withdrawAllCollateral(_id, false);     }     uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));     assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         admin,         false,         'Admin cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         borrower,         false,         'Borrower cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot liquidate a closed PCL',         'PCL:L1'     ); }  /************************************************************************************************************************************* WithdrawInterest function calls **************************************************************************************************************************************/  function assert_withdraw_interest_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1'); }  function test_lenderCanWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user != admin) {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.terminate(_id);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     } }  function test_adminCanTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         borrower,         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _toInterestOwed; uint256 _fromInterestOwed; uint256 _fromBorrowTokenBalanceInitial; uint256 _toBorrowTokenBalanceInitial;  /************************************************************************************************************************************** Pool MockToken Transfer function tests **************************************************************************************************************************************/  function assert_pool_token_transfer_in_closed_stage(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));         _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));          _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));         _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));          _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));          assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);         assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  function test_poolTokenTransferComplete() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         1,         '',         ''     ); }  function test_poolTokenTransferPartial() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         4,         '',         ''     ); }  function test_poolTokenTransferToNonVerifiedUser() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         admin,         false,         4,         'Non-verified user should not be able to receive pool tokens',         'LP:IT3'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      uint256 _startBalance = borrowAsset.balanceOf(address(_lender));     _lender.withdrawInterest(requestId);     uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));     assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);      vm.warp(block.timestamp + request.duration);     borrower.close(_requestId);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  /************************************************************************************************************************************** View/calculation function tests **************************************************************************************************************************************/  function assert_helper_functionalities_in_closed_state(     uint256 _id,     PCLUser _lender,     PCLUser _borrower ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertGe(_principalWithdrawable, _userLiquidity);     _lender.withdrawLiquidity(_id);     uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));     assertGe(newBalance, _userLiquidity);      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());     assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0); // Since PCL is closed now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment      // 6. calculateCurrentDebt     uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off      // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1     // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws      // 7. calculateCurrentCollateralRatio     try _borrower.calculateCurrentCollateralRatio(_id) {         uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     }      // 8. collateralTokensToLiquidate     try _borrower.collateralTokensToLiquidate(_id, 0) {         uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);         assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     } }  function test_helperFunctionInClosedState() public {     assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:28:48 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:28:51 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:28:51 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16421
completion_tokens: 1
total_tokens: 16422
cost: $-1.000000


[2024-27-08 09:28:51 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
.]

###

[2024-27-08 09:28:51 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:28:51 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-27-08 09:28:51 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      // The below function will create the PCL request and then lenders lend the entire requested amount     (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      borrowAndRepay(requestId);      // Now the PCL should be in the CLOSED state     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function borrowAndRepay(uint256 _id) public {     // Now we assert that we are in the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_id, _requiredCollateral, false);     }      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);     // And borrows the borrowable amount     borrower.borrow(_id, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(_id);     // Borrower decides to repay the entire debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);     borrower.repay(_id, currentDebt); }  /************************************************************************************************************************************* Start function calls *************************************************************************************************************************************/  function assert_start_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.start(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1'); }  function test_borrowerCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1'); }  function test_lenderCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in closed state',         'LP:S1'     ); }  /************************************************************************************************************************************* Cancel function calls *************************************************************************************************************************************/  function assert_cancel_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1'); }  function test_lenderCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot cancel a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Close function calls *************************************************************************************************************************************/  function assert_close_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1'); }  function test_lenderCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a closed PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the CLOSED state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAClosedPCL() public {     assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInClosedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2'); }  function test_borrowerCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2'); }  function test_lenderCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2'); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public virtual {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCanWithdrawCollateral() public {     // The below function will create the PCL request and then lenders lend the entire requested amount     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     borrowAndRepay(_id);     vm.warp(block.timestamp + request.duration.mul(110).div(100));     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     if (request.collateralRatio != 0) {         assertGt(_withdrawableCollateral, 0);         borrower.withdrawAllCollateral(_id, false);     }     uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));     assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         admin,         false,         'Admin cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         borrower,         false,         'Borrower cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot liquidate a closed PCL',         'PCL:L1'     ); }  /************************************************************************************************************************************* WithdrawInterest function calls **************************************************************************************************************************************/  function assert_withdraw_interest_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1'); }  function test_lenderCanWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user != admin) {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.terminate(_id);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     } }  function test_adminCanTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         borrower,         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _toInterestOwed; uint256 _fromInterestOwed; uint256 _fromBorrowTokenBalanceInitial; uint256 _toBorrowTokenBalanceInitial;  /************************************************************************************************************************************** Pool MockToken Transfer function tests **************************************************************************************************************************************/  function assert_pool_token_transfer_in_closed_stage(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));         _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));          _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));         _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));          _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));          assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);         assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  function test_poolTokenTransferComplete() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         1,         '',         ''     ); }  function test_poolTokenTransferPartial() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         4,         '',         ''     ); }  function test_poolTokenTransferToNonVerifiedUser() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         admin,         false,         4,         'Non-verified user should not be able to receive pool tokens',         'LP:IT3'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      uint256 _startBalance = borrowAsset.balanceOf(address(_lender));     _lender.withdrawInterest(requestId);     uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));     assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);      vm.warp(block.timestamp + request.duration);     borrower.close(_requestId);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  /************************************************************************************************************************************** View/calculation function tests **************************************************************************************************************************************/  function assert_helper_functionalities_in_closed_state(     uint256 _id,     PCLUser _lender,     PCLUser _borrower ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertGe(_principalWithdrawable, _userLiquidity);     _lender.withdrawLiquidity(_id);     uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));     assertGe(newBalance, _userLiquidity);      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());     assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0); // Since PCL is closed now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment      // 6. calculateCurrentDebt     uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off      // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1     // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws      // 7. calculateCurrentCollateralRatio     try _borrower.calculateCurrentCollateralRatio(_id) {         uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     }      // 8. collateralTokensToLiquidate     try _borrower.collateralTokensToLiquidate(_id, 0) {         uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);         assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     } }  function test_helperFunctionInClosedState() public {     assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:28:51 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      // The below function will create the PCL request and then lenders lend the entire requested amount     (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      borrowAndRepay(requestId);      // Now the PCL should be in the CLOSED state     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function borrowAndRepay(uint256 _id) public {     // Now we assert that we are in the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_id, _requiredCollateral, false);     }      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);     // And borrows the borrowable amount     borrower.borrow(_id, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(_id);     // Borrower decides to repay the entire debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);     borrower.repay(_id, currentDebt); }  /************************************************************************************************************************************* Start function calls *************************************************************************************************************************************/  function assert_start_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.start(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1'); }  function test_borrowerCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1'); }  function test_lenderCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in closed state',         'LP:S1'     ); }  /************************************************************************************************************************************* Cancel function calls *************************************************************************************************************************************/  function assert_cancel_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1'); }  function test_lenderCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot cancel a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Close function calls *************************************************************************************************************************************/  function assert_close_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1'); }  function test_lenderCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a closed PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the CLOSED state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAClosedPCL() public {     assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInClosedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2'); }  function test_borrowerCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2'); }  function test_lenderCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2'); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public virtual {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCanWithdrawCollateral() public {     // The below function will create the PCL request and then lenders lend the entire requested amount     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     borrowAndRepay(_id);     vm.warp(block.timestamp + request.duration.mul(110).div(100));     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     if (request.collateralRatio != 0) {         assertGt(_withdrawableCollateral, 0);         borrower.withdrawAllCollateral(_id, false);     }     uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));     assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         admin,         false,         'Admin cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         borrower,         false,         'Borrower cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot liquidate a closed PCL',         'PCL:L1'     ); }  /************************************************************************************************************************************* WithdrawInterest function calls **************************************************************************************************************************************/  function assert_withdraw_interest_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1'); }  function test_lenderCanWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user != admin) {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.terminate(_id);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     } }  function test_adminCanTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         borrower,         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _toInterestOwed; uint256 _fromInterestOwed; uint256 _fromBorrowTokenBalanceInitial; uint256 _toBorrowTokenBalanceInitial;  /************************************************************************************************************************************** Pool MockToken Transfer function tests **************************************************************************************************************************************/  function assert_pool_token_transfer_in_closed_stage(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));         _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));          _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));         _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));          _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));          assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);         assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  function test_poolTokenTransferComplete() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         1,         '',         ''     ); }  function test_poolTokenTransferPartial() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         4,         '',         ''     ); }  function test_poolTokenTransferToNonVerifiedUser() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         admin,         false,         4,         'Non-verified user should not be able to receive pool tokens',         'LP:IT3'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      uint256 _startBalance = borrowAsset.balanceOf(address(_lender));     _lender.withdrawInterest(requestId);     uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));     assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);      vm.warp(block.timestamp + request.duration);     borrower.close(_requestId);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  /************************************************************************************************************************************** View/calculation function tests **************************************************************************************************************************************/  function assert_helper_functionalities_in_closed_state(     uint256 _id,     PCLUser _lender,     PCLUser _borrower ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertGe(_principalWithdrawable, _userLiquidity);     _lender.withdrawLiquidity(_id);     uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));     assertGe(newBalance, _userLiquidity);      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());     assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0); // Since PCL is closed now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment      // 6. calculateCurrentDebt     uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off      // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1     // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws      // 7. calculateCurrentCollateralRatio     try _borrower.calculateCurrentCollateralRatio(_id) {         uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     }      // 8. collateralTokensToLiquidate     try _borrower.collateralTokensToLiquidate(_id, 0) {         uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);         assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     } }  function test_helperFunctionInClosedState() public {     assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:28:51 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:29:01 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:29:01 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8270
completion_tokens: 690
total_tokens: 8960
cost: $-1.000000


[2024-27-08 09:29:01 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
.]

Based on the provided smart contract code for the `PCLClosedStage` contract, here is a succinct summary of the security vulnerabilities identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Attacks**: 
   - The contract does not implement any reentrancy guards, which could allow malicious users to exploit functions that transfer tokens or modify state variables.

2. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, it is essential to ensure that all arithmetic operations are consistently protected against overflow and underflow, especially in custom calculations.

3. **Access Control Issues**:
   - The contract allows certain functions to be called by users who should not have access, particularly in the context of state transitions (e.g., starting, canceling, or closing a PCL in an inappropriate state). Proper access control mechanisms should be enforced.

4. **Error Handling**:
   - The contract relies heavily on `try/catch` statements for error handling, which can lead to unexpected behavior if not properly managed. It is crucial to ensure that all revert messages are clear and provide meaningful feedback.

5. **Token Transfer Logic**:
   - The logic for transferring tokens, especially in functions like `withdrawLiquidity`, does not check for the success of the transfer operation. This can lead to situations where tokens are not transferred as expected.

6. **Gas Limit Issues**:
   - Functions that involve loops or extensive calculations may run into gas limit issues, especially if the number of lenders or collateral amounts is large. This could lead to transaction failures.

7. **Lack of Event Emissions**:
   - Important state changes and actions (like borrowing, repaying, or closing a PCL) should emit events to provide transparency and allow for easier tracking of contract activity.

8. **Potential for Denial of Service (DoS)**:
   - Certain functions may be susceptible to DoS attacks if a malicious user can manipulate the state or conditions under which other users can interact with the contract.

### Comprehensive Analysis Report:

The `PCLClosedStage` contract exhibits several security vulnerabilities that could be exploited by malicious actors, potentially leading to financial loss or unintended behavior. The absence of reentrancy guards poses a significant risk, especially in functions that involve token transfers. While `SafeMath` is utilized, ensuring consistent protection against arithmetic errors is crucial.

Access control mechanisms must be strengthened to prevent unauthorized users from executing critical functions that alter the contract's state. Additionally, the reliance on `try/catch` for error handling could lead to ambiguous outcomes if not managed correctly.

The token transfer logic should be fortified to ensure that all transfers are successful, and gas limit considerations should be taken into account to prevent transaction failures. The lack of event emissions for critical actions undermines the contract's transparency and traceability.

To mitigate these vulnerabilities, it is recommended to implement the following measures:

- Introduce reentrancy guards in critical functions.
- Ensure all arithmetic operations are safeguarded with `SafeMath`.
- Enforce strict access control using modifiers.
- Improve error handling with clear revert messages.
- Validate the success of token transfers and handle failures appropriately.
- Optimize functions to avoid gas limit issues.
- Emit events for significant state changes and actions.

By addressing these vulnerabilities, the security and reliability of the `PCLClosedStage` contract can be significantly enhanced, fostering trust and confidence among users.

[2024-27-08 09:29:01 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `PCLClosedStage` contract, here is a succinct summary of the security vulnerabilities identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Attacks**: 
   - The contract does not implement any reentrancy guards, which could allow malicious users to exploit functions that transfer tokens or modify state variables.

2. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, it is essential to ensure that all arithmetic operations are consistently protected against overflow and underflow, especially in custom calculations.

3. **Access Control Issues**:
   - The contract allows certain functions to be called by users who should not have access, particularly in the context of state transitions (e.g., starting, canceling, or closing a PCL in an inappropriate state). Proper access control mechanisms should be enforced.

4. **Error Handling**:
   - The contract relies heavily on `try/catch` statements for error handling, which can lead to unexpected behavior if not properly managed. It is crucial to ensure that all revert messages are clear and provide meaningful feedback.

5. **Token Transfer Logic**:
   - The logic for transferring tokens, especially in functions like `withdrawLiquidity`, does not check for the success of the transfer operation. This can lead to situations where tokens are not transferred as expected.

6. **Gas Limit Issues**:
   - Functions that involve loops or extensive calculations may run into gas limit issues, especially if the number of lenders or collateral amounts is large. This could lead to transaction failures.

7. **Lack of Event Emissions**:
   - Important state changes and actions (like borrowing, repaying, or closing a PCL) should emit events to provide transparency and allow for easier tracking of contract activity.

8. **Potential for Denial of Service (DoS)**:
   - Certain functions may be susceptible to DoS attacks if a malicious user can manipulate the state or conditions under which other users can interact with the contract.

### Comprehensive Analysis Report:

The `PCLClosedStage` contract exhibits several security vulnerabilities that could be exploited by malicious actors, potentially leading to financial loss or unintended behavior. The absence of reentrancy guards poses a significant risk, especially in functions that involve token transfers. While `SafeMath` is utilized, ensuring consistent protection against arithmetic errors is crucial.

Access control mechanisms must be strengthened to prevent unauthorized users from executing critical functions that alter the contract's state. Additionally, the reliance on `try/catch` for error handling could lead to ambiguous outcomes if not managed correctly.

The token transfer logic should be fortified to ensure that all transfers are successful, and gas limit considerations should be taken into account to prevent transaction failures. The lack of event emissions for critical actions undermines the contract's transparency and traceability.

To mitigate these vulnerabilities, it is recommended to implement the following measures:

- Introduce reentrancy guards in critical functions.
- Ensure all arithmetic operations are safeguarded with `SafeMath`.
- Enforce strict access control using modifiers.
- Improve error handling with clear revert messages.
- Validate the success of token transfers and handle failures appropriately.
- Optimize functions to avoid gas limit issues.
- Emit events for significant state changes and actions.

By addressing these vulnerabilities, the security and reliability of the `PCLClosedStage` contract can be significantly enhanced, fostering trust and confidence among users.

[2024-27-08 09:29:04 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      // The below function will create the PCL request and then lenders lend the entire requested amount     (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      borrowAndRepay(requestId);      // Now the PCL should be in the CLOSED state     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function borrowAndRepay(uint256 _id) public {     // Now we assert that we are in the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_id, _requiredCollateral, false);     }      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);     // And borrows the borrowable amount     borrower.borrow(_id, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(_id);     // Borrower decides to repay the entire debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);     borrower.repay(_id, currentDebt); }  /************************************************************************************************************************************* Start function calls *************************************************************************************************************************************/  function assert_start_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.start(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1'); }  function test_borrowerCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1'); }  function test_lenderCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in closed state',         'LP:S1'     ); }  /************************************************************************************************************************************* Cancel function calls *************************************************************************************************************************************/  function assert_cancel_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1'); }  function test_lenderCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot cancel a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Close function calls *************************************************************************************************************************************/  function assert_close_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1'); }  function test_lenderCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a closed PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the CLOSED state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAClosedPCL() public {     assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInClosedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2'); }  function test_borrowerCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2'); }  function test_lenderCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2'); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public virtual {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCanWithdrawCollateral() public {     // The below function will create the PCL request and then lenders lend the entire requested amount     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     borrowAndRepay(_id);     vm.warp(block.timestamp + request.duration.mul(110).div(100));     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     if (request.collateralRatio != 0) {         assertGt(_withdrawableCollateral, 0);         borrower.withdrawAllCollateral(_id, false);     }     uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));     assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         admin,         false,         'Admin cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         borrower,         false,         'Borrower cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot liquidate a closed PCL',         'PCL:L1'     ); }  /************************************************************************************************************************************* WithdrawInterest function calls **************************************************************************************************************************************/  function assert_withdraw_interest_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1'); }  function test_lenderCanWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user != admin) {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.terminate(_id);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     } }  function test_adminCanTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         borrower,         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _toInterestOwed; uint256 _fromInterestOwed; uint256 _fromBorrowTokenBalanceInitial; uint256 _toBorrowTokenBalanceInitial;  /************************************************************************************************************************************** Pool MockToken Transfer function tests **************************************************************************************************************************************/  function assert_pool_token_transfer_in_closed_stage(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));         _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));          _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));         _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));          _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));          assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);         assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  function test_poolTokenTransferComplete() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         1,         '',         ''     ); }  function test_poolTokenTransferPartial() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         4,         '',         ''     ); }  function test_poolTokenTransferToNonVerifiedUser() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         admin,         false,         4,         'Non-verified user should not be able to receive pool tokens',         'LP:IT3'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      uint256 _startBalance = borrowAsset.balanceOf(address(_lender));     _lender.withdrawInterest(requestId);     uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));     assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);      vm.warp(block.timestamp + request.duration);     borrower.close(_requestId);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  /************************************************************************************************************************************** View/calculation function tests **************************************************************************************************************************************/  function assert_helper_functionalities_in_closed_state(     uint256 _id,     PCLUser _lender,     PCLUser _borrower ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertGe(_principalWithdrawable, _userLiquidity);     _lender.withdrawLiquidity(_id);     uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));     assertGe(newBalance, _userLiquidity);      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());     assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0); // Since PCL is closed now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment      // 6. calculateCurrentDebt     uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off      // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1     // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws      // 7. calculateCurrentCollateralRatio     try _borrower.calculateCurrentCollateralRatio(_id) {         uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     }      // 8. collateralTokensToLiquidate     try _borrower.collateralTokensToLiquidate(_id, 0) {         uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);         assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     } }  function test_helperFunctionInClosedState() public {     assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../Helpers/PCLParent.t.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\n\ncontract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n\n    uint256 requestId;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        request.borrowLimit = uint128(1_000_000 * 10(ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * 1e18) / 1e2);\n        request.collateralRatio = 1e18;\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * 1e18) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        // The below function will create the PCL request and then lenders lend the entire requested amount\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        borrowAndRepay(requestId);\n\n        // Now the PCL should be in the CLOSED state\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function borrowAndRepay(uint256 _id) public {\n        // Now we assert that we are in the ACTIVE state\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        if (request.collateralRatio != 0) {\n            borrower.depositCollateral(_id, _requiredCollateral, false);\n        }\n\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);\n        // And borrows the borrowable amount\n        borrower.borrow(_id, borrowableAmount);\n\n        // Borrower decides to repay everything at mid-duration\n\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(_id);\n        // Borrower decides to repay the entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);\n        borrower.repay(_id, currentDebt);\n    }\n\n    /*******************\n    Start function calls\n    *******************/\n\n    function assert_start_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.start(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');\n    }\n\n    function test_borrowerCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');\n    }\n\n    function test_lenderCannotStartAClosedPCL() public {\n        assert_start_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot start a PCL in closed state',\n            'LP:S1'\n        );\n    }\n\n    /*******************\n    Cancel function calls\n    *******************/\n\n    function assert_cancel_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.cancelRequest(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');\n    }\n\n    function test_lenderCannotCancelAClosedPCL() public {\n        assert_cancel_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot cancel a PCL in closed state',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Close function calls\n    *******************/\n\n    function assert_close_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.close(_id) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');\n    }\n\n    function test_lenderCannotCloseAClosedPCL() public {\n        assert_close_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot close a closed PCL',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Deposit collateral function calls\n    *******************/\n\n    function assert_collateralCannotBeDepositedInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _depositor,\n        bool _isDepositorLender\n    ) public {\n        if (_isDepositorLender) {\n            _depositor = PCLUser(lenders[0].lenderAddress);\n        }\n\n        admin.transferToken(address(collateralAsset), address(_depositor), _amount);\n        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);\n\n        try _depositor.depositCollateral(_id, _amount, false) {\n            revert('Collateral cannot be deposited in the CLOSED state');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:DC2');\n        }\n    }\n\n    function test_borrowerCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);\n    }\n\n    function test_lenderCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);\n    }\n\n    function test_adminCannotDepositCollateral() public {\n        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();\n        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);\n    }\n\n    /*******************\n    Borrow function tests\n    *******************/\n\n    function assertBorrowFunctionalityInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.borrow(_id, _amount) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotBorrow() public {\n        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');\n    }\n\n    function test_borrowerCannotBorrowAClosedPCL() public {\n        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');\n    }\n\n    function test_borrowerCannotBorrowZeroAmount() public {\n        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');\n    }\n\n    function test_lenderCannotBorrow() public {\n        assertBorrowFunctionalityInClosedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot borrow a PCL in closed state',\n            'PCL:OCLB1'\n        );\n    }\n\n    /*******************\n    Repay function tests\n    *******************/\n\n    function assertRepayFunctionalityInClosedState(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.repay(_id, 1) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');\n    }\n\n    function test_borrowerCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');\n    }\n\n    function test_lenderCannotRepayAClosedPCL() public {\n        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');\n    }\n\n    /*******************\n    Withdraw collateral function tests\n    *******************/\n\n    function assertWithdrawCollateralFunctionalityInClosedState(\n        uint256 _id,\n        uint256 _amount,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage,\n        string memory _errorMessageAll\n    ) public virtual {\n        if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawAllCollateral(_id, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertGe(_balanceAfter, _balanceBefore);\n        } else {\n            try _user.withdrawAllCollateral(_id, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessageAll);\n            }\n        }\n\n        if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {\n            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));\n            _user.withdrawCollateral(_id, _amount, false);\n            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));\n            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);\n        } else {\n            try _user.withdrawCollateral(_id, _amount, false) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            admin,\n            'Admin cannot withdraw collateral in closed state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            borrower,\n            'Borrower cannot withdraw collateral in closed state',\n            'PCL:WC1',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawZeroCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            0,\n            borrower,\n            'Borrower cannot withdraw collateral in closed state',\n            'PCL:WC2',\n            'PCL:WAC1'\n        );\n    }\n\n    function test_lenderCannotWithdrawCollateral() public {\n        assertWithdrawCollateralFunctionalityInClosedState(\n            requestId,\n            1,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot withdraw collateral in closed state',\n            'PCL:OCLB1',\n            'PCL:OCLB1'\n        );\n    }\n\n    function test_borrowerCanWithdrawCollateral() public {\n        // The below function will create the PCL request and then lenders lend the entire requested amount\n        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);\n        borrowAndRepay(_id);\n        vm.warp(block.timestamp + request.duration.mul(110).div(100));\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n\n        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);\n        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);\n        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));\n        if (request.collateralRatio != 0) {\n            assertGt(_withdrawableCollateral, 0);\n            borrower.withdrawAllCollateral(_id, false);\n        }\n        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));\n        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);\n    }\n\n    /*******************\n    WithdrawLiquidity function calls\n    *******************/\n\n    function assert_withdraw_liquidity_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        bool _positiveCase,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_positiveCase) {\n            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));\n            _user.withdrawLiquidity(_id);\n            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);\n            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));\n\n            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);\n            assertEq(_poolTokenBalanceNew, 0);\n        } else {\n            try _user.withdrawLiquidity(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(\n            requestId,\n            admin,\n            false,\n            'Admin cannot WithdrawLiquidity a PCL in closed state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(\n            requestId,\n            borrower,\n            false,\n            'Borrower cannot WithdrawLiquidity a PCL in closed state',\n            'LP:IWL1'\n        );\n    }\n\n    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {\n        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');\n    }\n\n    /*******************\n    Liquidate function tests\n    *******************/\n\n    function assert_liquidate_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        try _user.liquidate(_id, true) {\n            revert(_revertMessage);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n    }\n\n    function test_adminCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');\n    }\n\n    function test_borrowerCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');\n    }\n\n    function test_lenderCannotLiquidateAClosedPCL() public {\n        assert_liquidate_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Lender cannot liquidate a closed PCL',\n            'PCL:L1'\n        );\n    }\n\n    /********************\n    WithdrawInterest function calls\n    ********************/\n\n    function assert_withdraw_interest_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _errorMessage\n    ) public {\n        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));\n        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));\n        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);\n\n        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));\n\n        try _user.withdrawInterest(_id) {\n            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));\n            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));\n            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);\n\n            if (_userPoolTokenBalancePreWithdraw == 0) {\n                assertEq(_lenderInterest, 0);\n                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);\n            } else {\n                assertTrue(_lenderInterest != 0);\n                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);\n            }\n\n            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);\n            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);\n        } catch Error(string memory reason) {\n            assertEq(reason, _errorMessage);\n        }\n    }\n\n    function test_adminCannotWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');\n    }\n\n    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');\n    }\n\n    function test_lenderCanWithdrawInterestFromAClosedPCL() public {\n        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');\n    }\n\n    /********************\n    Terminate function tests\n    ********************/\n\n    function assert_terminate_functionality_in_closed_state(\n        uint256 _id,\n        PCLUser _user,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        if (_user != admin) {\n            try _user.terminate(_id) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n        } else {\n            _user.terminate(_id);\n            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        }\n    }\n\n    function test_adminCanTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');\n    }\n\n    function test_borrowerCannotTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(\n            requestId,\n            borrower,\n            'Should not be able to terminate a closed PCL',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    function test_lenderCannotTerminateAClosedPCL() public {\n        assert_terminate_functionality_in_closed_state(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            'Should not be able to terminate a closed PCL',\n            'Ownable: caller is not the owner'\n        );\n    }\n\n    uint256 _fromUserPoolTokenSupplyOld;\n    uint256 _toUserPoolTokenSupplyOld;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _toInterestOwed;\n    uint256 _fromInterestOwed;\n    uint256 _fromBorrowTokenBalanceInitial;\n    uint256 _toBorrowTokenBalanceInitial;\n\n    /********************\n    Pool MockToken Transfer function tests\n    ********************/\n\n    function assert_pool_token_transfer_in_closed_stage(\n        uint256 _id,\n        PCLUser _fromUser,\n        PCLUser _toUser,\n        bool _positiveCase,\n        uint256 _fractionOfPTSupply,\n        string memory _revertMessage,\n        string memory _errorMessage\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n\n        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);\n        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);\n\n        if (_positiveCase) {\n            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));\n            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));\n\n            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));\n            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));\n\n            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));\n\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n\n            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));\n            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));\n\n            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);\n            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);\n        } else {\n            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {\n                revert(_revertMessage);\n            } catch Error(string memory reason) {\n                assertEq(reason, _errorMessage);\n            }\n\n            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);\n            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);\n\n            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);\n            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);\n        }\n    }\n\n    function test_poolTokenTransferComplete() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            PCLUser(lenders[1].lenderAddress),\n            true,\n            1,\n            '',\n            ''\n        );\n    }\n\n    function test_poolTokenTransferPartial() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            PCLUser(lenders[1].lenderAddress),\n            true,\n            4,\n            '',\n            ''\n        );\n    }\n\n    function test_poolTokenTransferToNonVerifiedUser() public {\n        assert_pool_token_transfer_in_closed_stage(\n            requestId,\n            PCLUser(lenders[0].lenderAddress),\n            admin,\n            false,\n            4,\n            'Non-verified user should not be able to receive pool tokens',\n            'LP:IT3'\n        );\n    }\n\n    function test_externalUserCannotCreate() public {\n        try\n            lp.create(\n                requestId,\n                mockAdminVerifier1,\n                address(borrowAsset),\n                noYieldAddress,\n                request.borrowLimit,\n                request.minBorrowAmount,\n                request.collectionPeriod,\n                true\n            )\n        {\n            revert('External user cannot create');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_externalUserCannotTerminate() public {\n        try lp.terminate(requestId, address(admin)) {\n            revert('External user cannot terminate');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:OPCL1');\n        }\n    }\n\n    function test_cannotLendZeroAmount() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, 0) {\n            revert('Lender cannot lend zero amount');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L1');\n        }\n    }\n\n    function test_unverifiedLenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Unverified lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L2');\n        }\n    }\n\n    function test_lenderCannotLend() public {\n        uint256 _amountToLend = 100;\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);\n        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);\n\n        try _pooledCreditLineLender.lend(requestId, _amountToLend) {\n            revert('Lender cannot lend');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:L3');\n        }\n    }\n\n    function test_lenderCannotWithdrawZeroInterest() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertGt(_lenderInterestOwed, 0);\n\n        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));\n        _lender.withdrawInterest(requestId);\n        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));\n        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);\n        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));\n        assertEq(_lenderInterestOwed, 0);\n\n        try _lender.withdrawInterest(requestId) {\n            revert('Lender cannot withdraw zero interest');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:WI1');\n        }\n    }\n\n    function test_nonLenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);\n        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);\n\n        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {\n            revert('Non lender cannot withdraw liquidated collateral tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:WLC1');\n        }\n    }\n\n    function test_lenderCannotWithdrawLiquidationTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n\n        try _lender.withdrawTokensAfterLiquidation(requestId) {\n            revert('Lender cannot withdraw liquidated collateral tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    function test_cannotTransferLPTokensToSameAddress() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {\n            revert('Lender cannot transfer LP tokens to itself');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT1');\n        }\n    }\n\n    function test_cannotTransferLPTokensToBorrower() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {\n            revert('Lender cannot transfer LP tokens to borrower');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT2');\n        }\n    }\n\n    function test_cannotBurnPoolTokens() public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);\n\n        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {\n            revert('Lender cannot burn LP tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'ERC1155: transfer to the zero address');\n        }\n    }\n\n    function test_cannotTransferNonTransferableLPTokens() public {\n        request.areTokensTransferable = false;\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n\n        vm.warp(block.timestamp + request.duration);\n        borrower.close(_requestId);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);\n\n        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);\n        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);\n        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);\n\n        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {\n            revert('Lender cannot transfer non transferable LP tokens');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IT5');\n        }\n    }\n\n    /********************\n    View/calculation function tests\n    ********************/\n\n    function assert_helper_functionalities_in_closed_state(\n        uint256 _id,\n        PCLUser _lender,\n        PCLUser _borrower\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);\n\n        // 1. calculatePrincipalWithdrawable\n        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);\n        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertGe(_principalWithdrawable, _userLiquidity);\n        _lender.withdrawLiquidity(_id);\n        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));\n        assertGe(newBalance, _userLiquidity);\n\n        // 2. withdrawableCollateral\n        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        uint256 _oneUnitOfCollateral = 10(ERC20(address(collateralAsset)).decimals());\n        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);\n\n        // 3.calculateTotalCollateralTokens\n        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);\n\n        // 4. calculateBorrowableAmount\n        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_totalBorrowable, 0); // Since PCL is closed now\n\n        // 5. calculateInterestAccrued\n        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment\n\n        // 6. calculateCurrentDebt\n        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off\n\n        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1\n        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws\n\n        // 7. calculateCurrentCollateralRatio\n        try _borrower.calculateCurrentCollateralRatio(_id) {\n            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);\n            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:IGUPT1');\n        }\n\n        // 8. collateralTokensToLiquidate\n        try _borrower.collateralTokensToLiquidate(_id, 0) {\n            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);\n            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:IGUPT1');\n        }\n    }\n\n    function test_helperFunctionInClosedState() public {\n        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);\n    }\n}\n", 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-27-08 09:29:04 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../mocks/MockToken.sol'; import '../Helpers/PCLParent.t.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256; uint256 requestId;  function setUp() public virtual override {     super.setUp();      request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * 1e18) / 1e2);     request.collateralRatio = 1e18;     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * 1e18) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      // The below function will create the PCL request and then lenders lend the entire requested amount     (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      borrowAndRepay(requestId);      // Now the PCL should be in the CLOSED state     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function borrowAndRepay(uint256 _id) public {     // Now we assert that we are in the ACTIVE state     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     if (request.collateralRatio != 0) {         borrower.depositCollateral(_id, _requiredCollateral, false);     }      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);     // And borrows the borrowable amount     borrower.borrow(_id, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(_id);     // Borrower decides to repay the entire debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);     borrower.repay(_id, currentDebt); }  /************************************************************************************************************************************* Start function calls *************************************************************************************************************************************/  function assert_start_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.start(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1'); }  function test_borrowerCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1'); }  function test_lenderCannotStartAClosedPCL() public {     assert_start_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot start a PCL in closed state',         'LP:S1'     ); }  /************************************************************************************************************************************* Cancel function calls *************************************************************************************************************************************/  function assert_cancel_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.cancelRequest(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1'); }  function test_lenderCannotCancelAClosedPCL() public {     assert_cancel_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot cancel a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Close function calls *************************************************************************************************************************************/  function assert_close_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.close(_id) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1'); }  function test_borrowerCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1'); }  function test_lenderCannotCloseAClosedPCL() public {     assert_close_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot close a closed PCL',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************* Deposit collateral function calls *************************************************************************************************************************************/  function assert_collateralCannotBeDepositedInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _depositor,     bool _isDepositorLender ) public {     if (_isDepositorLender) {         _depositor = PCLUser(lenders[0].lenderAddress);     }      admin.transferToken(address(collateralAsset), address(_depositor), _amount);     _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);      try _depositor.depositCollateral(_id, _amount, false) {         revert('Collateral cannot be deposited in the CLOSED state');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:DC2');     } }  function test_borrowerCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true); }  function test_lenderCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true); }  function test_adminCannotDepositCollateral() public {     uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();     assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false); }  /************************************************************************************************************************************* Borrow function tests *************************************************************************************************************************************/  function assertBorrowFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.borrow(_id, _amount) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotBorrow() public {     assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1'); }  function test_borrowerCannotBorrowAClosedPCL() public {     assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3'); }  function test_borrowerCannotBorrowZeroAmount() public {     assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1'); }  function test_lenderCannotBorrow() public {     assertBorrowFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot borrow a PCL in closed state',         'PCL:OCLB1'     ); }  /************************************************************************************************************************************** Repay function tests **************************************************************************************************************************************/  function assertRepayFunctionalityInClosedState(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.repay(_id, 1) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2'); }  function test_borrowerCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2'); }  function test_lenderCannotRepayAClosedPCL() public {     assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2'); }  /************************************************************************************************************************************* Withdraw collateral function tests *************************************************************************************************************************************/  function assertWithdrawCollateralFunctionalityInClosedState(     uint256 _id,     uint256 _amount,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage,     string memory _errorMessageAll ) public virtual {     if (pcl.withdrawableCollateral(_id) &gt; 0 &amp;&amp; _user == borrower) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawAllCollateral(_id, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertGe(_balanceAfter, _balanceBefore);     } else {         try _user.withdrawAllCollateral(_id, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessageAll);         }     }      if (pcl.withdrawableCollateral(_id) &gt;= _amount &amp;&amp; _user == borrower &amp;&amp; _amount != 0) {         uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));         _user.withdrawCollateral(_id, _amount, false);         uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));         assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);     } else {         try _user.withdrawCollateral(_id, _amount, false) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         admin,         'Admin cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC1',         'PCL:WAC1'     ); }  function test_borrowerCannotWithdrawZeroCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         0,         borrower,         'Borrower cannot withdraw collateral in closed state',         'PCL:WC2',         'PCL:WAC1'     ); }  function test_lenderCannotWithdrawCollateral() public {     assertWithdrawCollateralFunctionalityInClosedState(         requestId,         1,         PCLUser(lenders[0].lenderAddress),         'Lender cannot withdraw collateral in closed state',         'PCL:OCLB1',         'PCL:OCLB1'     ); }  function test_borrowerCanWithdrawCollateral() public {     // The below function will create the PCL request and then lenders lend the entire requested amount     (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);     borrowAndRepay(_id);     vm.warp(block.timestamp + request.duration.mul(110).div(100));     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);     emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);     uint256 _startBalance = collateralAsset.balanceOf(address(borrower));     if (request.collateralRatio != 0) {         assertGt(_withdrawableCollateral, 0);         borrower.withdrawAllCollateral(_id, false);     }     uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));     assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14); }  /************************************************************************************************************************************* WithdrawLiquidity function calls **************************************************************************************************************************************/  function assert_withdraw_liquidity_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     bool _positiveCase,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_positiveCase) {         uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));         _user.withdrawLiquidity(_id);         uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);         uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));          assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);         assertEq(_poolTokenBalanceNew, 0);     } else {         try _user.withdrawLiquidity(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         admin,         false,         'Admin cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(         requestId,         borrower,         false,         'Borrower cannot WithdrawLiquidity a PCL in closed state',         'LP:IWL1'     ); }  function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {     assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', ''); }  /************************************************************************************************************************************** Liquidate function tests **************************************************************************************************************************************/  function assert_liquidate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     try _user.liquidate(_id, true) {         revert(_revertMessage);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     }      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED); }  function test_adminCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_borrowerCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1'); }  function test_lenderCannotLiquidateAClosedPCL() public {     assert_liquidate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Lender cannot liquidate a closed PCL',         'PCL:L1'     ); }  /************************************************************************************************************************************* WithdrawInterest function calls **************************************************************************************************************************************/  function assert_withdraw_interest_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _errorMessage ) public {     uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));     uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));     uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);      uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));      try _user.withdrawInterest(_id) {         uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));         uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));         uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);          if (_userPoolTokenBalancePreWithdraw == 0) {             assertEq(_lenderInterest, 0);             assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);         } else {             assertTrue(_lenderInterest != 0);             assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);         }          assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);         assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);     } catch Error(string memory reason) {         assertEq(reason, _errorMessage);     } }  function test_adminCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1'); }  function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1'); }  function test_lenderCanWithdrawInterestFromAClosedPCL() public {     assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), ''); }  /************************************************************************************************************************************** Terminate function tests **************************************************************************************************************************************/  function assert_terminate_functionality_in_closed_state(     uint256 _id,     PCLUser _user,     string memory _revertMessage,     string memory _errorMessage ) public {     if (_user != admin) {         try _user.terminate(_id) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }     } else {         _user.terminate(_id);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     } }  function test_adminCanTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(requestId, admin, '', ''); }  function test_borrowerCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         borrower,         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  function test_lenderCannotTerminateAClosedPCL() public {     assert_terminate_functionality_in_closed_state(         requestId,         PCLUser(lenders[0].lenderAddress),         'Should not be able to terminate a closed PCL',         'Ownable: caller is not the owner'     ); }  uint256 _fromUserPoolTokenSupplyOld; uint256 _toUserPoolTokenSupplyOld; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _toInterestOwed; uint256 _fromInterestOwed; uint256 _fromBorrowTokenBalanceInitial; uint256 _toBorrowTokenBalanceInitial;  /************************************************************************************************************************************** Pool MockToken Transfer function tests **************************************************************************************************************************************/  function assert_pool_token_transfer_in_closed_stage(     uint256 _id,     PCLUser _fromUser,     PCLUser _toUser,     bool _positiveCase,     uint256 _fractionOfPTSupply,     string memory _revertMessage,     string memory _errorMessage ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);     _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);      if (_positiveCase) {         _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));         _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));          _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));         _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));          _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));         assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));          assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);         assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);     } else {         try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {             revert(_revertMessage);         } catch Error(string memory reason) {             assertEq(reason, _errorMessage);         }          _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);         _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);          assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);         assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);     } }  function test_poolTokenTransferComplete() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         1,         '',         ''     ); }  function test_poolTokenTransferPartial() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         PCLUser(lenders[1].lenderAddress),         true,         4,         '',         ''     ); }  function test_poolTokenTransferToNonVerifiedUser() public {     assert_pool_token_transfer_in_closed_stage(         requestId,         PCLUser(lenders[0].lenderAddress),         admin,         false,         4,         'Non-verified user should not be able to receive pool tokens',         'LP:IT3'     ); }  function test_externalUserCannotCreate() public {     try         lp.create(             requestId,             mockAdminVerifier1,             address(borrowAsset),             noYieldAddress,             request.borrowLimit,             request.minBorrowAmount,             request.collectionPeriod,             true         )     {         revert('External user cannot create');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_externalUserCannotTerminate() public {     try lp.terminate(requestId, address(admin)) {         revert('External user cannot terminate');     } catch Error(string memory reason) {         assertEq(reason, 'LP:OPCL1');     } }  function test_cannotLendZeroAmount() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, 0) {         revert('Lender cannot lend zero amount');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L1');     } }  function test_unverifiedLenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier2);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Unverified lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L2');     } }  function test_lenderCannotLend() public {     uint256 _amountToLend = 100;     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);     _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);      try _pooledCreditLineLender.lend(requestId, _amountToLend) {         revert('Lender cannot lend');     } catch Error(string memory reason) {         assertEq(reason, 'LP:L3');     } }  function test_lenderCannotWithdrawZeroInterest() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertGt(_lenderInterestOwed, 0);      uint256 _startBalance = borrowAsset.balanceOf(address(_lender));     _lender.withdrawInterest(requestId);     uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));     assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);     _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));     assertEq(_lenderInterestOwed, 0);      try _lender.withdrawInterest(requestId) {         revert('Lender cannot withdraw zero interest');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WI1');     } }  function test_nonLenderCannotWithdrawLiquidationTokens() public {     PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);     _pooledCreditLineLender.registerSelf(mockAdminVerifier1);      try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {         revert('Non lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:WLC1');     } }  function test_lenderCannotWithdrawLiquidationTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);      try _lender.withdrawTokensAfterLiquidation(requestId) {         revert('Lender cannot withdraw liquidated collateral tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  function test_cannotTransferLPTokensToSameAddress() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to itself');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT1');     } }  function test_cannotTransferLPTokensToBorrower() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {         revert('Lender cannot transfer LP tokens to borrower');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT2');     } }  function test_cannotBurnPoolTokens() public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);      try _lender.transferLPTokens(address(0), requestId, _balanceLender) {         revert('Lender cannot burn LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'ERC1155: transfer to the zero address');     } }  function test_cannotTransferNonTransferableLPTokens() public {     request.areTokensTransferable = false;     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);      vm.warp(block.timestamp + request.duration);     borrower.close(_requestId);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);      PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);     uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);     PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);      try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {         revert('Lender cannot transfer non transferable LP tokens');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IT5');     } }  /************************************************************************************************************************************** View/calculation function tests **************************************************************************************************************************************/  function assert_helper_functionalities_in_closed_state(     uint256 _id,     PCLUser _lender,     PCLUser _borrower ) public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);      // 1. calculatePrincipalWithdrawable     uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);     uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertGe(_principalWithdrawable, _userLiquidity);     _lender.withdrawLiquidity(_id);     uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));     assertGe(newBalance, _userLiquidity);      // 2. withdrawableCollateral     uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());     assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);      // 3.calculateTotalCollateralTokens     uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);      // 4. calculateBorrowableAmount     uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_totalBorrowable, 0); // Since PCL is closed now      // 5. calculateInterestAccrued     uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment      // 6. calculateCurrentDebt     uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off      // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1     // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws      // 7. calculateCurrentCollateralRatio     try _borrower.calculateCurrentCollateralRatio(_id) {         uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     }      // 8. collateralTokensToLiquidate     try _borrower.collateralTokensToLiquidate(_id, 0) {         uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);         assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now     } catch Error(string memory reason) {         assertEq(reason, 'PO:IGUPT1');     } }  function test_helperFunctionInClosedState() public {     assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower); }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:29:04 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

