[2024-26-08 14:55:11 INFO] **[Preprocessing]**

**ChatDev Starts** (20240826145511)

**Timestamp**: 20240826145511

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}


**project_name**: RealWorld_BA_94_FETH

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_94_FETH_RealWord_20240826145511.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-26-08 14:55:11 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"; import "@openzeppelin/contracts/utils/math/Math.sol"; import "./libraries/LockedBalance.sol"; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = "Foundation Wrapped Ether";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = "FETH"; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '/\n  ･\n   \u3000★\n      ･ ｡\n        \u3000･\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 \u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000 ☆ ｡･ﾟ.｡\n      \u3000\u3000\u3000ﾟ .｡☆｡★\u3000･\n\u200b\n                      .-:::::-.              -::---...```\n-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy\n-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo\n                                              ````\n   *\u3000\n      ･ ｡\n\u3000\u3000\u3000\u3000･\u3000\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 *\u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000* ☆ ｡･ﾟ*.｡\n      \u3000\u3000\u3000ﾟ *.｡☆｡★\u3000･\n    *\u3000\u3000ﾟ｡·*･｡ ﾟ*\n  \u3000\u3000\u3000☆ﾟ･｡°*. ﾟ\n\u3000 ･ ﾟ*｡･ﾟ★｡\n\u3000\u3000･ *ﾟ｡\u3000\u3000 *\n\u3000･ﾟ*｡★･\n ☆∴｡\u3000*\n･ ｡\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";\nimport "@openzeppelin/contracts/utils/math/Math.sol";\n\nimport "./libraries/LockedBalance.sol";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Burn_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account\'s info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address =&gt; uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address =&gt; AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation Wrapped Ether\n   */\n  string public constant name = "Foundation Wrapped Ether";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = "FETH";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for thefromaccount.\n   * @param amount The max amount of tokens which can be spent by thespenderaccount.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account\'s total FETH balance.\n   * @param account The account which has access to the FETH after theexpiration.\n   * @param expiration The time at which thefromaccount will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account\'s total FETH balance,\n   * this may be lower thanamountif available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it\'s only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user\'s account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user\'s FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Initializes variables which may differ on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for whenBalanceLocked, in seconds.\n   */\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (viamsg.value) to the contract performs adepositinto the user\'s account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves aspenderas an operator with permissions to transfer from your account.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from themsg.sender\'s account.\n   * @param amount The max number of FETH tokens frommsg.sender\'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and credit theaccountprovided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user\'s account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked fromunlockFrom\'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=lockupAmountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account\'s FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param amount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=amountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as withbuy.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked fromaccount.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user\'s available balance and returns ETH to the caller.\n   * @dev Used by the market when a user\'s available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted fromunlockFrom\'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user\'s account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user\'s offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if themsg.senderhas approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Burn_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from thefromaccounts available balance\n   * and send ETH to the destination address, if themsg.senderhas approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    if (accountInfo.allowance[msg.sender] != type(uint256).max) {\n      if (accountInfo.allowance[msg.sender] &lt; amount) {\n        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        accountInfo.allowance[msg.sender] -= amount;\n      }\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account\'s available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    // Free from escrow in order to consider any expired escrow balance\n    if (accountInfo.freedBalance &lt; amount) {\n      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance -= uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that\'s the new start index\n      if (escrow.expiration &gt;= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account\'s FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is &lt;= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value &lt; amount) {\n      // The check above prevents underflow with delta.\n      unchecked {\n        uint256 delta = amount - msg.value;\n        if (accountInfo.freedBalance &lt; delta) {\n          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n        }\n        // The check above prevents underflow of freed balance.\n        accountInfo.freedBalance -= uint96(delta);\n      }\n    } else if (msg.value != amount) {\n      // There\'s no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always &lt; 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration &gt; type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be &lt; 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be &lt; 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration &lt; block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it\'s the last one\n        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n          // The number of escrow buckets will never overflow 32 bits.\n          unchecked {\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount &lt; amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount &gt; escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from theaccount\'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from theaccount\'s balance.\n   * @return amount The number of tokens theoperatoris still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    return accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    return foundationMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @devexpires.length==amounts.length\n   * andamounts[i]is the number of tokens which will expire atexpires[i].\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev UsebalanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   /\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   /\n  function totalSupply() external view returns (uint256 supply) {\n    / It is possible for this to diverge from the total token count by transferring ETH on self destruct\n       but this is on-par with the WETH implementation and done for gas savings. /\n    return address(this).balance;\n  }\n}\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-26-08 14:55:11 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"; import "@openzeppelin/contracts/utils/math/Math.sol"; import "./libraries/LockedBalance.sol"; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = "Foundation Wrapped Ether";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = "FETH"; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-26-08 14:55:11 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "/*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-26-08 14:55:19 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-26-08 14:55:19 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15243
completion_tokens: 446
total_tokens: 15689
cost: $-1.000000


[2024-26-08 14:55:19 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.]

Let's analyze the provided Solidity contract and identify potential improvements or enhancements.

1. **Reentrancy Protection**: While the contract uses `sendValue` for transferring ETH, it does not implement a reentrancy guard. Adding a reentrancy guard (using OpenZeppelin's `ReentrancyGuard`) to functions that transfer ETH could prevent potential reentrancy attacks.

2. **Gas Optimization**: The contract has several loops that could be optimized. For example, in the `_freeFromEscrow` and `balanceOf` functions, we could consider caching the length of the lockups to avoid recalculating it multiple times.

3. **Event Emission**: The contract emits events for significant actions, but it could be beneficial to emit events for all state-changing actions, such as when tokens are deposited or withdrawn. This would enhance transparency and allow for better tracking of contract activity.

4. **Access Control**: The `onlyFoundationMarket` modifier restricts certain functions to the Foundation market. It might be useful to implement a role-based access control system (using OpenZeppelin's `AccessControl`) to allow for more granular permissions in the future.

5. **Error Handling**: The contract uses custom error messages, which is good for gas efficiency. However, we could consider adding more context to some of the errors to make debugging easier. For example, including the account address in the `FETH_Escrow_Not_Found` error could help identify which account is causing the issue.

6. **Upgradeability**: Since the contract imports OpenZeppelin's upgradeable contracts, it might be beneficial to implement a proxy pattern to ensure that the contract can be upgraded in the future without losing state.

7. **Testing and Auditing**: Emphasizing the importance of thorough testing and auditing of the contract, especially since it deals with financial transactions. Implementing a test suite that covers edge cases and potential attack vectors would be crucial.

8. **User Experience**: Consider adding functions that allow users to check their locked balances and expiration times more easily, which could improve the user experience.

Which of these suggestions resonates most with you, or do you have any additional ideas to discuss?

[2024-26-08 14:55:19 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"; import "@openzeppelin/contracts/utils/math/Math.sol"; import "./libraries/LockedBalance.sol"; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = "Foundation Wrapped Ether";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = "FETH"; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: /\n  ･\n   \u3000★\n      ･ ｡\n        \u3000･\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 \u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000 ☆ ｡･ﾟ.｡\n      \u3000\u3000\u3000ﾟ .｡☆｡★\u3000･\n\u200b\n                      .-:::::-.              -::---...```\n-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy\n-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo\n                                              \n   *\u3000\n      ･ ｡\n\u3000\u3000\u3000\u3000･\u3000\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 *\u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000* ☆ ｡･ﾟ*.｡\n      \u3000\u3000\u3000ﾟ *.｡☆｡★\u3000･\n    *\u3000\u3000ﾟ｡·*･｡ ﾟ*\n  \u3000\u3000\u3000☆ﾟ･｡°*. ﾟ\n\u3000 ･ ﾟ*｡･ﾟ★｡\n\u3000\u3000･ *ﾟ｡\u3000\u3000 *\n\u3000･ﾟ*｡★･\n ☆∴｡\u3000*\n･ ｡\n*/\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.0;\nimport "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";\nimport "@openzeppelin/contracts/utils/math/Math.sol";\nimport "./libraries/LockedBalance.sol";\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Burn_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n  /// @notice Tracks an account\'s info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address =&gt; uint256) allowance;\n  }\n  /// @notice Stores per-account details.\n  mapping(address =&gt; AccountInfo) private accountToInfo;\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation Wrapped Ether\n   */\n  string public constant name = "Foundation Wrapped Ether";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = "FETH";\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account\'s total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account\'s total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it\'s only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user\'s account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user\'s FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n  /**\n   * @notice Initializes variables which may differ on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user\'s account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`\'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`\'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user\'s account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`\'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`\'s account.\n   * `msg.value` must be &lt;= `lockupAmount` and any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account\'s FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`\'s account.\n   * `msg.value` must be &lt;= `amount` and any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user\'s available balance and returns ETH to the caller.\n   * @dev Used by the market when a user\'s available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`\'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user\'s account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user\'s offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Burn_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n    emit Transfer(from, to, amount);\n    return true;\n  }\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n    emit ETHWithdrawn(from, to, amount);\n  }\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    if (accountInfo.allowance[msg.sender] != type(uint256).max) {\n      if (accountInfo.allowance[msg.sender] &lt; amount) {\n        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        accountInfo.allowance[msg.sender] -= amount;\n      }\n    }\n  }\n  /**\n   * @dev Removes an amount from the account\'s available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    // Free from escrow in order to consider any expired escrow balance\n    if (accountInfo.freedBalance &lt; amount) {\n      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance -= uint96(amount);\n    }\n  }\n  /**\n   * @dev Moves expired escrow to the available balance.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n      return accountInfo;\n    }\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n      // If the next bucket is expired, that\'s the new start index\n      if (escrow.expiration &gt;= block.timestamp) {\n        break;\n      }\n    }\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n  /**\n   * @notice Lockup an account\'s FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is &lt;= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value &lt; amount) {\n      // The check above prevents underflow with delta.\n      unchecked {\n        uint256 delta = amount - msg.value;\n        if (accountInfo.freedBalance &lt; delta) {\n          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n        }\n        // The check above prevents underflow of freed balance.\n        accountInfo.freedBalance -= uint96(delta);\n      }\n    } else if (msg.value != amount) {\n      // There\'s no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always &lt; 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration &gt; type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be &lt; 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be &lt; 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n  /**\n   * @notice Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration &lt; block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n        // Bump the escrow start index unless it\'s the last one\n        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n          // The number of escrow buckets will never overflow 32 bits.\n          unchecked {\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount &lt; amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount &gt; escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`\'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`\'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    return accountInfo.allowance[operator];\n  }\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    return foundationMarket;\n  }\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n    // Populate results\n    uint256 i;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct\n       but this is on-par with the WETH implementation and done for gas savings. */\n    return address(this).balance;\n  }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "/*\n  ･\n   *\u3000★\n      ･ ｡\n        \u3000･\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 *\u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000* ☆ ｡･ﾟ*.｡\n      \u3000\u3000\u3000ﾟ *.｡☆｡★\u3000･\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n\n   \u3000\n      ･ ｡\n\u3000\u3000\u3000\u3000･\u3000\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 \u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000 ☆ ｡･ﾟ.｡\n      \u3000\u3000\u3000ﾟ .｡☆｡★\u3000･\n    \u3000\u3000ﾟ｡·･｡ ﾟ\n  \u3000\u3000\u3000☆ﾟ･｡°. ﾟ\n\u3000 ･ ﾟ｡･ﾟ★｡\n\u3000\u3000･ ﾟ｡\u3000\u3000 \n\u3000･ﾟ｡★･\n ☆∴｡\u3000\n･ ｡\n/\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.0;\nimport "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";\nimport "@openzeppelin/contracts/utils/math/Math.sol";\nimport "./libraries/LockedBalance.sol";\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Burn_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n/\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an ERC-20 token modeled after\n * WETH9.\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n /\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n  /// @notice Tracks an account\'s info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address =&gt; uint256) allowance;\n  }\n  /// @notice Stores per-account details.\n  mapping(address =&gt; AccountInfo) private accountToInfo;\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n  // ERC-20 metadata fields\n  /\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /\n   * @notice The name of the token.\n   * @return Foundation Wrapped Ether\n   /\n  string public constant name = "Foundation Wrapped Ether";\n  /\n   * @notice The symbol of the token.\n   * @return FETH\n   /\n  string public constant symbol = "FETH";\n  // ERC-20 events\n  /\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the from account.\n   * @param amount The max amount of tokens which can be spent by the spender account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   /\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n  // Custom events\n  /\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account\'s total FETH balance.\n   * @param account The account which has access to the FETH after the expiration.\n   * @param expiration The time at which the from account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account\'s total FETH balance,\n   * this may be lower than amount if available FETH was leveraged.\n   /\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it\'s only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /\n   * @notice Emitted when ETH is withdrawn from a user\'s account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user\'s FETH balance and transferred as ETH.\n   /\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n  /\n   * @notice Initializes variables which may differ on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.\n   /\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n  /\n   * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user\'s account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n  /\n   * @notice Approves a spender as an operator with permissions to transfer from your account.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the msg.sender\'s account.\n   * @param amount The max number of FETH tokens from msg.sender\'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   /\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n  /\n   * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   /\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n  /\n   * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user\'s account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n  /\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from unlockFrom\'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the lockupFor\'s account.\n   * msg.value must be &lt;= lockupAmount and any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   /\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n  /\n   * @notice Used by the market contract only:\n   * Lockup an account\'s FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the lockupFor\'s account.\n   * msg.value must be &lt;= amount and any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   /\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n  /\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with buy.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from account.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n  /\n   * @notice Used by the market contract only:\n   * Removes tokens from the user\'s available balance and returns ETH to the caller.\n   * @dev Used by the market when a user\'s available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from unlockFrom\'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   /\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n  /\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user\'s account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user\'s offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   /\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n  /\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n  /\n   * @notice Transfers an amount from the account specified if the msg.sender has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   /\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Burn_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n    emit Transfer(from, to, amount);\n    return true;\n  }\n  /\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   /\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n  /\n   * @notice Withdraw the specified number of tokens from the from accounts available balance\n   * and send ETH to the destination address, if the msg.sender has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n    emit ETHWithdrawn(from, to, amount);\n  }\n  /\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   /\n  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    if (accountInfo.allowance[msg.sender] != type(uint256).max) {\n      if (accountInfo.allowance[msg.sender] &lt; amount) {\n        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        accountInfo.allowance[msg.sender] -= amount;\n      }\n    }\n  }\n  /\n   * @dev Removes an amount from the account\'s available FETH balance.\n   /\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    // Free from escrow in order to consider any expired escrow balance\n    if (accountInfo.freedBalance &lt; amount) {\n      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance -= uint96(amount);\n    }\n  }\n  /\n   * @dev Moves expired escrow to the available balance.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n      return accountInfo;\n    }\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n      // If the next bucket is expired, that\'s the new start index\n      if (escrow.expiration &gt;= block.timestamp) {\n        break;\n      }\n    }\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n  /\n   * @notice Lockup an account\'s FETH tokens for 24-25 hours.\n   /\n  / solhint-disable-next-line code-complexity /\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is &lt;= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value &lt; amount) {\n      // The check above prevents underflow with delta.\n      unchecked {\n        uint256 delta = amount - msg.value;\n        if (accountInfo.freedBalance &lt; delta) {\n          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n        }\n        // The check above prevents underflow of freed balance.\n        accountInfo.freedBalance -= uint96(delta);\n      }\n    } else if (msg.value != amount) {\n      // There\'s no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always &lt; 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration &gt; type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be &lt; 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be &lt; 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n  /\n   * @notice Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   /\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n  /\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   /\n  / solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration &lt; block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n        // Bump the escrow start index unless it\'s the last one\n        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n          // The number of escrow buckets will never overflow 32 bits.\n          unchecked {\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount &lt; amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount &gt; escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n  /\n   * @notice Returns the amount which a spender is still allowed to transact from the account\'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the account\'s balance.\n   * @return amount The number of tokens the operator is still allowed to transact with.\n   /\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    return accountInfo.allowance[operator];\n  }\n  /\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   /\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n  /\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    return foundationMarket;\n  }\n  /\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev expires.length == amounts.length\n   * and amounts[i] is the number of tokens which will expire at expires[i].\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   /\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n    // Allocate arrays\n    expiries = new uint256;\n    amounts = new uint256;\n    // Populate results\n    uint256 i;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n  /\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   /\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n  /\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   /\n  function totalSupply() external view returns (uint256 supply) {\n    / It is possible for this to diverge from the total token count by transferring ETH on self destruct\n       but this is on-par with the WETH implementation and done for gas savings. */\n    return address(this).balance;\n  }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s analyze the provided Solidity contract and identify potential improvements or enhancements.\n1. Reentrancy Protection: While the contract uses sendValue for transferring ETH, it does not implement a reentrancy guard. Adding a reentrancy guard (using OpenZeppelin\'s ReentrancyGuard) to functions that transfer ETH could prevent potential reentrancy attacks.\n2. Gas Optimization: The contract has several loops that could be optimized. For example, in the _freeFromEscrow and balanceOf functions, we could consider caching the length of the lockups to avoid recalculating it multiple times.\n3. Event Emission: The contract emits events for significant actions, but it could be beneficial to emit events for all state-changing actions, such as when tokens are deposited or withdrawn. This would enhance transparency and allow for better tracking of contract activity.\n4. Access Control: The onlyFoundationMarket modifier restricts certain functions to the Foundation market. It might be useful to implement a role-based access control system (using OpenZeppelin\'s AccessControl) to allow for more granular permissions in the future.\n5. Error Handling: The contract uses custom error messages, which is good for gas efficiency. However, we could consider adding more context to some of the errors to make debugging easier. For example, including the account address in the FETH_Escrow_Not_Found error could help identify which account is causing the issue.\n6. Upgradeability: Since the contract imports OpenZeppelin\'s upgradeable contracts, it might be beneficial to implement a proxy pattern to ensure that the contract can be upgraded in the future without losing state.\n7. Testing and Auditing: Emphasizing the importance of thorough testing and auditing of the contract, especially since it deals with financial transactions. Implementing a test suite that covers edge cases and potential attack vectors would be crucial.\n8. User Experience**: Consider adding functions that allow users to check their locked balances and expiration times more easily, which could improve the user experience.\nWhich of these suggestions resonates most with you, or do you have any additional ideas to discuss?', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-26-08 14:55:19 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"; import "@openzeppelin/contracts/utils/math/Math.sol"; import "./libraries/LockedBalance.sol"; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = "Foundation Wrapped Ether";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = "FETH"; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-26-08 14:55:19 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/
// SPDX-License-Identifier: MIT OR Apache-2.0
pragma solidity ^0.8.0;
import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";
import "./libraries/LockedBalance.sol";
error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();
/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;
  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }
  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;
  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;
  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;
  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";
  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);
  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);
  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }
  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }
  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }
  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }
  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }
  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }
  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }
  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }
  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }
  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);
    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);
    emit ETHWithdrawn(from, msg.sender, amount);
  }
  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);
    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);
    emit ETHWithdrawn(account, msg.sender, amount);
  }
  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }
  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }
    emit Transfer(from, to, amount);
    return true;
  }
  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;
    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);
    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }
  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);
    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);
    emit ETHWithdrawn(from, to, amount);
  }
  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }
  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }
  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }
    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }
      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }
      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }
      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }
    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }
  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }
    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }
    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }
    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }
    emit BalanceLocked(account, expiration, amount, msg.value);
  }
  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }
  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);
        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }
    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }
  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }
  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;
    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }
  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }
  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];
    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }
    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);
    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }
  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;
    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }
  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "/*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/
// SPDX-License-Identifier: MIT OR Apache-2.0
pragma solidity ^0.8.0;
import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";
import "./libraries/LockedBalance.sol";
error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();
/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;
  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }
  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;
  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;
  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;
  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";
  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);
  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);
  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }
  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }
  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }
  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }
  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }
  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }
  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }
  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }
  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }
  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);
    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);
    emit ETHWithdrawn(from, msg.sender, amount);
  }
  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);
    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);
    emit ETHWithdrawn(account, msg.sender, amount);
  }
  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }
  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }
    emit Transfer(from, to, amount);
    return true;
  }
  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;
    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);
    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }
  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);
    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);
    emit ETHWithdrawn(from, to, amount);
  }
  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }
  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }
  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }
    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }
      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }
      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }
      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }
    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }
  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }
    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }
    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }
    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }
    emit BalanceLocked(account, expiration, amount, msg.value);
  }
  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }
  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);
        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }
    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }
  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }
  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;
    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }
  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }
  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];
    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }
    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);
    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }
  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;
    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }
  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's analyze the provided Solidity contract and identify potential improvements or enhancements.
1. **Reentrancy Protection**: While the contract uses `sendValue` for transferring ETH, it does not implement a reentrancy guard. Adding a reentrancy guard (using OpenZeppelin's `ReentrancyGuard`) to functions that transfer ETH could prevent potential reentrancy attacks.
2. **Gas Optimization**: The contract has several loops that could be optimized. For example, in the `_freeFromEscrow` and `balanceOf` functions, we could consider caching the length of the lockups to avoid recalculating it multiple times.
3. **Event Emission**: The contract emits events for significant actions, but it could be beneficial to emit events for all state-changing actions, such as when tokens are deposited or withdrawn. This would enhance transparency and allow for better tracking of contract activity.
4. **Access Control**: The `onlyFoundationMarket` modifier restricts certain functions to the Foundation market. It might be useful to implement a role-based access control system (using OpenZeppelin's `AccessControl`) to allow for more granular permissions in the future.
5. **Error Handling**: The contract uses custom error messages, which is good for gas efficiency. However, we could consider adding more context to some of the errors to make debugging easier. For example, including the account address in the `FETH_Escrow_Not_Found` error could help identify which account is causing the issue.
6. **Upgradeability**: Since the contract imports OpenZeppelin's upgradeable contracts, it might be beneficial to implement a proxy pattern to ensure that the contract can be upgraded in the future without losing state.
7. **Testing and Auditing**: Emphasizing the importance of thorough testing and auditing of the contract, especially since it deals with financial transactions. Implementing a test suite that covers edge cases and potential attack vectors would be crucial.
8. **User Experience**: Consider adding functions that allow users to check their locked balances and expiration times more easily, which could improve the user experience.
Which of these suggestions resonates most with you, or do you have any additional ideas to discuss? Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-26-08 14:55:22 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-26-08 14:55:22 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 23364
completion_tokens: 1
total_tokens: 23365
cost: $-1.000000


[2024-26-08 14:55:22 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.]

1

[2024-26-08 14:55:22 INFO] **[Seminar Conclusion]**:

 1

[2024-26-08 14:55:22 INFO] **[Seminar Conclusion]**:

 <INFO> 1

[2024-26-08 14:55:22 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-26-08 14:55:22 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"; import "@openzeppelin/contracts/utils/math/Math.sol"; import "./libraries/LockedBalance.sol"; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = "Foundation Wrapped Ether";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = "FETH"; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '/\n  ･\n   \u3000★\n      ･ ｡\n        \u3000･\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 \u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000 ☆ ｡･ﾟ.｡\n      \u3000\u3000\u3000ﾟ .｡☆｡★\u3000･\n\u200b\n                      .-:::::-.              -::---...```\n-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy\n-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo\n                                              ````\n   *\u3000\n      ･ ｡\n\u3000\u3000\u3000\u3000･\u3000\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 *\u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000* ☆ ｡･ﾟ*.｡\n      \u3000\u3000\u3000ﾟ *.｡☆｡★\u3000･\n    *\u3000\u3000ﾟ｡·*･｡ ﾟ*\n  \u3000\u3000\u3000☆ﾟ･｡°*. ﾟ\n\u3000 ･ ﾟ*｡･ﾟ★｡\n\u3000\u3000･ *ﾟ｡\u3000\u3000 *\n\u3000･ﾟ*｡★･\n ☆∴｡\u3000*\n･ ｡\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";\nimport "@openzeppelin/contracts/utils/math/Math.sol";\n\nimport "./libraries/LockedBalance.sol";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Burn_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account\'s info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address =&gt; uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address =&gt; AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation Wrapped Ether\n   */\n  string public constant name = "Foundation Wrapped Ether";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = "FETH";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for thefromaccount.\n   * @param amount The max amount of tokens which can be spent by thespenderaccount.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account\'s total FETH balance.\n   * @param account The account which has access to the FETH after theexpiration.\n   * @param expiration The time at which thefromaccount will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account\'s total FETH balance,\n   * this may be lower thanamountif available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it\'s only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user\'s account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user\'s FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Initializes variables which may differ on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for whenBalanceLocked, in seconds.\n   */\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (viamsg.value) to the contract performs adepositinto the user\'s account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves aspenderas an operator with permissions to transfer from your account.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from themsg.sender\'s account.\n   * @param amount The max number of FETH tokens frommsg.sender\'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and credit theaccountprovided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user\'s account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked fromunlockFrom\'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=lockupAmountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account\'s FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param amount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=amountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as withbuy.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked fromaccount.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user\'s available balance and returns ETH to the caller.\n   * @dev Used by the market when a user\'s available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted fromunlockFrom\'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user\'s account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user\'s offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if themsg.senderhas approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Burn_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from thefromaccounts available balance\n   * and send ETH to the destination address, if themsg.senderhas approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    if (accountInfo.allowance[msg.sender] != type(uint256).max) {\n      if (accountInfo.allowance[msg.sender] &lt; amount) {\n        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        accountInfo.allowance[msg.sender] -= amount;\n      }\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account\'s available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    // Free from escrow in order to consider any expired escrow balance\n    if (accountInfo.freedBalance &lt; amount) {\n      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance -= uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that\'s the new start index\n      if (escrow.expiration &gt;= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account\'s FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is &lt;= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value &lt; amount) {\n      // The check above prevents underflow with delta.\n      unchecked {\n        uint256 delta = amount - msg.value;\n        if (accountInfo.freedBalance &lt; delta) {\n          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n        }\n        // The check above prevents underflow of freed balance.\n        accountInfo.freedBalance -= uint96(delta);\n      }\n    } else if (msg.value != amount) {\n      // There\'s no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always &lt; 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration &gt; type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be &lt; 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be &lt; 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration &lt; block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it\'s the last one\n        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n          // The number of escrow buckets will never overflow 32 bits.\n          unchecked {\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount &lt; amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount &gt; escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from theaccount\'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from theaccount\'s balance.\n   * @return amount The number of tokens theoperatoris still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    return accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    return foundationMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @devexpires.length==amounts.length\n   * andamounts[i]is the number of tokens which will expire atexpires[i].\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev UsebalanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   /\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   /\n  function totalSupply() external view returns (uint256 supply) {\n    / It is possible for this to diverge from the total token count by transferring ETH on self destruct\n       but this is on-par with the WETH implementation and done for gas savings. /\n    return address(this).balance;\n  }\n}\n', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-26-08 14:55:22 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"; import "@openzeppelin/contracts/utils/math/Math.sol"; import "./libraries/LockedBalance.sol"; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = "Foundation Wrapped Ether";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = "FETH"; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-26-08 14:55:22 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "/*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-26-08 14:55:35 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-26-08 14:55:35 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15235
completion_tokens: 923
total_tokens: 16158
cost: $-1.000000


[2024-26-08 14:55:35 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.]

### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract allows external calls to be made (e.g., sending ETH to `msg.sender` in functions like `marketWithdrawFrom`, `marketWithdrawLocked`, and `withdrawFrom`) after state changes have occurred. This can lead to a reentrancy attack where an attacker could exploit the external call to re-enter the function before the state is updated, potentially draining funds from the contract.

RECOMMENDED MITIGATION: Implement a non-reentrant guard pattern using a mutex or the OpenZeppelin `ReentrancyGuard` modifier to prevent reentrant calls. Ensure that all state changes occur before any external calls.
```

### VULNERABILITY: Insufficient Input Validation
```
DETAILED DESCRIPTION: The contract does not adequately validate inputs in several functions. For example, in the `marketChangeLockup` function, there is no check to ensure that the `unlockAmount` is greater than zero. This could lead to unintended behavior or state corruption if invalid values are passed.

RECOMMENDED MITIGATION: Add input validation checks at the beginning of functions to ensure that all parameters meet expected criteria (e.g., non-zero values, valid addresses).
```

### VULNERABILITY: Gas Limit and Loops
```
DETAILED DESCRIPTION: The functions that iterate over lockup buckets (e.g., `_freeFromEscrow`, `_marketLockupFor`) could potentially run into gas limit issues if the number of buckets exceeds the expected maximum (25). If an attacker can manipulate the number of buckets, they could cause the transaction to fail due to exceeding the gas limit.

RECOMMENDED MITIGATION: Implement checks to ensure that the number of lockup buckets does not exceed a predefined limit. Additionally, consider using a more gas-efficient data structure or approach to manage lockups.
```

### VULNERABILITY: Lack of Access Control
```
DETAILED DESCRIPTION: The contract relies on the `onlyFoundationMarket` modifier to restrict access to certain functions. However, if the `foundationMarket` address is compromised or improperly set, it could allow unauthorized access to critical functions, leading to potential fund loss or manipulation.

RECOMMENDED MITIGATION: Implement a mechanism to change the `foundationMarket` address securely, such as an owner-only function that can update the address. Additionally, consider implementing a multi-signature wallet for critical operations.
```

### VULNERABILITY: Incorrect Handling of Allowance
```
DETAILED DESCRIPTION: The allowance mechanism does not properly handle the case where the allowance is set to `type(uint256).max`. This could lead to unexpected behavior if the allowance is not managed correctly, allowing excessive withdrawals.

RECOMMENDED MITIGATION: Ensure that the allowance is checked and managed correctly. Consider implementing a safe math library to handle allowance adjustments to prevent underflows and overflows.
```

### VULNERABILITY: Potential Integer Overflow/Underflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.0 has built-in overflow and underflow checks, there are still areas in the contract where unchecked arithmetic is used (e.g., in `_deductBalanceFrom`). If the contract is ever upgraded to a version prior to 0.8.0, it could be vulnerable to overflow/underflow issues.

RECOMMENDED MITIGATION: Use the `SafeMath` library for all arithmetic operations to ensure safety against overflow and underflow, especially in critical calculations involving balances and allowances.
```

### VULNERABILITY: Unchecked External Call
```
DETAILED DESCRIPTION: The contract uses `sendValue` and `transfer` methods for sending ETH, which can fail silently. If the external call fails, the state changes made before the call may leave the contract in an inconsistent state.

RECOMMENDED MITIGATION: Use the `call` method with proper error handling to ensure that any failure in sending ETH is caught and handled appropriately. Additionally, consider reverting the transaction if the external call fails.
```

### VULNERABILITY: Misleading Comments and Documentation
```
DETAILED DESCRIPTION: Some comments in the code may mislead developers regarding the functionality of certain functions, especially around the handling of funds and allowances. This can lead to incorrect assumptions about the contract's behavior.

RECOMMENDED MITIGATION: Review and update comments and documentation to accurately reflect the functionality and potential risks associated with each function. Ensure that all developers working with the contract understand its behavior.
```

<INFO> Analysis Complete.

[2024-26-08 14:55:35 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract allows external calls to be made (e.g., sending ETH to `msg.sender` in functions like `marketWithdrawFrom`, `marketWithdrawLocked`, and `withdrawFrom`) after state changes have occurred. This can lead to a reentrancy attack where an attacker could exploit the external call to re-enter the function before the state is updated, potentially draining funds from the contract.

RECOMMENDED MITIGATION: Implement a non-reentrant guard pattern using a mutex or the OpenZeppelin `ReentrancyGuard` modifier to prevent reentrant calls. Ensure that all state changes occur before any external calls.
```

### VULNERABILITY: Insufficient Input Validation
```
DETAILED DESCRIPTION: The contract does not adequately validate inputs in several functions. For example, in the `marketChangeLockup` function, there is no check to ensure that the `unlockAmount` is greater than zero. This could lead to unintended behavior or state corruption if invalid values are passed.

RECOMMENDED MITIGATION: Add input validation checks at the beginning of functions to ensure that all parameters meet expected criteria (e.g., non-zero values, valid addresses).
```

### VULNERABILITY: Gas Limit and Loops
```
DETAILED DESCRIPTION: The functions that iterate over lockup buckets (e.g., `_freeFromEscrow`, `_marketLockupFor`) could potentially run into gas limit issues if the number of buckets exceeds the expected maximum (25). If an attacker can manipulate the number of buckets, they could cause the transaction to fail due to exceeding the gas limit.

RECOMMENDED MITIGATION: Implement checks to ensure that the number of lockup buckets does not exceed a predefined limit. Additionally, consider using a more gas-efficient data structure or approach to manage lockups.
```

### VULNERABILITY: Lack of Access Control
```
DETAILED DESCRIPTION: The contract relies on the `onlyFoundationMarket` modifier to restrict access to certain functions. However, if the `foundationMarket` address is compromised or improperly set, it could allow unauthorized access to critical functions, leading to potential fund loss or manipulation.

RECOMMENDED MITIGATION: Implement a mechanism to change the `foundationMarket` address securely, such as an owner-only function that can update the address. Additionally, consider implementing a multi-signature wallet for critical operations.
```

### VULNERABILITY: Incorrect Handling of Allowance
```
DETAILED DESCRIPTION: The allowance mechanism does not properly handle the case where the allowance is set to `type(uint256).max`. This could lead to unexpected behavior if the allowance is not managed correctly, allowing excessive withdrawals.

RECOMMENDED MITIGATION: Ensure that the allowance is checked and managed correctly. Consider implementing a safe math library to handle allowance adjustments to prevent underflows and overflows.
```

### VULNERABILITY: Potential Integer Overflow/Underflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.0 has built-in overflow and underflow checks, there are still areas in the contract where unchecked arithmetic is used (e.g., in `_deductBalanceFrom`). If the contract is ever upgraded to a version prior to 0.8.0, it could be vulnerable to overflow/underflow issues.

RECOMMENDED MITIGATION: Use the `SafeMath` library for all arithmetic operations to ensure safety against overflow and underflow, especially in critical calculations involving balances and allowances.
```

### VULNERABILITY: Unchecked External Call
```
DETAILED DESCRIPTION: The contract uses `sendValue` and `transfer` methods for sending ETH, which can fail silently. If the external call fails, the state changes made before the call may leave the contract in an inconsistent state.

RECOMMENDED MITIGATION: Use the `call` method with proper error handling to ensure that any failure in sending ETH is caught and handled appropriately. Additionally, consider reverting the transaction if the external call fails.
```

### VULNERABILITY: Misleading Comments and Documentation
```
DETAILED DESCRIPTION: Some comments in the code may mislead developers regarding the functionality of certain functions, especially around the handling of funds and allowances. This can lead to incorrect assumptions about the contract's behavior.

RECOMMENDED MITIGATION: Review and update comments and documentation to accurately reflect the functionality and potential risks associated with each function. Ensure that all developers working with the contract understand its behavior.
```

<INFO> Analysis Complete.

[2024-26-08 14:55:35 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-26-08 14:55:35 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"; import "@openzeppelin/contracts/utils/math/Math.sol"; import "./libraries/LockedBalance.sol"; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = "Foundation Wrapped Ether";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = "FETH"; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-26-08 14:55:35 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"; import "@openzeppelin/contracts/utils/math/Math.sol"; import "./libraries/LockedBalance.sol"; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = "Foundation Wrapped Ether";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = "FETH"; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-26-08 14:55:35 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-26-08 14:55:47 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-26-08 14:55:47 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7676
completion_tokens: 894
total_tokens: 8570
cost: $-1.000000


[2024-26-08 14:55:47 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.]

Based on the provided smart contract code for the Foundation Wrapped Ether (FETH) and the analysis of its structure, logic, and implementation, here is a summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not implement a reentrancy guard on functions that transfer ETH, such as `withdrawAvailableBalance`, `withdrawFrom`, and `marketWithdrawFrom`. This could allow an attacker to re-enter these functions before the state changes are completed, potentially draining funds.

2. **Insufficient Input Validation**:
   - The contract relies on certain assumptions about input values (e.g., `msg.value` in `marketLockupFor`). If the assumptions are violated (e.g., a malicious contract sends unexpected values), it could lead to unexpected behavior or loss of funds.

3. **Gas Limit Issues**:
   - The use of loops in functions like `balanceOf` and `getLockups` could lead to gas limit issues if a user has a large number of lockup buckets. This could prevent users from accessing their funds if the gas required exceeds the block gas limit.

4. **Lack of Access Control**:
   - While the `onlyFoundationMarket` modifier restricts certain functions to the Foundation market contract, there is no check to ensure that the Foundation market address is valid or that it has not been compromised. This could lead to unauthorized access if the market contract is exploited.

5. **Potential for Integer Overflow/Underflow**:
   - Although Solidity 0.8.0 and above has built-in overflow/underflow checks, there are still areas in the code where unchecked arithmetic is used (e.g., in `_deductBalanceFrom`). This could lead to unexpected behavior if not handled carefully.

6. **Improper Error Handling**:
   - The contract uses custom error messages but does not provide sufficient context in some cases. For example, when reverting due to insufficient allowance or funds, the error messages do not specify which account is affected, making debugging difficult.

7. **Unrestricted ETH Transfers**:
   - The contract allows for ETH to be sent directly to it via the `receive()` function. If not managed properly, this could lead to unexpected behavior or loss of funds if the contract is not designed to handle incoming ETH correctly.

### Comprehensive Analysis Report:

The FETH contract is designed to wrap ETH and provide additional functionality for locking and managing balances. However, several security vulnerabilities have been identified that could pose significant risks to users and the integrity of the contract. 

1. **Reentrancy**: The absence of reentrancy guards in critical functions could allow attackers to exploit the contract during ETH transfers, leading to potential fund loss.

2. **Input Validation**: Insufficient validation of inputs may allow malicious actors to manipulate contract behavior, especially in functions that handle ETH deposits and lockups.

3. **Gas Limit Concerns**: The potential for gas limit issues due to loops in balance calculations could prevent users from accessing their funds, especially if they have numerous lockup entries.

4. **Access Control**: The reliance on a single market contract for managing lockups without further validation increases the risk of unauthorized access if that contract is compromised.

5. **Arithmetic Safety**: While Solidity provides overflow checks, the use of unchecked arithmetic in certain areas could still lead to vulnerabilities if not handled with caution.

6. **Error Handling**: The lack of detailed error messages can complicate debugging and user experience, making it difficult to identify the source of issues.

7. **ETH Management**: The unrestricted ability to send ETH to the contract raises concerns about how incoming funds are managed, which could lead to unexpected behavior.

### Recommendations:

- Implement a reentrancy guard on all functions that transfer ETH.
- Enhance input validation to ensure that all inputs are within expected ranges and formats.
- Consider limiting the number of lockup buckets or implementing a mechanism to handle gas limits more effectively.
- Strengthen access control measures to ensure that only authorized contracts can interact with sensitive functions.
- Review and refactor areas using unchecked arithmetic to ensure safety.
- Improve error handling to provide more context in error messages.
- Implement a clear strategy for managing incoming ETH to prevent unexpected behavior.

By addressing these vulnerabilities, the FETH contract can enhance its security posture and provide a safer environment for users to interact with wrapped ETH.

[2024-26-08 14:55:47 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the Foundation Wrapped Ether (FETH) and the analysis of its structure, logic, and implementation, here is a summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not implement a reentrancy guard on functions that transfer ETH, such as `withdrawAvailableBalance`, `withdrawFrom`, and `marketWithdrawFrom`. This could allow an attacker to re-enter these functions before the state changes are completed, potentially draining funds.

2. **Insufficient Input Validation**:
   - The contract relies on certain assumptions about input values (e.g., `msg.value` in `marketLockupFor`). If the assumptions are violated (e.g., a malicious contract sends unexpected values), it could lead to unexpected behavior or loss of funds.

3. **Gas Limit Issues**:
   - The use of loops in functions like `balanceOf` and `getLockups` could lead to gas limit issues if a user has a large number of lockup buckets. This could prevent users from accessing their funds if the gas required exceeds the block gas limit.

4. **Lack of Access Control**:
   - While the `onlyFoundationMarket` modifier restricts certain functions to the Foundation market contract, there is no check to ensure that the Foundation market address is valid or that it has not been compromised. This could lead to unauthorized access if the market contract is exploited.

5. **Potential for Integer Overflow/Underflow**:
   - Although Solidity 0.8.0 and above has built-in overflow/underflow checks, there are still areas in the code where unchecked arithmetic is used (e.g., in `_deductBalanceFrom`). This could lead to unexpected behavior if not handled carefully.

6. **Improper Error Handling**:
   - The contract uses custom error messages but does not provide sufficient context in some cases. For example, when reverting due to insufficient allowance or funds, the error messages do not specify which account is affected, making debugging difficult.

7. **Unrestricted ETH Transfers**:
   - The contract allows for ETH to be sent directly to it via the `receive()` function. If not managed properly, this could lead to unexpected behavior or loss of funds if the contract is not designed to handle incoming ETH correctly.

### Comprehensive Analysis Report:

The FETH contract is designed to wrap ETH and provide additional functionality for locking and managing balances. However, several security vulnerabilities have been identified that could pose significant risks to users and the integrity of the contract. 

1. **Reentrancy**: The absence of reentrancy guards in critical functions could allow attackers to exploit the contract during ETH transfers, leading to potential fund loss.

2. **Input Validation**: Insufficient validation of inputs may allow malicious actors to manipulate contract behavior, especially in functions that handle ETH deposits and lockups.

3. **Gas Limit Concerns**: The potential for gas limit issues due to loops in balance calculations could prevent users from accessing their funds, especially if they have numerous lockup entries.

4. **Access Control**: The reliance on a single market contract for managing lockups without further validation increases the risk of unauthorized access if that contract is compromised.

5. **Arithmetic Safety**: While Solidity provides overflow checks, the use of unchecked arithmetic in certain areas could still lead to vulnerabilities if not handled with caution.

6. **Error Handling**: The lack of detailed error messages can complicate debugging and user experience, making it difficult to identify the source of issues.

7. **ETH Management**: The unrestricted ability to send ETH to the contract raises concerns about how incoming funds are managed, which could lead to unexpected behavior.

### Recommendations:

- Implement a reentrancy guard on all functions that transfer ETH.
- Enhance input validation to ensure that all inputs are within expected ranges and formats.
- Consider limiting the number of lockup buckets or implementing a mechanism to handle gas limits more effectively.
- Strengthen access control measures to ensure that only authorized contracts can interact with sensitive functions.
- Review and refactor areas using unchecked arithmetic to ensure safety.
- Improve error handling to provide more context in error messages.
- Implement a clear strategy for managing incoming ETH to prevent unexpected behavior.

By addressing these vulnerabilities, the FETH contract can enhance its security posture and provide a safer environment for users to interact with wrapped ETH.

[2024-26-08 14:55:47 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-26-08 14:55:47 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"; import "@openzeppelin/contracts/utils/math/Math.sol"; import "./libraries/LockedBalance.sol"; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = "Foundation Wrapped Ether";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = "FETH"; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '/\n  ･\n   \u3000★\n      ･ ｡\n        \u3000･\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 \u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000 ☆ ｡･ﾟ.｡\n      \u3000\u3000\u3000ﾟ .｡☆｡★\u3000･\n\u200b\n                      .-:::::-.              -::---...```\n-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy\n-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo\n                                              ````\n   *\u3000\n      ･ ｡\n\u3000\u3000\u3000\u3000･\u3000\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 *\u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000* ☆ ｡･ﾟ*.｡\n      \u3000\u3000\u3000ﾟ *.｡☆｡★\u3000･\n    *\u3000\u3000ﾟ｡·*･｡ ﾟ*\n  \u3000\u3000\u3000☆ﾟ･｡°*. ﾟ\n\u3000 ･ ﾟ*｡･ﾟ★｡\n\u3000\u3000･ *ﾟ｡\u3000\u3000 *\n\u3000･ﾟ*｡★･\n ☆∴｡\u3000*\n･ ｡\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";\nimport "@openzeppelin/contracts/utils/math/Math.sol";\n\nimport "./libraries/LockedBalance.sol";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Burn_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account\'s info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address =&gt; uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address =&gt; AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation Wrapped Ether\n   */\n  string public constant name = "Foundation Wrapped Ether";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = "FETH";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for thefromaccount.\n   * @param amount The max amount of tokens which can be spent by thespenderaccount.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account\'s total FETH balance.\n   * @param account The account which has access to the FETH after theexpiration.\n   * @param expiration The time at which thefromaccount will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account\'s total FETH balance,\n   * this may be lower thanamountif available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it\'s only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user\'s account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user\'s FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Initializes variables which may differ on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for whenBalanceLocked, in seconds.\n   */\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (viamsg.value) to the contract performs adepositinto the user\'s account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves aspenderas an operator with permissions to transfer from your account.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from themsg.sender\'s account.\n   * @param amount The max number of FETH tokens frommsg.sender\'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and credit theaccountprovided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user\'s account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked fromunlockFrom\'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=lockupAmountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account\'s FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param amount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=amountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as withbuy.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked fromaccount.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user\'s available balance and returns ETH to the caller.\n   * @dev Used by the market when a user\'s available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted fromunlockFrom\'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user\'s account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user\'s offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if themsg.senderhas approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Burn_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from thefromaccounts available balance\n   * and send ETH to the destination address, if themsg.senderhas approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    if (accountInfo.allowance[msg.sender] != type(uint256).max) {\n      if (accountInfo.allowance[msg.sender] &lt; amount) {\n        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        accountInfo.allowance[msg.sender] -= amount;\n      }\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account\'s available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    // Free from escrow in order to consider any expired escrow balance\n    if (accountInfo.freedBalance &lt; amount) {\n      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance -= uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that\'s the new start index\n      if (escrow.expiration &gt;= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account\'s FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is &lt;= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value &lt; amount) {\n      // The check above prevents underflow with delta.\n      unchecked {\n        uint256 delta = amount - msg.value;\n        if (accountInfo.freedBalance &lt; delta) {\n          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n        }\n        // The check above prevents underflow of freed balance.\n        accountInfo.freedBalance -= uint96(delta);\n      }\n    } else if (msg.value != amount) {\n      // There\'s no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always &lt; 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration &gt; type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be &lt; 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be &lt; 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration &lt; block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it\'s the last one\n        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n          // The number of escrow buckets will never overflow 32 bits.\n          unchecked {\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount &lt; amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount &gt; escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from theaccount\'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from theaccount\'s balance.\n   * @return amount The number of tokens theoperatoris still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    return accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    return foundationMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @devexpires.length==amounts.length\n   * andamounts[i]is the number of tokens which will expire atexpires[i].\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev UsebalanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   /\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   /\n  function totalSupply() external view returns (uint256 supply) {\n    / It is possible for this to diverge from the total token count by transferring ETH on self destruct\n       but this is on-par with the WETH implementation and done for gas savings. /\n    return address(this).balance;\n  }\n}\n', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-26-08 14:55:47 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"; import "@openzeppelin/contracts/utils/math/Math.sol"; import "./libraries/LockedBalance.sol"; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = "Foundation Wrapped Ether";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = "FETH"; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-26-08 14:55:47 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "/*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-26-08 14:56:01 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-26-08 14:56:01 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15235
completion_tokens: 911
total_tokens: 16146
cost: $-1.000000


[2024-26-08 14:56:01 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.]

### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract does not implement a reentrancy guard in functions that transfer ETH, such as `marketWithdrawFrom`, `marketWithdrawLocked`, and `withdrawFrom`. This could allow an attacker to recursively call these functions before the state changes are completed, potentially draining funds from the contract.

RECOMMENDED MITIGATION: Implement a reentrancy guard using the `nonReentrant` modifier from OpenZeppelin's `ReentrancyGuard` contract. This should be applied to any function that transfers ETH or modifies state before transferring ETH.
```

### VULNERABILITY: Lack of Input Validation
```
DETAILED DESCRIPTION: The function `marketChangeLockup` does not validate the `unlockExpiration` parameter. If an invalid expiration timestamp is provided (e.g., in the past), it could lead to unexpected behavior or allow the unlocking of tokens that should remain locked.

RECOMMENDED MITIGATION: Add checks to ensure that `unlockExpiration` is greater than the current block timestamp before proceeding with the unlock operation.
```

### VULNERABILITY: Gas Limit and Looping
```
DETAILED DESCRIPTION: The functions that iterate through lockup buckets, such as `_freeFromEscrow` and `_marketLockupFor`, could potentially run into gas limit issues if there are many lockup buckets. The contract allows for up to 25 buckets, but if the logic is not carefully managed, it could lead to excessive gas consumption.

RECOMMENDED MITIGATION: Ensure that the logic for managing lockup buckets is efficient and does not allow for excessive looping. Consider using a fixed-size array or other data structures that limit the number of iterations.
```

### VULNERABILITY: Improper Error Handling
```
DETAILED DESCRIPTION: The contract uses custom error messages for various conditions, but it does not handle all possible failure cases properly. For example, in the `marketWithdrawFrom` function, if the `sendValue` fails, it does not revert the transaction, which could leave the contract in an inconsistent state.

RECOMMENDED MITIGATION: Ensure that all external calls (like `sendValue`) are followed by checks to confirm success, and revert the transaction if they fail. This will help maintain the integrity of the contract's state.
```

### VULNERABILITY: Insufficient Access Control
```
DETAILED DESCRIPTION: The `onlyFoundationMarket` modifier is used to restrict access to certain functions, but there is no mechanism to ensure that the `foundationMarket` address is set correctly during contract deployment. If an incorrect address is set, it could lead to unauthorized access.

RECOMMENDED MITIGATION: Implement checks during the constructor to ensure that the `foundationMarket` address is a valid contract address and consider adding an admin function to update it if necessary.
```

### VULNERABILITY: Potential Integer Overflow/Underflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.0 introduced built-in overflow and underflow checks, there are still areas in the contract where unchecked arithmetic is used (e.g., in `_deductBalanceFrom`). If the logic is not carefully managed, it could lead to unexpected behavior.

RECOMMENDED MITIGATION: Review all instances of unchecked arithmetic and ensure that they are necessary. If possible, use safe math operations or revert to using checked arithmetic to prevent any potential issues.
```

### VULNERABILITY: Lack of Events for Critical State Changes
```
DETAILED DESCRIPTION: The contract does not emit events for critical state changes, such as when tokens are deposited or withdrawn. This can make it difficult for users and external applications to track the state of the contract.

RECOMMENDED MITIGATION: Emit events for all significant state changes, including deposits, withdrawals, and lockup changes. This will improve transparency and allow for better tracking of contract activity.
```

### VULNERABILITY: Unchecked External Call
```
DETAILED DESCRIPTION: The contract uses `sendValue` for transferring ETH, which does not check for success. If the recipient is a contract that reverts, the transaction will fail, but the state changes made before the call will not be reverted.

RECOMMENDED MITIGATION: Use `call` instead of `sendValue` and check for success. This will allow for better error handling and ensure that state changes are reverted if the transfer fails.
```

<INFO> Analysis Complete.

[2024-26-08 14:56:01 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract does not implement a reentrancy guard in functions that transfer ETH, such as `marketWithdrawFrom`, `marketWithdrawLocked`, and `withdrawFrom`. This could allow an attacker to recursively call these functions before the state changes are completed, potentially draining funds from the contract.

RECOMMENDED MITIGATION: Implement a reentrancy guard using the `nonReentrant` modifier from OpenZeppelin's `ReentrancyGuard` contract. This should be applied to any function that transfers ETH or modifies state before transferring ETH.
```

### VULNERABILITY: Lack of Input Validation
```
DETAILED DESCRIPTION: The function `marketChangeLockup` does not validate the `unlockExpiration` parameter. If an invalid expiration timestamp is provided (e.g., in the past), it could lead to unexpected behavior or allow the unlocking of tokens that should remain locked.

RECOMMENDED MITIGATION: Add checks to ensure that `unlockExpiration` is greater than the current block timestamp before proceeding with the unlock operation.
```

### VULNERABILITY: Gas Limit and Looping
```
DETAILED DESCRIPTION: The functions that iterate through lockup buckets, such as `_freeFromEscrow` and `_marketLockupFor`, could potentially run into gas limit issues if there are many lockup buckets. The contract allows for up to 25 buckets, but if the logic is not carefully managed, it could lead to excessive gas consumption.

RECOMMENDED MITIGATION: Ensure that the logic for managing lockup buckets is efficient and does not allow for excessive looping. Consider using a fixed-size array or other data structures that limit the number of iterations.
```

### VULNERABILITY: Improper Error Handling
```
DETAILED DESCRIPTION: The contract uses custom error messages for various conditions, but it does not handle all possible failure cases properly. For example, in the `marketWithdrawFrom` function, if the `sendValue` fails, it does not revert the transaction, which could leave the contract in an inconsistent state.

RECOMMENDED MITIGATION: Ensure that all external calls (like `sendValue`) are followed by checks to confirm success, and revert the transaction if they fail. This will help maintain the integrity of the contract's state.
```

### VULNERABILITY: Insufficient Access Control
```
DETAILED DESCRIPTION: The `onlyFoundationMarket` modifier is used to restrict access to certain functions, but there is no mechanism to ensure that the `foundationMarket` address is set correctly during contract deployment. If an incorrect address is set, it could lead to unauthorized access.

RECOMMENDED MITIGATION: Implement checks during the constructor to ensure that the `foundationMarket` address is a valid contract address and consider adding an admin function to update it if necessary.
```

### VULNERABILITY: Potential Integer Overflow/Underflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.0 introduced built-in overflow and underflow checks, there are still areas in the contract where unchecked arithmetic is used (e.g., in `_deductBalanceFrom`). If the logic is not carefully managed, it could lead to unexpected behavior.

RECOMMENDED MITIGATION: Review all instances of unchecked arithmetic and ensure that they are necessary. If possible, use safe math operations or revert to using checked arithmetic to prevent any potential issues.
```

### VULNERABILITY: Lack of Events for Critical State Changes
```
DETAILED DESCRIPTION: The contract does not emit events for critical state changes, such as when tokens are deposited or withdrawn. This can make it difficult for users and external applications to track the state of the contract.

RECOMMENDED MITIGATION: Emit events for all significant state changes, including deposits, withdrawals, and lockup changes. This will improve transparency and allow for better tracking of contract activity.
```

### VULNERABILITY: Unchecked External Call
```
DETAILED DESCRIPTION: The contract uses `sendValue` for transferring ETH, which does not check for success. If the recipient is a contract that reverts, the transaction will fail, but the state changes made before the call will not be reverted.

RECOMMENDED MITIGATION: Use `call` instead of `sendValue` and check for success. This will allow for better error handling and ensure that state changes are reverted if the transfer fails.
```

<INFO> Analysis Complete.

[2024-26-08 14:56:01 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-26-08 14:56:01 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"; import "@openzeppelin/contracts/utils/math/Math.sol"; import "./libraries/LockedBalance.sol"; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = "Foundation Wrapped Ether";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = "FETH"; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-26-08 14:56:01 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"; import "@openzeppelin/contracts/utils/math/Math.sol"; import "./libraries/LockedBalance.sol"; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = "Foundation Wrapped Ether";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = "FETH"; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-26-08 14:56:01 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-26-08 14:56:06 INFO] Retrying request to /chat/completions in 0.866060 seconds
[2024-26-08 14:56:23 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-26-08 14:56:23 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7676
completion_tokens: 812
total_tokens: 8488
cost: $-1.000000


[2024-26-08 14:56:23 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.]

Based on the provided Solidity smart contract code for the Foundation Wrapped Ether (FETH) token, here is a summary of the potential security vulnerabilities identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not implement a reentrancy guard, which could lead to reentrancy attacks during external calls (e.g., when transferring ETH). This is particularly concerning in functions like `withdrawFrom`, `marketWithdrawFrom`, and `marketWithdrawLocked`.

2. **Insufficient Input Validation**:
   - The contract relies on certain assumptions about the input parameters (e.g., `amount`, `expiration`). If these parameters are manipulated, it could lead to unexpected behavior or contract state corruption.

3. **Gas Limit Issues**:
   - The contract uses loops to process escrow buckets, which may lead to gas limit issues if a user has a large number of lockup buckets. This could cause transactions to fail due to exceeding the block gas limit.

4. **Potential for Integer Overflow/Underflow**:
   - Although Solidity 0.8.0 and above has built-in overflow/underflow checks, there are still areas where unchecked arithmetic is used (e.g., in `_deductBalanceFrom`, `_marketLockupFor`). Care should be taken to ensure that these operations do not lead to unexpected results.

5. **Lack of Access Control**:
   - The contract uses a single address (`foundationMarket`) to manage lockups, which could be a single point of failure. If this address is compromised, it could lead to unauthorized access to user funds.

6. **Improper Error Handling**:
   - The contract uses custom error messages but does not provide sufficient context for debugging. This can make it difficult to identify the root cause of issues during contract execution.

7. **Potential for Denial of Service (DoS)**:
   - If a user has a large number of lockup buckets, it may lead to DoS by making it impossible to process their transactions due to gas limits.

8. **Lack of Events for Critical State Changes**:
   - While there are events for some actions, there may be critical state changes that do not emit events, making it difficult to track the state of the contract.

### Comprehensive Analysis Report:

The FETH contract is a complex implementation of an ERC-20 token with additional features for locking and managing ETH deposits. While it provides useful functionality, several security vulnerabilities could expose users to risks. 

1. **Reentrancy attacks** are a significant concern, especially in functions that involve transferring ETH. Implementing a reentrancy guard would mitigate this risk.

2. **Input validation** should be enhanced to ensure that all parameters are within expected ranges and formats. This would prevent potential manipulation and unexpected behavior.

3. The use of **loops** to manage escrow buckets could lead to gas limit issues, especially for users with many lockups. Consideration should be given to optimizing this logic or limiting the number of lockups.

4. Although Solidity provides built-in protections against overflow/underflow, the use of unchecked arithmetic in certain areas should be reviewed to ensure that it does not lead to unexpected results.

5. The reliance on a single address for managing lockups poses a **centralization risk**. Implementing multi-signature control or a decentralized governance mechanism could enhance security.

6. **Error handling** could be improved by providing more context in error messages, making it easier to debug issues.

7. The potential for **Denial of Service** due to gas limits should be addressed by limiting the number of lockup buckets or optimizing the logic for processing them.

8. Finally, ensuring that all critical state changes emit events will improve transparency and allow for better tracking of contract activity.

In conclusion, while the FETH contract provides valuable functionality, it is essential to address these vulnerabilities to enhance security and ensure user trust. A thorough audit and testing process should be conducted before deployment to mitigate these risks effectively.

[2024-26-08 14:56:23 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the Foundation Wrapped Ether (FETH) token, here is a summary of the potential security vulnerabilities identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not implement a reentrancy guard, which could lead to reentrancy attacks during external calls (e.g., when transferring ETH). This is particularly concerning in functions like `withdrawFrom`, `marketWithdrawFrom`, and `marketWithdrawLocked`.

2. **Insufficient Input Validation**:
   - The contract relies on certain assumptions about the input parameters (e.g., `amount`, `expiration`). If these parameters are manipulated, it could lead to unexpected behavior or contract state corruption.

3. **Gas Limit Issues**:
   - The contract uses loops to process escrow buckets, which may lead to gas limit issues if a user has a large number of lockup buckets. This could cause transactions to fail due to exceeding the block gas limit.

4. **Potential for Integer Overflow/Underflow**:
   - Although Solidity 0.8.0 and above has built-in overflow/underflow checks, there are still areas where unchecked arithmetic is used (e.g., in `_deductBalanceFrom`, `_marketLockupFor`). Care should be taken to ensure that these operations do not lead to unexpected results.

5. **Lack of Access Control**:
   - The contract uses a single address (`foundationMarket`) to manage lockups, which could be a single point of failure. If this address is compromised, it could lead to unauthorized access to user funds.

6. **Improper Error Handling**:
   - The contract uses custom error messages but does not provide sufficient context for debugging. This can make it difficult to identify the root cause of issues during contract execution.

7. **Potential for Denial of Service (DoS)**:
   - If a user has a large number of lockup buckets, it may lead to DoS by making it impossible to process their transactions due to gas limits.

8. **Lack of Events for Critical State Changes**:
   - While there are events for some actions, there may be critical state changes that do not emit events, making it difficult to track the state of the contract.

### Comprehensive Analysis Report:

The FETH contract is a complex implementation of an ERC-20 token with additional features for locking and managing ETH deposits. While it provides useful functionality, several security vulnerabilities could expose users to risks. 

1. **Reentrancy attacks** are a significant concern, especially in functions that involve transferring ETH. Implementing a reentrancy guard would mitigate this risk.

2. **Input validation** should be enhanced to ensure that all parameters are within expected ranges and formats. This would prevent potential manipulation and unexpected behavior.

3. The use of **loops** to manage escrow buckets could lead to gas limit issues, especially for users with many lockups. Consideration should be given to optimizing this logic or limiting the number of lockups.

4. Although Solidity provides built-in protections against overflow/underflow, the use of unchecked arithmetic in certain areas should be reviewed to ensure that it does not lead to unexpected results.

5. The reliance on a single address for managing lockups poses a **centralization risk**. Implementing multi-signature control or a decentralized governance mechanism could enhance security.

6. **Error handling** could be improved by providing more context in error messages, making it easier to debug issues.

7. The potential for **Denial of Service** due to gas limits should be addressed by limiting the number of lockup buckets or optimizing the logic for processing them.

8. Finally, ensuring that all critical state changes emit events will improve transparency and allow for better tracking of contract activity.

In conclusion, while the FETH contract provides valuable functionality, it is essential to address these vulnerabilities to enhance security and ensure user trust. A thorough audit and testing process should be conducted before deployment to mitigate these risks effectively.

[2024-26-08 14:56:23 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-26-08 14:56:23 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"; import "@openzeppelin/contracts/utils/math/Math.sol"; import "./libraries/LockedBalance.sol"; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = "Foundation Wrapped Ether";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = "FETH"; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '/\n  ･\n   \u3000★\n      ･ ｡\n        \u3000･\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 \u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000 ☆ ｡･ﾟ.｡\n      \u3000\u3000\u3000ﾟ .｡☆｡★\u3000･\n\u200b\n                      .-:::::-.              -::---...```\n-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy\n-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo\n                                              ````\n   *\u3000\n      ･ ｡\n\u3000\u3000\u3000\u3000･\u3000\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 *\u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000* ☆ ｡･ﾟ*.｡\n      \u3000\u3000\u3000ﾟ *.｡☆｡★\u3000･\n    *\u3000\u3000ﾟ｡·*･｡ ﾟ*\n  \u3000\u3000\u3000☆ﾟ･｡°*. ﾟ\n\u3000 ･ ﾟ*｡･ﾟ★｡\n\u3000\u3000･ *ﾟ｡\u3000\u3000 *\n\u3000･ﾟ*｡★･\n ☆∴｡\u3000*\n･ ｡\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";\nimport "@openzeppelin/contracts/utils/math/Math.sol";\n\nimport "./libraries/LockedBalance.sol";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Burn_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account\'s info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address =&gt; uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address =&gt; AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation Wrapped Ether\n   */\n  string public constant name = "Foundation Wrapped Ether";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = "FETH";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for thefromaccount.\n   * @param amount The max amount of tokens which can be spent by thespenderaccount.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account\'s total FETH balance.\n   * @param account The account which has access to the FETH after theexpiration.\n   * @param expiration The time at which thefromaccount will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account\'s total FETH balance,\n   * this may be lower thanamountif available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it\'s only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user\'s account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user\'s FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Initializes variables which may differ on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for whenBalanceLocked, in seconds.\n   */\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (viamsg.value) to the contract performs adepositinto the user\'s account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves aspenderas an operator with permissions to transfer from your account.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from themsg.sender\'s account.\n   * @param amount The max number of FETH tokens frommsg.sender\'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and credit theaccountprovided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user\'s account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked fromunlockFrom\'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=lockupAmountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account\'s FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param amount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=amountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as withbuy.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked fromaccount.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user\'s available balance and returns ETH to the caller.\n   * @dev Used by the market when a user\'s available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted fromunlockFrom\'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user\'s account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user\'s offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if themsg.senderhas approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Burn_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from thefromaccounts available balance\n   * and send ETH to the destination address, if themsg.senderhas approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    if (accountInfo.allowance[msg.sender] != type(uint256).max) {\n      if (accountInfo.allowance[msg.sender] &lt; amount) {\n        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        accountInfo.allowance[msg.sender] -= amount;\n      }\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account\'s available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    // Free from escrow in order to consider any expired escrow balance\n    if (accountInfo.freedBalance &lt; amount) {\n      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance -= uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that\'s the new start index\n      if (escrow.expiration &gt;= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account\'s FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is &lt;= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value &lt; amount) {\n      // The check above prevents underflow with delta.\n      unchecked {\n        uint256 delta = amount - msg.value;\n        if (accountInfo.freedBalance &lt; delta) {\n          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n        }\n        // The check above prevents underflow of freed balance.\n        accountInfo.freedBalance -= uint96(delta);\n      }\n    } else if (msg.value != amount) {\n      // There\'s no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always &lt; 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration &gt; type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be &lt; 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be &lt; 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration &lt; block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it\'s the last one\n        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n          // The number of escrow buckets will never overflow 32 bits.\n          unchecked {\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount &lt; amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount &gt; escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from theaccount\'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from theaccount\'s balance.\n   * @return amount The number of tokens theoperatoris still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    return accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    return foundationMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @devexpires.length==amounts.length\n   * andamounts[i]is the number of tokens which will expire atexpires[i].\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev UsebalanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   /\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   /\n  function totalSupply() external view returns (uint256 supply) {\n    / It is possible for this to diverge from the total token count by transferring ETH on self destruct\n       but this is on-par with the WETH implementation and done for gas savings. /\n    return address(this).balance;\n  }\n}\n', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-26-08 14:56:23 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"; import "@openzeppelin/contracts/utils/math/Math.sol"; import "./libraries/LockedBalance.sol"; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = "Foundation Wrapped Ether";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = "FETH"; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-26-08 14:56:23 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "/*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-26-08 14:56:37 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-26-08 14:56:37 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15235
completion_tokens: 947
total_tokens: 16182
cost: $-1.000000


[2024-26-08 14:56:37 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.]

### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract allows external calls to be made (e.g., in the `marketWithdrawFrom` and `marketWithdrawLocked` functions) after state changes have occurred. This could allow a malicious contract to re-enter the function and manipulate the state before the original function call completes, potentially draining funds.

RECOMMENDED MITIGATION: Implement a non-reentrant guard using a mutex pattern or OpenZeppelin's `ReentrancyGuard` to prevent reentrant calls to sensitive functions.
```

### VULNERABILITY: Insufficient Input Validation
```
DETAILED DESCRIPTION: In the `marketChangeLockup` function, there is a lack of checks to ensure that the `unlockFrom` address is valid and that the `unlockAmount` is not greater than the available balance. This could lead to unexpected behavior or allow a user to attempt to unlock more than they have.

RECOMMENDED MITIGATION: Add checks to validate that `unlockFrom` is not the zero address and that `unlockAmount` does not exceed the available balance of the `unlockFrom` account.
```

### VULNERABILITY: Gas Limit and Loops
```
DETAILED DESCRIPTION: The `_freeFromEscrow` and `_marketLockupFor` functions contain loops that iterate over potentially unbounded data structures (the lockup buckets). If the number of buckets exceeds the expected limit, this could lead to gas limit issues and transaction failures.

RECOMMENDED MITIGATION: Ensure that the maximum number of lockup buckets is enforced and consider using a fixed-size array or a more gas-efficient data structure to manage lockups.
```

### VULNERABILITY: Integer Overflow/Underflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.0 has built-in overflow and underflow checks, there are still areas in the code where unchecked arithmetic is used (e.g., in the `_deductBalanceFrom` function). If the assumptions about the values are incorrect, this could lead to unexpected behavior.

RECOMMENDED MITIGATION: Review all unchecked arithmetic operations to ensure they are safe and consider using SafeMath for clarity, even though it's not strictly necessary in Solidity 0.8.0.
```

### VULNERABILITY: Lack of Access Control
```
DETAILED DESCRIPTION: The contract relies on the `onlyFoundationMarket` modifier to restrict access to certain functions. If the `foundationMarket` address is compromised or incorrectly set, it could lead to unauthorized access to sensitive functions.

RECOMMENDED MITIGATION: Implement additional access control mechanisms, such as multi-signature wallets or time-locks, to ensure that the `foundationMarket` address is secure and cannot be manipulated.
```

### VULNERABILITY: Improper Error Handling
```
DETAILED DESCRIPTION: The contract uses custom error messages but does not provide sufficient context in some cases (e.g., `FETH_Escrow_Not_Found`). This could make debugging difficult if an error occurs.

RECOMMENDED MITIGATION: Enhance error messages to include more context about the failure, such as the account address or the expected state, to aid in debugging and provide better feedback to users.
```

### VULNERABILITY: Unchecked Return Values
```
DETAILED DESCRIPTION: The contract uses `sendValue` from the `AddressUpgradeable` library, which does not check the return value. If the transfer fails, it could lead to funds being stuck in the contract.

RECOMMENDED MITIGATION: Use `call` with proper error handling to ensure that any ETH transfers succeed, or implement a fallback mechanism to handle failed transfers gracefully.
```

### VULNERABILITY: Potential for Locked Funds
```
DETAILED DESCRIPTION: The contract allows for funds to be locked for a period of 24-25 hours. If a user mistakenly locks funds or if there is a bug in the locking mechanism, they may be unable to access their funds.

RECOMMENDED MITIGATION: Implement a mechanism for users to unlock their funds early under certain conditions or provide a clear way for users to understand the locking mechanism and its implications.
```

### VULNERABILITY: Lack of Events for Critical Actions
```
DETAILED DESCRIPTION: While the contract emits events for some actions, there are critical actions (like deposits and withdrawals) that may not have sufficient event logging, making it difficult to track the state of the contract.

RECOMMENDED MITIGATION: Ensure that all critical state changes, especially those involving funds, emit appropriate events to allow for better tracking and transparency.
```

<INFO> Analysis Complete.

[2024-26-08 14:56:37 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract allows external calls to be made (e.g., in the `marketWithdrawFrom` and `marketWithdrawLocked` functions) after state changes have occurred. This could allow a malicious contract to re-enter the function and manipulate the state before the original function call completes, potentially draining funds.

RECOMMENDED MITIGATION: Implement a non-reentrant guard using a mutex pattern or OpenZeppelin's `ReentrancyGuard` to prevent reentrant calls to sensitive functions.
```

### VULNERABILITY: Insufficient Input Validation
```
DETAILED DESCRIPTION: In the `marketChangeLockup` function, there is a lack of checks to ensure that the `unlockFrom` address is valid and that the `unlockAmount` is not greater than the available balance. This could lead to unexpected behavior or allow a user to attempt to unlock more than they have.

RECOMMENDED MITIGATION: Add checks to validate that `unlockFrom` is not the zero address and that `unlockAmount` does not exceed the available balance of the `unlockFrom` account.
```

### VULNERABILITY: Gas Limit and Loops
```
DETAILED DESCRIPTION: The `_freeFromEscrow` and `_marketLockupFor` functions contain loops that iterate over potentially unbounded data structures (the lockup buckets). If the number of buckets exceeds the expected limit, this could lead to gas limit issues and transaction failures.

RECOMMENDED MITIGATION: Ensure that the maximum number of lockup buckets is enforced and consider using a fixed-size array or a more gas-efficient data structure to manage lockups.
```

### VULNERABILITY: Integer Overflow/Underflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.0 has built-in overflow and underflow checks, there are still areas in the code where unchecked arithmetic is used (e.g., in the `_deductBalanceFrom` function). If the assumptions about the values are incorrect, this could lead to unexpected behavior.

RECOMMENDED MITIGATION: Review all unchecked arithmetic operations to ensure they are safe and consider using SafeMath for clarity, even though it's not strictly necessary in Solidity 0.8.0.
```

### VULNERABILITY: Lack of Access Control
```
DETAILED DESCRIPTION: The contract relies on the `onlyFoundationMarket` modifier to restrict access to certain functions. If the `foundationMarket` address is compromised or incorrectly set, it could lead to unauthorized access to sensitive functions.

RECOMMENDED MITIGATION: Implement additional access control mechanisms, such as multi-signature wallets or time-locks, to ensure that the `foundationMarket` address is secure and cannot be manipulated.
```

### VULNERABILITY: Improper Error Handling
```
DETAILED DESCRIPTION: The contract uses custom error messages but does not provide sufficient context in some cases (e.g., `FETH_Escrow_Not_Found`). This could make debugging difficult if an error occurs.

RECOMMENDED MITIGATION: Enhance error messages to include more context about the failure, such as the account address or the expected state, to aid in debugging and provide better feedback to users.
```

### VULNERABILITY: Unchecked Return Values
```
DETAILED DESCRIPTION: The contract uses `sendValue` from the `AddressUpgradeable` library, which does not check the return value. If the transfer fails, it could lead to funds being stuck in the contract.

RECOMMENDED MITIGATION: Use `call` with proper error handling to ensure that any ETH transfers succeed, or implement a fallback mechanism to handle failed transfers gracefully.
```

### VULNERABILITY: Potential for Locked Funds
```
DETAILED DESCRIPTION: The contract allows for funds to be locked for a period of 24-25 hours. If a user mistakenly locks funds or if there is a bug in the locking mechanism, they may be unable to access their funds.

RECOMMENDED MITIGATION: Implement a mechanism for users to unlock their funds early under certain conditions or provide a clear way for users to understand the locking mechanism and its implications.
```

### VULNERABILITY: Lack of Events for Critical Actions
```
DETAILED DESCRIPTION: While the contract emits events for some actions, there are critical actions (like deposits and withdrawals) that may not have sufficient event logging, making it difficult to track the state of the contract.

RECOMMENDED MITIGATION: Ensure that all critical state changes, especially those involving funds, emit appropriate events to allow for better tracking and transparency.
```

<INFO> Analysis Complete.

[2024-26-08 14:56:37 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-26-08 14:56:37 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"; import "@openzeppelin/contracts/utils/math/Math.sol"; import "./libraries/LockedBalance.sol"; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = "Foundation Wrapped Ether";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = "FETH"; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-26-08 14:56:37 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"; import "@openzeppelin/contracts/utils/math/Math.sol"; import "./libraries/LockedBalance.sol"; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = "Foundation Wrapped Ether";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = "FETH"; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-26-08 14:56:37 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-26-08 14:56:48 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-26-08 14:56:48 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7676
completion_tokens: 763
total_tokens: 8439
cost: $-1.000000


[2024-26-08 14:56:48 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.]

Based on the provided Solidity smart contract code for the `FETH` contract, here is a summary of the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities

1. **Reentrancy Risk**:
   - The contract does not implement a reentrancy guard in functions that involve transferring ETH, such as `withdrawAvailableBalance`, `withdrawFrom`, and `marketWithdrawFrom`. This could allow an attacker to exploit the contract by recursively calling these functions before the state is updated.

2. **Insufficient Input Validation**:
   - The contract lacks comprehensive checks on the input parameters for functions like `marketChangeLockup`, `marketLockupFor`, and `marketUnlockFor`. This could lead to unexpected behavior if invalid data is passed.

3. **Gas Limit Issues**:
   - The `_freeFromEscrow` function contains a loop that iterates through potentially many lockup buckets. If there are many buckets, this could lead to exceeding the gas limit, causing transactions to fail.

4. **Potential Integer Overflow/Underflow**:
   - Although Solidity 0.8.0 and above has built-in overflow/underflow checks, the unchecked blocks in the code (e.g., in `_deductBalanceFrom`, `_marketLockupFor`) may still lead to logical errors if not handled carefully.

5. **Lack of Access Control**:
   - The contract relies on the `onlyFoundationMarket` modifier to restrict access to certain functions. If the `foundationMarket` address is compromised, it could lead to unauthorized access to sensitive functions.

6. **Error Handling**:
   - The contract uses custom error messages, which is a good practice, but it lacks detailed logging or events for certain operations that could help in debugging and tracking state changes.

7. **Potential for Locked Funds**:
   - The design allows for funds to be locked for an extended period (24-25 hours). If the market contract is not functioning correctly, users may be unable to access their funds.

### Comprehensive Analysis Report

The `FETH` contract is designed to wrap ETH and provide additional functionality for locking tokens. While the contract implements several good practices, such as using OpenZeppelin libraries and custom error messages, it also presents several security vulnerabilities that need to be addressed.

1. **Reentrancy**: The absence of a reentrancy guard in critical functions poses a significant risk. Implementing the Checks-Effects-Interactions pattern or using a reentrancy guard can mitigate this risk.

2. **Input Validation**: Strengthening input validation across all functions will enhance the contract's robustness against unexpected inputs and potential exploits.

3. **Gas Limit Concerns**: The potential for gas limit issues in loops should be addressed by limiting the number of iterations or restructuring the logic to avoid long-running operations.

4. **Integer Handling**: While Solidity's built-in checks reduce the risk of overflow/underflow, careful handling of unchecked operations is necessary to avoid logical errors.

5. **Access Control**: The reliance on a single market address for critical functions necessitates a thorough review of the security of that address. Implementing multi-signature wallets or additional access controls could enhance security.

6. **Error Handling and Logging**: Improving error handling and adding events for significant state changes will aid in tracking and debugging the contract's behavior.

7. **User Fund Accessibility**: The locking mechanism should be designed to ensure that users can access their funds in a timely manner, even if the market contract encounters issues.

In conclusion, while the `FETH` contract has a solid foundation, addressing the identified vulnerabilities will significantly enhance its security and reliability. A thorough audit and testing phase should be conducted before deployment to ensure that all potential risks are mitigated.

[2024-26-08 14:56:48 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `FETH` contract, here is a summary of the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities

1. **Reentrancy Risk**:
   - The contract does not implement a reentrancy guard in functions that involve transferring ETH, such as `withdrawAvailableBalance`, `withdrawFrom`, and `marketWithdrawFrom`. This could allow an attacker to exploit the contract by recursively calling these functions before the state is updated.

2. **Insufficient Input Validation**:
   - The contract lacks comprehensive checks on the input parameters for functions like `marketChangeLockup`, `marketLockupFor`, and `marketUnlockFor`. This could lead to unexpected behavior if invalid data is passed.

3. **Gas Limit Issues**:
   - The `_freeFromEscrow` function contains a loop that iterates through potentially many lockup buckets. If there are many buckets, this could lead to exceeding the gas limit, causing transactions to fail.

4. **Potential Integer Overflow/Underflow**:
   - Although Solidity 0.8.0 and above has built-in overflow/underflow checks, the unchecked blocks in the code (e.g., in `_deductBalanceFrom`, `_marketLockupFor`) may still lead to logical errors if not handled carefully.

5. **Lack of Access Control**:
   - The contract relies on the `onlyFoundationMarket` modifier to restrict access to certain functions. If the `foundationMarket` address is compromised, it could lead to unauthorized access to sensitive functions.

6. **Error Handling**:
   - The contract uses custom error messages, which is a good practice, but it lacks detailed logging or events for certain operations that could help in debugging and tracking state changes.

7. **Potential for Locked Funds**:
   - The design allows for funds to be locked for an extended period (24-25 hours). If the market contract is not functioning correctly, users may be unable to access their funds.

### Comprehensive Analysis Report

The `FETH` contract is designed to wrap ETH and provide additional functionality for locking tokens. While the contract implements several good practices, such as using OpenZeppelin libraries and custom error messages, it also presents several security vulnerabilities that need to be addressed.

1. **Reentrancy**: The absence of a reentrancy guard in critical functions poses a significant risk. Implementing the Checks-Effects-Interactions pattern or using a reentrancy guard can mitigate this risk.

2. **Input Validation**: Strengthening input validation across all functions will enhance the contract's robustness against unexpected inputs and potential exploits.

3. **Gas Limit Concerns**: The potential for gas limit issues in loops should be addressed by limiting the number of iterations or restructuring the logic to avoid long-running operations.

4. **Integer Handling**: While Solidity's built-in checks reduce the risk of overflow/underflow, careful handling of unchecked operations is necessary to avoid logical errors.

5. **Access Control**: The reliance on a single market address for critical functions necessitates a thorough review of the security of that address. Implementing multi-signature wallets or additional access controls could enhance security.

6. **Error Handling and Logging**: Improving error handling and adding events for significant state changes will aid in tracking and debugging the contract's behavior.

7. **User Fund Accessibility**: The locking mechanism should be designed to ensure that users can access their funds in a timely manner, even if the market contract encounters issues.

In conclusion, while the `FETH` contract has a solid foundation, addressing the identified vulnerabilities will significantly enhance its security and reliability. A thorough audit and testing phase should be conducted before deployment to ensure that all potential risks are mitigated.

[2024-26-08 14:56:51 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"; import "@openzeppelin/contracts/utils/math/Math.sol"; import "./libraries/LockedBalance.sol"; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = "Foundation Wrapped Ether";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = "FETH"; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '/\n  ･\n   \u3000★\n      ･ ｡\n        \u3000･\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 \u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000 ☆ ｡･ﾟ.｡\n      \u3000\u3000\u3000ﾟ .｡☆｡★\u3000･\n\u200b\n                      .-:::::-.              -::---...```\n-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy\n-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo\n                                              ````\n   *\u3000\n      ･ ｡\n\u3000\u3000\u3000\u3000･\u3000\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 *\u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000* ☆ ｡･ﾟ*.｡\n      \u3000\u3000\u3000ﾟ *.｡☆｡★\u3000･\n    *\u3000\u3000ﾟ｡·*･｡ ﾟ*\n  \u3000\u3000\u3000☆ﾟ･｡°*. ﾟ\n\u3000 ･ ﾟ*｡･ﾟ★｡\n\u3000\u3000･ *ﾟ｡\u3000\u3000 *\n\u3000･ﾟ*｡★･\n ☆∴｡\u3000*\n･ ｡\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";\nimport "@openzeppelin/contracts/utils/math/Math.sol";\n\nimport "./libraries/LockedBalance.sol";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Burn_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account\'s info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address =&gt; uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address =&gt; AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation Wrapped Ether\n   */\n  string public constant name = "Foundation Wrapped Ether";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = "FETH";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for thefromaccount.\n   * @param amount The max amount of tokens which can be spent by thespenderaccount.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account\'s total FETH balance.\n   * @param account The account which has access to the FETH after theexpiration.\n   * @param expiration The time at which thefromaccount will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account\'s total FETH balance,\n   * this may be lower thanamountif available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it\'s only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user\'s account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user\'s FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Initializes variables which may differ on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for whenBalanceLocked, in seconds.\n   */\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (viamsg.value) to the contract performs adepositinto the user\'s account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves aspenderas an operator with permissions to transfer from your account.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from themsg.sender\'s account.\n   * @param amount The max number of FETH tokens frommsg.sender\'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and credit theaccountprovided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user\'s account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked fromunlockFrom\'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=lockupAmountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account\'s FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param amount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=amountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as withbuy.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked fromaccount.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user\'s available balance and returns ETH to the caller.\n   * @dev Used by the market when a user\'s available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted fromunlockFrom\'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user\'s account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user\'s offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if themsg.senderhas approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Burn_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from thefromaccounts available balance\n   * and send ETH to the destination address, if themsg.senderhas approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    if (accountInfo.allowance[msg.sender] != type(uint256).max) {\n      if (accountInfo.allowance[msg.sender] &lt; amount) {\n        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        accountInfo.allowance[msg.sender] -= amount;\n      }\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account\'s available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    // Free from escrow in order to consider any expired escrow balance\n    if (accountInfo.freedBalance &lt; amount) {\n      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance -= uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that\'s the new start index\n      if (escrow.expiration &gt;= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account\'s FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is &lt;= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value &lt; amount) {\n      // The check above prevents underflow with delta.\n      unchecked {\n        uint256 delta = amount - msg.value;\n        if (accountInfo.freedBalance &lt; delta) {\n          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n        }\n        // The check above prevents underflow of freed balance.\n        accountInfo.freedBalance -= uint96(delta);\n      }\n    } else if (msg.value != amount) {\n      // There\'s no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always &lt; 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration &gt; type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be &lt; 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be &lt; 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration &lt; block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it\'s the last one\n        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n          // The number of escrow buckets will never overflow 32 bits.\n          unchecked {\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount &lt; amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount &gt; escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from theaccount\'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from theaccount\'s balance.\n   * @return amount The number of tokens theoperatoris still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    return accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    return foundationMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @devexpires.length==amounts.length\n   * andamounts[i]is the number of tokens which will expire atexpires[i].\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev UsebalanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   /\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   /\n  function totalSupply() external view returns (uint256 supply) {\n    / It is possible for this to diverge from the total token count by transferring ETH on self destruct\n       but this is on-par with the WETH implementation and done for gas savings. /\n    return address(this).balance;\n  }\n}\n', 'ideas': ' 1', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-26-08 14:56:51 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"; import "@openzeppelin/contracts/utils/math/Math.sol"; import "./libraries/LockedBalance.sol"; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = "Foundation Wrapped Ether";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = "FETH"; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-26-08 14:56:51 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "/*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

[2024-26-08 14:56:54 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-26-08 14:56:54 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15570
completion_tokens: 1
total_tokens: 15571
cost: $0.046714


[2024-26-08 14:56:54 INFO] Security Testing Engineer: **Security Testing Engineer<->Solidity Programming Expert on : TestBugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./libraries/LockedBalance.sol";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup "bucket".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = "Foundation Wrapped Ether";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = "FETH";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.]

###

[2024-26-08 14:56:54 INFO] **[Seminar Conclusion]**:

 ###

[2024-26-08 14:56:54 INFO] **[Post Info]**

Software Info: 

💰**cost**=$0.000000

🔨**version_updates**=1.0

📃**num_code_files**=0

🏞**num_png_files**=0

📚**num_doc_files**=5

📃**code_lines**=0

📋**env_lines**=-1

📒**manual_lines**=-1

🗣**num_utterances**=18

🤔**num_self_reflections**=1

❓**num_prompt_tokens**=122910

❗**num_completion_tokens**=5698

🌟**num_total_tokens**=128608

🕑**duration**=103.00s

ChatDev Starts (20240826145511)

ChatDev Ends (20240826145654)



